---
layout: default
redis: true
modal-id: 30000001
date: 2024-06-11
img: pexels-matt-g-623574593-17392834.jpg
alt: image-alt
project-date: June 2024
client: Start Bootstrap
category: redis
description: redis概览
---

### Redis 为什么这么快

<center>   
<img src="img/redis/guide/whyRedisFast.png" class="img-responsive img-centered" alt="image-alt">
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">Why is Redis so fast</div>
</center> 

### 完全基于内存    

&nbsp;&nbsp;&nbsp;&nbsp;redis作为一种内存导向型数据库系统，其关键特性在于将所有的数据实体，包括键值对及其相关的复杂数据结构，完全寄宿于内存之中。相较于依赖磁盘存储的传统数据库系统，redis巧妙地运用内存的高速读写特性，显著提升了系统的响应速度与整体性能表现。  
&nbsp;&nbsp;&nbsp;&nbsp;内存相对于磁盘具备无可比拟的读写速度优势，使得redis能够即时、高效地处理数据存取。在读取操作层面，redis无需经过耗时的磁盘I/O过程。只需要在内存空间内迅速定位所需数据，从而显著降低了访问延迟；而在写入操作时，redis同样直接作用于内存区域，新数据能立刻生效，仅在执行持久化策略时，例如RDB快照或AOF日志记录，数据才会被异步地或按需地同步到磁盘，以确保在系统重启后数据还能恢复，但此过程并不会妨碍redis在常规操作中维持其卓越的性能表现。  
&nbsp;&nbsp;&nbsp;&nbsp;服务器的内存是有限的，redis究竟是如何在有限内存空间中进行精细且高效的内存管理呢？  

**过期键删除**  
&nbsp;&nbsp;&nbsp;&nbsp;Redis支持为键设置过期时间（TTL），并且在键过期后会通过两种方式自动删除它们:  

  1. 惰性删除（Lazy Expire）：
  在访问某个键时，Redis会检查该键是否已经过期，如果已经过期，则在访问时将其删除。这意味胡总只有当客户端尝试访问过期键时，Redis才会执行删除操作。这种方式的优势在于避免了不必要的操作，只有在需要时才进行删除，但缺点是可能会导致过期键在一段时间内仍然占用内存。    
  2. 定期删除（Active Expire）： 
  Redis周期性地（默认每秒10次）随机抽取一部分键，并检查它们的过期时间。如果发现某个键已经过期，则立即删除。这种方式可以保证过期键在一定时间内被及时删除，避免了过期键长时间占用内存。但定期删除会带来额外的CPU消耗，因为需要再每次抽取时检查键的过期时间。    

&nbsp;&nbsp;&nbsp;&nbsp;这两种方式结合起来，可以有效地管理和清理过期键，保证Redis的内存使用在合理范围内。同时，我们在日常开发中可以根据具体业务场景和需求调整过期策略的配置，以达到最佳的性能和内存利用率。  

**内存淘汰策略**  
&nbsp;&nbsp;&nbsp;&nbsp;内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的maxmemory），Redis会根据预先设置的淘汰策略来选择要删除的键，从而释放内存空间。通过合理选择和配置内存淘汰策略，可以有效地管理内存使用，防止内存溢出，并保证系统的稳定性和性能。  
&nbsp;&nbsp;&nbsp;&nbsp;常见的内存淘汰策略：  
   1. LRU（最近最少使用）  
   LRU策略会删除最近最少被访问的键。Redis会记录每个键最好一次被访问的时间戳，并定期检查这些时间戳，选择最久未被访问的键进行删除。LRU策略适用于缓存场景，通常最久未被访问的键可能是最不常用的，因此删除这些键可以释放更多的内存空间。  
   2. LFU（最不经常使用）  
   LFU策略会删除最不经常被访问的键。Redis会记录每个键被访问的频率，并定期检查这些频率，选择访问频率最低的键进行删除。LFU策略适用于对访问频率较低的键进行淘汰，从而释放内存空间。
   3. TTL（键的过期时间）  
   TTL策略会删除已经过期的键。Redis会定期检查键的过期时间，并删除已经过期的键。通过设置键的过期时间，可以自动清理不再需要的数据，释放内存空间。
   4. 随机删除  
   随机删除策略会随机选择一些键进行删除。虽然这种策略不考虑键的使用频率或过期时间，但在某些情况下可能会是一种简单且有效地淘汰方式，尤其在内存空间不足时。
   5. 淘汰固定数量的键  
   淘汰固定数量的键策略会选择要删除的键数量，然后安装一定的规则（如LRU或LFU）来选择要删除的键。这种策略可以保证每次淘汰都释放固定数量的内存空间。  
   当Redis的内存使用达到配置的 **maxmemory** 限制时，就会触发内存淘汰策略，以释放内存空间。合理选择内存淘汰策略，并根据系统的需求设置 **maxmemory** 参数，可以有效地管理内存使用，保证系统的稳定性和性能。通过合理配置内存限制和内存淘汰策略，可以有效地管理Redis的内存使用，保证系统在内存空间不足时能够及时释放内存，避免因内存溢出而导致系统功能下降或者崩溃。  

> 修改内存 **maxmemory** 只需要在 **redis.config** 配置文件中配置 **maxmemory-policy** 参数即可。  

**内存碎片管理**  
&nbsp;&nbsp;&nbsp;&nbsp;内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。  
&nbsp;&nbsp;&nbsp;&nbsp;在Redis中，由于数据的增删改查操作不断进行，会导致内存空间中出现大量的内存碎片。这些内存碎片虽然单个很小，但如果积累起来会导致内存碎片化，降低内存利用率，影响系统的性能和稳定性。  
&nbsp;&nbsp;&nbsp;&nbsp;为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：
   1. 遍历内存空间：Redis会遍历整个内存空间，检查每个内存块的状态，包含已分配和未分配的内存块。
   2. 合并相邻的空闲内存块：Redis会尝试合并相邻的空间内存块，将它们合并成一个更大的内存块。这样可以减少内存碎片的数量，提高内存利用率。
   3. 移动数据：如果有必要，Redis可能会将数据从一个内存块移动到另一个内存块，以便更好地组织内存空间。这个过程可能会比较耗时，因为需要将数据从一个位置复制到另一个位置。
   4. 释放不再使用的内存块：最后，Redis会释放那些不再使用的内存块，以便它们可以被重新分配给新的数据。  

&nbsp;&nbsp;&nbsp;&nbsp;通过定期进行内存碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化的程度，提高内存利用率，从而提高系统的性能和稳定性。但是，内存碎片整理过程可能会消耗一定的系统资源，尤其在内存碎片较多的情况下。所以，通常情况下，Redis会选择在系统负载较低的时候进行碎片整理操作。  

### 高效的数据结构

&nbsp;&nbsp;&nbsp;&nbsp;Redis的每种对象其实都由 **对象结构（redisObject）** 与 **对应编码的数据结构** 组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。  

> https://markdown.com.cn/basic-syntax/blockquotes.html
> https://www.cnblogs.com/coderacademy/p/18099027
> https://redis.io/docs/latest/develop/data-types/
> https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html