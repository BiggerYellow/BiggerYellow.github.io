<!DOCTYPE html>
<html>
<!--    <script>-->
<!--        MathJax = {-->
<!--            tex: {-->
<!--                inlineMath: [['$', '$']],-->
<!--                displayMath: [['$$', '$$']],-->
<!--                processEnvironments: true,-->
<!--                processRefs: true-->
<!--            },-->
<!--            options: {-->
<!--                skipHtmlTags: ['noscript', 'style', 'textarea', 'pre', 'code'],-->
<!--                ignoreHtmlClass: 'tex2jax_ignore',-->
<!--                renderActions: {-->
<!--                    find_script_mathtex: [10, function (doc) {-->
<!--                        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {-->
<!--                            const display = !!node.type.match(/; *mode=display/);-->
<!--                            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);-->
<!--                            const text = document.createTextNode('');-->
<!--                            node.parentNode.replaceChild(text, node);-->
<!--                            math.start = { node: text, delim: '', n: 0 };-->
<!--                            math.end = { node: text, delim: '', n: 0 };-->
<!--                            doc.math.push(math);-->
<!--                        }-->
<!--                    }, '']-->
<!--                }-->
<!--            },-->
<!--            svg: {-->
<!--                fontCache: 'global'-->
<!--            }-->
<!--        };-->
<!--    </script>-->
<!--    <script id="MathJax-script" async src="https://cdn.staticfile.org/mathjax/3.0.1/es5/tex-svg.js"></script>-->

    <script type="text/javascript"
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
            // src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: true,
                processEnvironments: true,
                processRefs: true
            }
        };
    </script>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>黄天霸</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.">
    <meta name="keywords" content="your keywords, separated by commas" />
    <meta name="author" content="LastName FirstName">
    <link rel="canonical" href="http://localhost:4000/">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">

    <!-- Custom CSS & Bootstrap Core CSS - Uses Bootswatch Flatly Theme: http://bootswatch.com/flatly/ -->
    <link rel="stylesheet" href="/style.css">

    <!-- Google verification -->
    

    <!-- Bing Verification -->
    

    <!-- Custom Fonts -->
    <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css">
    <link href="//fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/font-awesome/css/rouge.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

    <body id="page-top" class="index">
       <!-- Navigation -->
    <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#page-top">黄天霸</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <!-- 栏目添加: 添加新栏目需要在这里加模板   -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li class="hidden">
                        <a href="#page-top"></a>
                    </li>
<!--                    <li class="page-scroll">-->
<!--                        <a href="#portfolio">Portfolio</a>-->
<!--                    </li> -->
                    <li class="page-scroll">
                        <a href="#home">Home</a>
                    </li>
                    <li class="page-scroll">
                        <a href="#spring">Spring</a>
                    </li>
                    <li class="page-scroll">
                        <a href="#springboot">SpringBoot</a>
                    </li>
                    <li class="page-scroll">
                        <a href="#algorithm">Algorithm</a>
                    </li>
                    <li class="page-scroll">
                        <a href="#mysql">Mysql</a>
                    </li>
                    <li class="page-scroll">
                        <a href="#redis">Redis</a>
                    </li>
                    <li class="page-scroll">
                        <a href="#ddd">DDD</a>
                    </li>
<!--                    <li class="page-scroll">-->
<!--                        <a href="#about">About</a>-->
<!--                    </li>-->
<!--                    <li class="page-scroll">-->
<!--                        <a href="#contact">Contact</a>-->
<!--                    </li>-->
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container-fluid -->
    </nav>
    <!-- Header -->
<header>
  <div class="container">
    <div class="row">
      <div class="col-lg-12">
        <img class="img-responsive" src="img/profile.png" alt="profile-pic" />
        <div class="intro-text">
          <span class="name">黄天霸</span>
          <hr class="star-light" />
          <span class="skills">FUCK ALL</span>
        </div>
      </div>
    </div>
  </div>
</header>

    <!-- 栏目添加: 添加新栏目需要在这里加模板  这里需要将html删除 注释掉还是会显示 -->
    
    <!-- Home Page -->
    <section id="home">
        <div class="container portfolio-flex-grid">
            <div class="row">
                <div class="col-lg-12 text-center">
                    <h2>Home</h2>
                    <hr class="star-primary">
                </div>
            </div>
            <div class="portfolio-flex-row">
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000008" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>zskiplist</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-adil-dahmani-157456832-10727340.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000007" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>intSet</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-tomas-malik-793526-27244374.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000006" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>dict</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-kaiwalya-limaye-1997844793-29188005.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000005" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>quickList</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-mutecevvil-28871575.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000004" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>ziplist</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-ahmetkurt-12661193.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000003" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>sds</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-matreding-23105882.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000002" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>redisObject</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-keval-padhiyar-245700856-19915666.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>redis概览</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-matt-g-623574593-17392834.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>DDD基础概念</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-kbra-arslaner-19767896.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000021" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>位运算</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-muhammet-cengiov-19017576.jpg" class="img-responsive" alt="BitOperation">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000020" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>数学公式</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-tim-mossholder-3308750.jpg" class="img-responsive" alt="Euclidean">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000019" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>算法小技巧</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-valentin-stenglein-18640944.jpg" class="img-responsive" alt="Euclidean">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>Mysql基本数据类型</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-hannah-luo-18540208.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000020" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>莫里斯遍历</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-thiago-matos-4037037.jpg" class="img-responsive" alt="Morris Traversing">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000019" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>蓄水池采样算法</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-emmanuel-hernndez-12217674.jpg" class="img-responsive" alt="ReservoirSampling">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000018" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>欧几里得算法</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-alexey-demidov-11341064.jpg" class="img-responsive" alt="Euclidean">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-100000017" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>散列表</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-nuta-sorokina-10005736.jpg" class="img-responsive" alt="hashTable">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000016" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>状态压缩</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-eugene-golovesov-5097165.jpg" class="img-responsive" alt="stateCompression">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000015" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>拓扑排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-michael-kessel-9668543.jpg" class="img-responsive" alt="topoSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000014" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>快速幂</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-regina-pivetta-9945338.jpg" class="img-responsive" alt="快速幂">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000013" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>摩尔投票</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-vladislav-filippov-9001724.jpg" class="img-responsive" alt="摩尔投票">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000008" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication getBean方法解析:org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String, java.lang.Class<T>)</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-joaqu-9677214.jpg" class="img-responsive" alt="SpringBoot">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000007" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Refresh方法解析:processConfigBeanDefinitions</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-maverick-coltman-3214311.jpg" class="img-responsive" alt="SpringBoot">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000012" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>平衡二叉查找树</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-jue-5806480.jpg" class="img-responsive" alt="BalancedBinaryTree">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000006" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Run方法解析(四):refreshContext</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-rachel-claire-4577793.jpg" class="img-responsive" alt="SpringBoot">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000005" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Run方法解析(三):prepareContext</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-pok-rie-136728.jpg" class="img-responsive" alt="SpringBoot">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000004" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Run方法解析(二):createApplicationContext</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-anastasia-pavlova-8692301.jpg" class="img-responsive" alt="SpringBoot4">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000003" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Run方法解析(一):prepareEnvironment</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-rachel-claire-5490361.jpg" class="img-responsive" alt="SpringBoot3">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000002" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication构造方法分析</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-irina-iriser-1122625.jpg" class="img-responsive" alt="SpringBoot2">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000010" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>二分查找</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-victoria-borodinova-9201864.jpg" class="img-responsive" alt="BinarySearch">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000011" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>二叉查找树</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-julia-volk-5273316.jpg" class="img-responsive" alt="BinarySearchTree">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000009" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>二叉树基本概念</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-karina-zhukovskaya-7260333.jpg" class="img-responsive" alt="binaryTree">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000008" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>基数排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-roman-odintsov-5327786.jpg" class="img-responsive" alt="radixSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000007" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>希尔排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-alena-beliaeva-8697338.jpg" class="img-responsive" alt="shellSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000006" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>归并排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-anete-lusina-5721167.jpg" class="img-responsive" alt="mergeSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000005" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>选择排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-8906527.jpg" class="img-responsive" alt="selectSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000004" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>插入排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-nick-wehrli-6524730.jpg" class="img-responsive" alt="insertSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000003" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>堆排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-valeriya-kobzar-8155476.jpg" class="img-responsive" alt="heapSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000002" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>快速排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-jo-jesus-4198220.jpg" class="img-responsive" alt="quickSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>冒泡排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-rachel-claire-4846299.jpg" class="img-responsive" alt="bubbleSort">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication注解分析</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-david-selbert-6468061.jpg" class="img-responsive" alt="SpringBoot1">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-9" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>spring</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-8802433.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-7" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>spring</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-luizclas-556666.jpg" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-1" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</p>

                                </div>
                            </div>
                            <img src="img/portfolio/cabin.png" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-2" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</p>

                                </div>
                            </div>
                            <img src="img/portfolio/cake.png" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-3" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</p>

                                </div>
                            </div>
                            <img src="img/portfolio/circus.png" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-4" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</p>

                                </div>
                            </div>
                            <img src="img/portfolio/game.png" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-6" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</p>

                                </div>
                            </div>
                            <img src="img/portfolio/submarine.png" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
                    <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-5" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</p>

                                </div>
                            </div>
                            <img src="img/portfolio/safe.png" class="img-responsive" alt="image-alt">

                        </a>
                    </div>
                
            </div>
        </div>
    </section>
    <!-- 指定的栏目下的内容需要加上指定的标记为true使用 if标签  标志位添加在posts中的markdown中  还需要设置main.css中的样式-->
    <!-- Spring -->
    <section id="spring">
        <div class="container portfolio-flex-grid">
            <div class="row">
                <div class="col-lg-12 text-center">
                    <h2>Spring</h2>
                    <hr class="star-primary">
                </div>
            </div>
            <div class="portfolio-flex-row">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-9" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>spring</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-8802433.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-7" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>spring</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-luizclas-556666.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </div>
        </div>
    </section>
    
    <!-- Spring Boot -->
    <section id="springboot">
        <div class="container portfolio-flex-grid">
            <div class="row">
                <div class="col-lg-12 text-center">
                    <h2>Spring Boot</h2>
                    <hr class="star-primary">
                </div>
            </div>
            <div class="portfolio-flex-row">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000008" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication getBean方法解析:org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String, java.lang.Class<T>)</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-joaqu-9677214.jpg" class="img-responsive" alt="SpringBoot">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000007" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Refresh方法解析:processConfigBeanDefinitions</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-maverick-coltman-3214311.jpg" class="img-responsive" alt="SpringBoot">
                        </a>
                    </div>
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000006" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Run方法解析(四):refreshContext</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-rachel-claire-4577793.jpg" class="img-responsive" alt="SpringBoot">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000005" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Run方法解析(三):prepareContext</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-pok-rie-136728.jpg" class="img-responsive" alt="SpringBoot">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000004" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Run方法解析(二):createApplicationContext</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-anastasia-pavlova-8692301.jpg" class="img-responsive" alt="SpringBoot4">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000003" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication Run方法解析(一):prepareEnvironment</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-rachel-claire-5490361.jpg" class="img-responsive" alt="SpringBoot3">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000002" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication构造方法分析</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-irina-iriser-1122625.jpg" class="img-responsive" alt="SpringBoot2">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>SpringBootApplication注解分析</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-david-selbert-6468061.jpg" class="img-responsive" alt="SpringBoot1">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </div>
        </div>
    </section>
    
    <!-- Spring Boot -->
    <section id="algorithm">
        <div class="container portfolio-flex-grid">
            <div class="row">
                <div class="col-lg-12 text-center">
                    <h2>算法与数据结构</h2>
                    <hr class="star-primary">
                </div>
            </div>
            <div class="portfolio-flex-row">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000021" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>位运算</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-muhammet-cengiov-19017576.jpg" class="img-responsive" alt="BitOperation">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000020" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>数学公式</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-tim-mossholder-3308750.jpg" class="img-responsive" alt="Euclidean">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000019" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>算法小技巧</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-valentin-stenglein-18640944.jpg" class="img-responsive" alt="Euclidean">
                        </a>
                    </div>
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000020" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>莫里斯遍历</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-thiago-matos-4037037.jpg" class="img-responsive" alt="Morris Traversing">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000019" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>蓄水池采样算法</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-emmanuel-hernndez-12217674.jpg" class="img-responsive" alt="ReservoirSampling">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000018" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>欧几里得算法</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-alexey-demidov-11341064.jpg" class="img-responsive" alt="Euclidean">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-100000017" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>散列表</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-nuta-sorokina-10005736.jpg" class="img-responsive" alt="hashTable">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000016" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>状态压缩</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-eugene-golovesov-5097165.jpg" class="img-responsive" alt="stateCompression">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000015" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>拓扑排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-michael-kessel-9668543.jpg" class="img-responsive" alt="topoSort">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000014" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>快速幂</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-regina-pivetta-9945338.jpg" class="img-responsive" alt="快速幂">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000013" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>摩尔投票</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-vladislav-filippov-9001724.jpg" class="img-responsive" alt="摩尔投票">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000012" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>平衡二叉查找树</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-jue-5806480.jpg" class="img-responsive" alt="BalancedBinaryTree">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000010" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>二分查找</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-victoria-borodinova-9201864.jpg" class="img-responsive" alt="BinarySearch">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000011" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>二叉查找树</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-julia-volk-5273316.jpg" class="img-responsive" alt="BinarySearchTree">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000009" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>二叉树基本概念</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-karina-zhukovskaya-7260333.jpg" class="img-responsive" alt="binaryTree">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000008" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>基数排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-roman-odintsov-5327786.jpg" class="img-responsive" alt="radixSort">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000007" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>希尔排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-alena-beliaeva-8697338.jpg" class="img-responsive" alt="shellSort">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000006" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>归并排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-anete-lusina-5721167.jpg" class="img-responsive" alt="mergeSort">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000005" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>选择排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-8906527.jpg" class="img-responsive" alt="selectSort">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000004" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>插入排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-nick-wehrli-6524730.jpg" class="img-responsive" alt="insertSort">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000003" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>堆排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-valeriya-kobzar-8155476.jpg" class="img-responsive" alt="heapSort">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000002" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>快速排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-jo-jesus-4198220.jpg" class="img-responsive" alt="quickSort">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-10000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>冒泡排序</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-rachel-claire-4846299.jpg" class="img-responsive" alt="bubbleSort">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </div>
        </div>
    </section>
    
    <!-- Mysql -->
    <section id="mysql">
        <div class="container portfolio-flex-grid">
            <div class="row">
                <div class="col-lg-12 text-center">
                    <h2>Mysql</h2>
                    <hr class="star-primary">
                </div>
            </div>
            <div class="portfolio-flex-row">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-20000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>Mysql基本数据类型</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-hannah-luo-18540208.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </div>
        </div>
    </section>
    
    <!-- Redis -->
    <section id="redis">
        <div class="container portfolio-flex-grid">
            <div class="row">
                <div class="col-lg-12 text-center">
                    <h2>Redis</h2>
                    <hr class="star-primary">
                </div>
            </div>
            <div class="portfolio-flex-row">
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000008" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>zskiplist</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-adil-dahmani-157456832-10727340.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000007" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>intSet</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-tomas-malik-793526-27244374.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000006" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>dict</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-kaiwalya-limaye-1997844793-29188005.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000005" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>quickList</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-mutecevvil-28871575.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000004" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>ziplist</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-ahmetkurt-12661193.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000003" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>sds</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-matreding-23105882.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000002" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>redisObject</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-keval-padhiyar-245700856-19915666.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>redis概览</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-matt-g-623574593-17392834.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </div>
        </div>
    </section>
    
    <!-- DDD -->
    <section id="ddd">
        <div class="container portfolio-flex-grid">
            <div class="row">
                <div class="col-lg-12 text-center">
                    <h2>DDD</h2>
                    <hr class="star-primary">
                </div>
            </div>
            <div class="portfolio-flex-row">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                <div class="portfolio-flex-item portfolio-item">
                        <a href="#portfolioModal-30000001" class="portfolio-link" data-toggle="modal">
                            <div class="caption">
                                <div class="caption-content">
                                    <i class="fa fa-search-plus fa-3x"></i>
                                    <p>DDD基础概念</p>

                                </div>
                            </div>
                            <img src="img/portfolio/pexels-kbra-arslaner-19767896.jpg" class="img-responsive" alt="image-alt">
                        </a>
                    </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </div>
        </div>
    </section>

        <!-- Footer -->
    <footer class="text-center">
        <div class="footer-above">
            <div class="container">
                <div class="row">
                    <div class="footer-col col-md-4">
                        <h3>China</h3>
                        <p>
                            
                                3481 Melrose Place <br>
		                    
                                Beverly Hills, CA 90210 <br>
		                    
                        </p>
                    </div>
                    <div class="footer-col col-md-4">
                        <h3>Around the Web</h3>
                        <ul class="list-inline">
                            
                            <li>
                                <a href="http://github.com/BiggerYellow" class="btn-social btn-outline"><i class="fa fa-fw fa-github"></i></a>
                            </li>
		                    
                        </ul>
                    </div>
                    <div class="footer-col col-md-4">
                        <h3>Credits</h3>
                        <p>Freelancer is a free to use, open source Bootstrap theme created by <a href="http://startbootstrap.com">Start Bootstrap</a>.</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="footer-below">
            <div class="container">
                <div class="row">
                    <div class="col-lg-12">
                        Copyright &copy; Hcc 2024
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <!-- Scroll to Top Button (Only visible on small and extra-small screen sizes) -->
    <div class="scroll-top page-scroll visible-xs visible-sm">
        <a class="btn btn-primary" href="#page-top">
            <i class="fa fa-chevron-up"></i>
        </a>
    </div>

     <!-- Portfolio Modals -->
 
    <div class="portfolio-modal modal fade" id="portfolioModal-30000008" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>跳表</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-adil-dahmani-157456832-10727340.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>zskiplist</h3>
                            
                            </div>

                            <p><h3 id="跳表---zskiplist">跳表 - zskiplist</h3>
<hr />
<p>跳表的性能可以保证在查找、删除、添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳表的长处。跳跃表的缺点就是需要的存储空间较大，属于利用空间来换取时间的数据结构。<br />
跳表结构在 redis 中的运用场景只有一个，就是作为有序列表 （Zset）的使用。</p>

<h3 id="为什么使用跳表">为什么使用跳表</h3>
<hr />
<p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。<br />
例如：查找 12，需要 7 次查找。</p>
<center>   
<img src="../../img/redis/skiplist/db-redis-ds-x-9.png" class="img-responsive img-centered" alt="image-alt" />
</center>

<p>如果我们增加如下两级索引，那么它搜索次数就变成了 3 次。</p>
<center>   
<img src="../../img/redis/skiplist/db-redis-ds-x-10.png" class="img-responsive img-centered" alt="image-alt" />
</center>

<h3 id="zskiplist-数据结构">zskiplist 数据结构</h3>
<hr />

<center>   
<img src="../../img/redis/skiplist/skiplistStructure.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">跳跃表结构示意图</div>
</center>

<p>跳表的数据结构定义在 server.h 中，主要由以下几个结构体组成：</p>
<pre><code class="language-CPP">// 层高最大值限制
#define ZSKIPLIST_MAXLEVEL 64 /* Should be enough for 2^64 elements */
// 层高是否继续增长的概率
#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */


/* ZSETs use a specialized version of Skiplists
 * ZSET 使用特殊版本的快表
 * */
//跳表节点定义
typedef struct zskiplistNode {
    //存储的内容
    sds ele;
    //对应的分值  用于排序
    double score;
    //后退指针
    struct zskiplistNode *backward;
    //变长数组 记录层信息，层级越高跳过的节点越多（因为层高越高概率越低）
    struct zskiplistLevel {
        //执行当前层的下一个节点
        struct zskiplistNode *forward;
        //当前节点 与 forward 所指节点间隔的节点数
        unsigned long span;
    } level[];
} zskiplistNode;

//跳表数据结构
typedef struct zskiplist {
    //头尾节点
    struct zskiplistNode *header, *tail;
    //长度
    unsigned long length;
    //最大层级
    int level;
} zskiplist;


//有序集合数据结构
typedef struct zset {
    //字典 当元素较少时使用字典作为底层结构，适用于直接查询
    dict *dict;
    //跳表 适用于范围查询
    zskiplist *zsl;
} zset;
</code></pre>

<ul>
  <li>
    <p>zskiplist<br />
header: 跳表头结点指针，头结点是一个特殊的节点，它不保存实际分值和对象，它的 level 数组长度为 32.
tail: 跳表尾结点指针，尾结点是一个真实的节点，和头结点不一样<br />
length: 跳跃表长度，即跳表当前节点数量，不包括头结点<br />
level: 跳表当前节点中的最大层数，不包括头结点</p>
  </li>
  <li>
    <p>zskiplistNode<br />
ele: 节点保存的对象，是一个 sds 字符串对象。老版本存放的是 obj，最后存储的也是 sds 字符串对象。<br />
score: 节点分值，跳表中所有节点都按照分值从小到大排序<br />
backward: 指向前驱节点<br />
level[]: zskiplistLevel 结构体的数组，数组中的每个 zskiplistLevel 元素称为层。每层中保存了后继节点的指针 forward 和 span。</p>
    <ul>
      <li>forward: 表示后继节点的指针</li>
      <li>span: 表示当前节点到 forward 指向的后继节点之间需要跨越多少个节点</li>
    </ul>
  </li>
</ul>

<p><strong>源码解析</strong><br />
有序集合中常用API（包含跳表和压缩列表）</p>
<pre><code class="language-CPP">//有序集合相关API
zskiplist *zslCreate(void);
void zslFree(zskiplist *zsl);
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);
unsigned char *zzlInsert(unsigned char *zl, sds ele, double score);
int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);
zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);
zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);
double zzlGetScore(unsigned char *sptr);
void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);
void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);
unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);
unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);
unsigned long zsetLength(const robj *zobj);
void zsetConvert(robj *zobj, int encoding);
void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);
int zsetScore(robj *zobj, sds member, double *score);
unsigned long zslGetRank(zskiplist *zsl, double score, sds o);
int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore);
long zsetRank(robj *zobj, sds ele, int reverse);
int zsetDel(robj *zobj, sds ele);
robj *zsetDup(robj *o);
int zsetZiplistValidateIntegrity(unsigned char *zl, size_t size, int deep);
void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg);
sds ziplistGetObject(unsigned char *sptr);
int zslValueGteMin(double value, zrangespec *spec);
int zslValueLteMax(double value, zrangespec *spec);
void zslFreeLexRange(zlexrangespec *spec);
int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec);
unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range);
unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range);
zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range);
zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);
int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec);
int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec);
int zslLexValueGteMin(sds value, zlexrangespec *spec);
int zslLexValueLteMax(sds value, zlexrangespec *spec);
</code></pre>

<ul>
  <li>zslCreate</li>
</ul>

<pre><code class="language-CPP">/* Create a new skiplist.
 * 创建新的跳表
 * */
zskiplist *zslCreate(void) {
    int j;
    zskiplist *zsl;

    //分配内存空间
    zsl = zmalloc(sizeof(*zsl));
    //初始化层数为1
    zsl-&gt;level = 1;
    //初始化长度为0
    zsl-&gt;length = 0;
    //创建跳表节点并赋值给头结点  最大level为32
    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
    //循环初始化层信息
    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) {
        //下一个节点为null
        zsl-&gt;header-&gt;level[j].forward = NULL;
        //间隔数量为0
        zsl-&gt;header-&gt;level[j].span = 0;
    }
    //头结点的回退指针指向null
    zsl-&gt;header-&gt;backward = NULL;
    //尾节点指向null
    zsl-&gt;tail = NULL;
    return zsl;
}

/* Create a skiplist node with the specified number of levels.
 * The SDS string 'ele' is referenced by the node after the call.
 * 创建具有指定数量层级的跳表。
 * 在调用之后，节点引用SDS字符串 ele
 * */
zskiplistNode *zslCreateNode(int level, double score, sds ele) {
    //分配内存
    zskiplistNode *zn =
        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
    //初始化分数
    zn-&gt;score = score;
    //初始化字符串
    zn-&gt;ele = ele;
    return zn;
}
</code></pre>
<p>创建跳表结构，初始化跳表结构中各个字段，创建跳表节点层级为 32 的头结点，初始化时直接按照最大值申请高度，避免后续高度增加时为头结点重新分配内存。</p>

<ul>
  <li>zslInsert</li>
</ul>

<pre><code class="language-CPP">/* Insert a new node in the skiplist. Assumes the element does not already
 * exist (up to the caller to enforce that). The skiplist takes ownership
 * of the passed SDS string 'ele'.
 * 在跳表中插入一个新节点。假设元素不存在（取决于调用者强制指定）。跳表有传入的sds字符换 ele 的所有权
 * */
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    //update 存放需要更新的跳表节点
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    //rank[i] 表示的是 update[i] 指向的节点的排位，即 update[i] 到头结点的间距
    unsigned int rank[ZSKIPLIST_MAXLEVEL];

    int i, level;

    serverAssert(!isnan(score));
    //x 指向跳表头部
    x = zsl-&gt;header;
    //第一步 收集需要更新的节点与步长信息
    //从最大层级开始 从上往下处理层级   收集需要更新的节点与步长信息
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        /* store rank that is crossed to reach the insert position
         * 为到达插入位置而交叉的存储位置
         * */
        //若从最大开始则为0，否则为之前计算过的值
        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];

        //若层级存在下一个节点 且 分值大于下个节点分值 或 分值相等但是 ele 较小  说明需要包含该层级信息
        while (x-&gt;level[i].forward &amp;&amp;
                (x-&gt;level[i].forward-&gt;score &lt; score ||
                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
        {
            //累加当前节点与下一个节点间隔的数量
            rank[i] += x-&gt;level[i].span;
            //继续处理下一个节点
            x = x-&gt;level[i].forward;
        }
        //待更新节点 x 代表该层已经找到最后一个节点了
        update[i] = x;
    }
    /* we assume the element is not already inside, since we allow duplicated
     * scores, reinserting the same element should never happen since the
     * caller of zslInsert() should test in the hash table if the element is
     * already inside or not.
     * 我们假设元素不存在于跳表中，由于我们允许重复的分数，重新插入相同元素不应该发生，由于 zslInsert 的调用者应该在哈希表中测试元素是否已经存在
     * */
    //第二步 获取随机层高，补全需要更新的节点
    //计算随机层级
    level = zslRandomLevel();
    //若新计算层级大于当前跳表节点的最大层级
    if (level &gt; zsl-&gt;level) {
        //即头结点中未使用的层都需要记录
        for (i = zsl-&gt;level; i &lt; level; i++) {
            rank[i] = 0;
            update[i] = zsl-&gt;header;
            update[i]-&gt;level[i].span = zsl-&gt;length;
        }
        //更新最大层级
        zsl-&gt;level = level;
    }
    //第三步 创建并分层插入节点，同时更新同层前一节点步长信息
    //创建跳表节点
    x = zslCreateNode(level,score,ele);
    //更新同层的节点信息
    for (i = 0; i &lt; level; i++) {
        //更新新节点的下一个跳表节点
        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;
        //将沿途记录的各个节点的 forward 指针指向新节点
        update[i]-&gt;level[i].forward = x;

        /* update span covered by update[i] as x is inserted here
         * 当 x 插入到这里时， update[i] 覆盖的更新范围
         * */
        //计算新节点跨越的节点数量
        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);
        //更新新节点插入之后，沿途节点的 span 值，其中 +1计算的是新节点
        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;
    }

    //第四步，更新新增节点未涉及层节点的步长信息及跳表相关信息
    /* increment span for untouched levels
     * 为未使用的层级新增 span，直接从表头节点指向新节点
     * */
    for (i = level; i &lt; zsl-&gt;level; i++) {
        update[i]-&gt;level[i].span++;
    }

    //设置新节点的后退指针
    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];
    if (x-&gt;level[0].forward)
        x-&gt;level[0].forward-&gt;backward = x;
    else
        zsl-&gt;tail = x;
    //跳跃表技术加1
    zsl-&gt;length++;
    return x;
}
</code></pre>
<p>插入节点可以分为四步，原有跳表结构如下:</p>
<center>   
<img src="../../img/redis/skiplist/zslInsert0.png" class="img-responsive img-centered" alt="image-alt" />
</center>
<p>假设现在需要插入元素 80，且获取到随机的层高为 5 （假设为了所有情况都覆盖到）</p>
<center>   
<img src="../../img/redis/skiplist/zslInsert1.png" class="img-responsive img-centered" alt="image-alt" />
</center>

<ol>
  <li>收集需要更新的节点和步长信息
    <ul>
      <li>将插入新增节点后每层受影响节点存在 update 数组中，update[i] 为第 i+1 层会受影响节点（红框中标出来的节点）</li>
      <li>将会受影响的节点到头结点的距离存在 rank 数组中， rank[i] 为头结点与第 i+1 层会受影响节点中间存在的节点数（rank 为 [6,5,3,3]）</li>
    </ul>
  </li>
</ol>
<center>   
<img src="../../img/redis/skiplist/zslInsert2.png" class="img-responsive img-centered" alt="image-alt" />
</center>

<ol>
  <li>获取随机层高，补全需要更新的节点，同时可能更新跳表高度
    <ul>
      <li>通过 zslRandomLevel 函数计算当前插入节点的层高，层高越高出现的几率越小</li>
      <li>因为搜索需要更新节点是从跳跃表当前高度的那一层开始的，如果新插入的节点的层高比当前表高还高，那么高出的这几层的头结点也是需要更新信息的</li>
      <li>如果当前层高高于表高，则更新表高（从4变成5）</li>
    </ul>
  </li>
</ol>
<center>   
<img src="../../img/redis/skiplist/zslInsert3.png" class="img-responsive img-centered" alt="image-alt" />
</center>

<ol>
  <li>创建并分层插入节点，同时更新同层前一节点步长信息
    <ul>
      <li>创建节点，根据当前节点的层高，在每一层进行节点插入</li>
      <li>更新每层前一个节点（update[i] 对应节点）与自身节点的步长信息</li>
    </ul>
  </li>
  <li>更新新增节点未涉及层节点的步长信息，以及跳表相关信息与节点自身的相关信息
    <ul>
      <li>更新 zsl-&gt;level 到 level 中的节点，意味着待插入的节点层高大于后面节点的层高，后面的步长信息都需要加 1</li>
      <li>更新跳表长度与当前节点与第一层下一节点的后退指针（后退指针只有底层链表有）</li>
    </ul>
  </li>
</ol>

<ul>
  <li>zslGetRank、zslGetElementByRank</li>
</ul>

<pre><code class="language-CPP">/* Find the rank for an element by both score and key.
 * Returns 0 when the element cannot be found, rank otherwise.
 * Note that the rank is 1-based due to the span of zsl-&gt;header to the
 * first element.
 * 根据分数和键值查找元素的排名
 * */
unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *x;
    //当前排名
    unsigned long rank = 0;
    int i;

    //从头结点开始处理
    x = zsl-&gt;header;
    //从最大层级开始处理
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        //若当前层级存在下一个节点  且 分数大于下一个节点的分数  且  分值相同但是值小于当前节点
        while (x-&gt;level[i].forward &amp;&amp;
            (x-&gt;level[i].forward-&gt;score &lt; score ||
                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= 0))) {
            //累加当前节点的跨度
            rank += x-&gt;level[i].span;
            //继续遍历下一个
            x = x-&gt;level[i].forward;
        }

        /* x might be equal to zsl-&gt;header, so test if obj is non-NULL
         * x可能是跳表头部，所以测试obj 是否为非空
         * */
        if (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
            //若值相等直接返回值
            return rank;
        }
    }
    return 0;
}

/* Finds an element by its rank. The rank argument needs to be 1-based.
 * 根据元素的排名查找元素。rank参数需要以1为基础
 * */
zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
    zskiplistNode *x;
    unsigned long traversed = 0;
    int i;

    //x执行头结点
    x = zsl-&gt;header;
    //从最大层级开始往下遍历
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        //若当前节点存在下一个节点  且 当前节点跨度小于排名 rank
        while (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)
        {
            //累增跨度
            traversed += x-&gt;level[i].span;
            //继续处理下一个节点
            x = x-&gt;level[i].forward;
        }
        //如果跨度相等则返回节点
        if (traversed == rank) {
            return x;
        }
    }
    return NULL;
}
</code></pre>
<p>zslGetRank: 查询元素在跳表中的排名 、 zslGetElementByRank: 根据排名查询元素的值。<br />
以上两个查询方法类似，从最大层级从上往下遍历，判断是否大小满足继续遍历的条件，满足则继续处理下一个节点，不满足则直接返回。</p>

<ul>
  <li>zslDelete</li>
</ul>

<pre><code class="language-CPP">/* Delete an element with matching score/element from the skiplist.
 * The function returns 1 if the node was found and deleted, otherwise
 * 0 is returned.
 * 从跳表中匹配分数或元素删除元素。
 * 如果节点被发现且删除该方法返回1，否则返回0
 *
 * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise
 * it is not freed (but just unlinked) and *node is set to the node pointer,
 * so that it is possible for the caller to reuse the node (including the
 * referenced SDS string at node-&gt;ele).
 * 如果node为null，则被删除的节点将被 zslFreeNode() 释放，否则它不会被释放（只是解除链接），*node 被设置为节点指针，所以调用方可以重用节点（包括引用的SDS字符串在节点的ele）
 * */
int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    //update 待更新的节点
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    //x从头节点开始处理
    x = zsl-&gt;header;
    //从跳表已有的最大层级开始往下记录需要处理的节点
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        //迭代找到最后一个大于待删除的节点
        while (x-&gt;level[i].forward &amp;&amp;
                (x-&gt;level[i].forward-&gt;score &lt; score ||
                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
        {
            //继续处理下一个跳表节点
            x = x-&gt;level[i].forward;
        }
        //待更新的跳表节点
        update[i] = x;
    }
    /* We may have multiple elements with the same score, what we need
     * is to find the element with both the right score and object.
     * 我们可能有多个相同分数的元素，我们需要的是找到具有相同分数和对象的元素
     * */
    // x 当前为要更新的最后一个节点 即离待删除节点最近的节点
    // 此时 第 0 层 forward 指向的可能就是要删除的节点
    x = x-&gt;level[0].forward;
    //若存在该节点 且 分数和大小相等
    if (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
        //删除该跳表节点及待更新的节点
        zslDeleteNode(zsl, x, update);
        //若无引用则直接释放 x 内存
        if (!node)
            zslFreeNode(x);
        else
            //若有引用则
            *node = x;
        return 1;
    }
    //为 0 说明找到
    return 0; /* not found */
}

/* Internal function used by zslDelete, zslDeleteRangeByScore and
 * zslDeleteRangeByRank.
 * 删除的内部使用方法
 * zsl:当前跳表
 * x:待删除节点
 * update:待更新节点
 * */
void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;
    //处理所有层级的节点
    for (i = 0; i &lt; zsl-&gt;level; i++) {
        //若待更新节点下一个节点指向待删除节点 被删除的节点在第i层有节点，则update[i]为被删除节点的前一个节点
        if (update[i]-&gt;level[i].forward == x) {
            //当前节点跨度 + 下一节点跨度 - 待删除节点
            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;
            //将当前节点指向待删除的下一个节点
            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;
        } else {
            //被删除节点在第 i 层无节点，则 步长=原步长 - 1（被删除节点）
            update[i]-&gt;level[i].span -= 1;
        }
    }
    //若待删除节点存在下一个节点
    if (x-&gt;level[0].forward) {
        //更新被删除节点下一个节点的后退指针
        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;
    } else {
        //否则指向末尾节点
        zsl-&gt;tail = x-&gt;backward;
    }
    //更新最大层级
    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)
        zsl-&gt;level--;
    //跳表长度减1
    zsl-&gt;length--;
}
</code></pre>
<p>删除节点与添加节点步骤类型，分为三步:</p>
<ol>
  <li>收集需要更新的节点</li>
  <li>删除节点所在的层移除节点，并更新前一节点的步长信息（update[i] 所存节点）</li>
  <li>更新跳表高度与长度</li>
</ol>

<h3 id="为什么不用平衡树或哈希表">为什么不用平衡树或哈希表</h3>
<hr />
<ul>
  <li>为什么不是平衡树，作者回答如下</li>
</ul>

<blockquote>
  <p>https://news.ycombinator.com/item?id=1171423</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>There are a few reasons:
1) They are not very memory intensive. It's up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.

2) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.

3) They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.

About the Append Only durability &amp; speed, I don't think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.

About threads: our experience shows that Redis is mostly I/O bound. I'm using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the "Redis Cluster" solution that I plan to develop in the future.
</code></pre></div></div>

<p>实现节点且达到了类似的效果。</p>

<ul>
  <li>跳表与平衡树、哈希表的比较</li>
</ul>

<p>skiplist 和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个 key 的查找，不适宜做范围查找。</p>

<p>在做范围查找时，平衡树比 skiplist 操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历不容易实现。而在 skiplist 上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</p>

<p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而 skiplist 的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p>

<p>从内存占用上来说，skiplist 比平衡树更灵活一些。一般来说，平衡树每个节点包含 2 个指针（分别指向左右子树），而 skiplist 每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像 redis 里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</p>

<p>查找单个 key，skiplist 和 平衡树的时间复杂度都为 O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提喜爱，查找时间复杂度接近 O(1)，性能更高一些。</p>

<p>从算法实现难度上来比较，skiplist 比 平衡树要简单的多。</p>

<blockquote>
  <p>参考博客<br />
https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html#%E6%95%B4%E6%95%B0%E9%9B%86-intset<br />
https://cloud.tencent.com/developer/article/1350965<br />
https://juejin.cn/post/7382734569605316627<br />
https://juejin.cn/post/6844904004498128903<br />
https://nullcc.github.io/2017/11/17/Redis%E4%B8%AD%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(7)%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8(zskiplist)/<br />
https://fanlv.fun/2019/08/17/reids-source-code-7/<br />
https://www.cnblogs.com/yinbiao/p/11238374.html</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">December 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">redis</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-30000007" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>整数集</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-tomas-malik-793526-27244374.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>intSet</h3>
                            
                            </div>

                            <p><h3 id="整数集---intset">整数集 - intSet</h3>
<hr />
<p>整数集合（intSet）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。
有以下几个特点：</p>
<ul>
  <li>升序排序，无重复元素</li>
  <li>可通过属性自定义编码方式 (int16_t/int32_t/int64_t)</li>
  <li>插入新元素时，如果新元素的类型比 intSet 的原编码类型长，那么要先进行升级操作（不可逆操作）</li>
  <li>节省内存</li>
</ul>

<h3 id="intset-数据结构">intSet 数据结构</h3>
<hr />
<pre><code class="language-CPP">typedef struct intset {
    // 整数编码方式  取值有三个 INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64  占4字节
    uint32_t encoding;
    // 代表存储的整数个数    占4字节
    uint32_t length;
    // 指向实际存储数值的连续内存区域，是一个数组；整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值大小从小到大有序排序，且数组中不包含任何重复项     占1字节
    int8_t contents[];
} intset;
</code></pre>

<p>字段含义：</p>
<ul>
  <li>encoding：数据编码，表示 intSet 中的每个数据元素用几个字节来存储。它有三种可能得取值：INTSET_ENC_INT16 表示每个元素用 2 个字节存储、INTSET_ENC_INT32 表示每个元素用 4 个字节存储、INTSET_ENC_INT64 表示每个元素用 8 个字节存储。因此，intSet 中存储的整数最多只能占用 64 bit</li>
  <li>length：表示 intSet 中的元素个数。encoding 和 length 两个字段构成了 intSet 的头部（header）</li>
  <li>contents：是一个柔性数组，表示 intSet 的 header 后面紧跟着数据元素。这个数组的总长度（即总字节数）等于 encoding*length。柔性数组在 Redis 的很多数据结构的定义中都出现过，用于表达一个偏移量。contents 需要单独为其分配空间，这部分内存不包含在 intSet 结构当中。</li>
</ul>

<p>整数集的结构如下所示：</p>

<p>+——–+——–+——–+——–+——–+——–+<br />
| header |  data  |  data  |  data  |  data  |  data  |<br />
+——–+——–+——–+——–+——–+——–+</p>

<p>注意，intSet 的存储直接涉及到内存编码，所以需要考虑主机的字节序问题。<br />
intrev32ifbe 的意思是 int32 reversal if big endian。即 如果当前主机字节序为大端序，那么将它的内存存储进行翻转操作。简言之，intSet 的所有成员存储方式都采用小端序。所以创建一个空的整数集合，内存分布如下：</p>

<center>   
<img src="../../img/redis/intset/整数集合内存分布.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">整数集合内存分布</div>
</center>

<p>需要注意的是，intSet 可能会随着数据的添加而改变它的数据编码：<br />
最开始，新创建的 intSet 使用占用内存最小的 INTSET_ENC_INT16（2字节）作为数据编码，每添加一个新元素，则根据元素大小决定是否对数据编码进行升级。</p>

<p>下面是添加数据的具体例子：</p>

<center>   
<img src="../../img/redis/intset/redis_intset_add_example.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">整数集合添加元素示例</div>
</center>

<p>上图中：</p>
<ol>
  <li>新建的 intSet 只有一个 header，总共 8 个字节。其中 encoding=2，length=0</li>
  <li>添加 13、5 两个元素之后，因为它们是比较小的整数，都能使用 2 个字节表示，所以 encoding 不变，值还是 2</li>
  <li>当添加 32768 的时候，它不能再用 2 个字节来表示了（2个字节能表示的数据范围是 -2^15 ~ 2^15 - 1，而 32768 = 2^15 ，超过范围了），因此 encoding 必须升级到 INTSET_ENC_INT32（值为4），即用 4 个字节表示一个元素</li>
  <li>在添加每个元素的过程中，intSet 始终保持从小到大有序</li>
  <li>与 ziplist 类似，intSet 也是按小端序模式存储的。比如在上图中 intSet 添加完所有数据之后，表示 encoding 字段的 4 个字节应该解释成 0x00000004，而第 5 个数据应该解释成 0x000186A0 = 100000。</li>
</ol>

<p>intSet 与 zipList 相比：</p>
<ul>
  <li>zipList 可以存储任意二进制串，而 intSet 只能存储整数</li>
  <li>zipList 是无需的，而 intSet 是从小到大有序的。因此，在 zipList 上查找只能遍历，而在 intSet 上可以进行二分查找，性能更高</li>
  <li>zipList 可以对每个数据项进行不同的变长编码（每个数据项前面都有数据长度字段 len），而 intSet 只能整体使用一个统一的编码（encoding）</li>
</ul>

<h3 id="intset-核心api">intSet 核心API</h3>
<hr />

<p>intset *intsetNew(void);<br />
intset *intsetAdd(intset *is, int64_t value, uint8_t *success);<br />
intset *intsetRemove(intset *is, int64_t value, int *success);<br />
uint8_t intsetFind(intset *is, int64_t value);<br />
int64_t intsetRandom(intset *is);<br />
uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);<br />
uint32_t intsetLen(const intset *is);<br />
size_t intsetBlobLen(intset *is);<br />
int intsetValidateIntegrity(const unsigned char *is, size_t size, int deep);</p>

<p><strong>源码解析</strong></p>

<ul>
  <li>intsetNew</li>
</ul>

<pre><code class="language-CPP">/* Create an empty intset.
 * 创建空的整数集合
 * */
intset *intsetNew(void) {
    //分配内存
    intset *is = zmalloc(sizeof(intset));
    //初始化整数类型为 int16    intset的所有成员存储方式都采用小端序
    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);
    //初始化集合长度为 0
    is-&gt;length = 0;
    return is;
}
</code></pre>
<p>创建空的整数集，分配内存及初始化属性字段。</p>

<ul>
  <li>intsetAdd</li>
</ul>

<pre><code class="language-CPP">/* Insert an integer in the intset
 * 向整数集合中插入一个整数
 * */
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    //获取该值对应的编码
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 1;

    /* Upgrade encoding if necessary. If we need to upgrade, we know that
     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),
     * because it lies outside the range of existing values.
     * 如果需要的话升级编码。如果我们需要升级，我们要知道 这个值应该被附加（如果&gt;0）或加在前面（如果&lt;0），因为它位于现有值的范围之外
     * */
    //如果待插入值的编码大于当前整数集合编码
    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) {
        /* This always succeeds, so we don't need to curry *success.
         * 他总是成功，所以我们不需要追求 *success
         * */
        return intsetUpgradeAndAdd(is,value);
    } else {
        /* Abort if the value is already present in the set.
         * This call will populate "pos" with the right position to insert
         * the value when it cannot be found.
         * 如果该值已经存在于集合中则终止。
         * 这个调用将用正确的位置填充 pos 以便在找不到值时插入值
         * */
        if (intsetSearch(is,value,&amp;pos)) {
            //找到则说明不用插入直接返回 说明插入未成功
            if (success) *success = 0;
            return is;
        }

        //该值不存在，首先扩容集合数量加1
        is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);
        //如果待插入位置在中间 将待插入位置的值全部移动到末尾
        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1);
    }

    //将值插入到指定位置
    _intsetSet(is,pos,value);
    //更新长度
    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);
    return is;
}


/* Return the required encoding for the provided value.
 * 返回所提供值需要的编码
 * */
static uint8_t _intsetValueEncoding(int64_t v) {
    //若该值小于 32位的最小值 或 大于32位的最大值 则为 64位
    if (v &lt; INT32_MIN || v &gt; INT32_MAX)
        return INTSET_ENC_INT64;
    else if (v &lt; INT16_MIN || v &gt; INT16_MAX) //若该值小于16位的最小值 或 大于16位的最大值 则为 32位
        return INTSET_ENC_INT32;
    else
        return INTSET_ENC_INT16; //否则就是 16位
}

/* Upgrades the intset to a larger encoding and inserts the given integer.
 * 升级整数集合到更大的编码 插入给定的整数
 * */
static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    //当前整数集合编码
    uint8_t curenc = intrev32ifbe(is-&gt;encoding);
    //待插入值的编码
    uint8_t newenc = _intsetValueEncoding(value);
    //当前整数集合数量
    int length = intrev32ifbe(is-&gt;length);
    //拼接位置  如果小于0放在前面 如果大于0放在后面
    int prepend = value &lt; 0 ? 1 : 0;

    /* First set new encoding and resize
     * 首先设置新编码并扩容
     * */
    //设置新编码
    is-&gt;encoding = intrev32ifbe(newenc);
    //数量扩容加1
    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);

    /* Upgrade back-to-front so we don't overwrite values.
     * Note that the "prepend" variable is used to make sure we have an empty
     * space at either the beginning or the end of the intset.
     * 从后到前升级，这样我们就不会覆盖
     * 请注意 prepend 比那里用来确保我们有空余空间在整数集的开头或结尾
     * */
    //递归处理 将原有整数插入到扩容后的集合中，需要注意将待插入索引空出来
    while(length--)
        //将整数插入到指定位置
        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));

    /* Set the value at the beginning or the end.
     * 将值插入到开头或者末尾
     * */
    //如果 prepend为1插入到开头，为0插入到末尾
    if (prepend)
        _intsetSet(is,0,value);
    else
        _intsetSet(is,intrev32ifbe(is-&gt;length),value);
    //更新整数集合大小 加1
    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);
    return is;
}

/* Resize the intset
 * 整数集合扩容
 * */
static intset *intsetResize(intset *is, uint32_t len) {
    //计算最终大小 扩容后的数量*最新编码
    uint64_t size = (uint64_t)len*intrev32ifbe(is-&gt;encoding);
    assert(size &lt;= SIZE_MAX - sizeof(intset));
    //重新分配内存 intset原始大小 + 最新数组大小
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}

/* Set the value at pos, using the configured encoding.
 * 将值插入到指定位置，并使用配置的编码
 * */
static void _intsetSet(intset *is, int pos, int64_t value) {
    uint32_t encoding = intrev32ifbe(is-&gt;encoding);

    if (encoding == INTSET_ENC_INT64) {
        ((int64_t*)is-&gt;contents)[pos] = value;
        memrev64ifbe(((int64_t*)is-&gt;contents)+pos);
    } else if (encoding == INTSET_ENC_INT32) {
        ((int32_t*)is-&gt;contents)[pos] = value;
        memrev32ifbe(((int32_t*)is-&gt;contents)+pos);
    } else {
        ((int16_t*)is-&gt;contents)[pos] = value;
        memrev16ifbe(((int16_t*)is-&gt;contents)+pos);
    }
}

/* Search for the position of "value". Return 1 when the value was found and
 * sets "pos" to the position of the value within the intset. Return 0 when
 * the value is not present in the intset and sets "pos" to the position
 * where "value" can be inserted.
 * 搜索value的位置。如果值被找到则返回1并将值在集合中的位置设置到 pos 中。
 * 如果值不存在于集合中返回0，并值可以被插入的位置设置到 pos 中
 * */
static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    //初始化变量
    //min = 0  最小
    //max = length-1 最大
    //mid = -1 中间位置
    int min = 0, max = intrev32ifbe(is-&gt;length)-1, mid = -1;
    //cur = -1 当前位置
    int64_t cur = -1;

    /* The value can never be found when the set is empty
     * 如果集合为空则值永远不会被发现
     * */
    //集合长度为0 代表空集合
    if (intrev32ifbe(is-&gt;length) == 0) {
        //pos设置为0 表明可以插入到第一个位置
        if (pos) *pos = 0;
        //插入失败返回0
        return 0;
    } else {

        /* Check for the case where we know we cannot find the value,
         * but do know the insert position.
         * 检查我们找不到该值但是知道要插入哪里的情况
         * */
        //如果该值大于 最大索引对应的值
        if (value &gt; _intsetGet(is,max)) {
            //说明待插入位置为最后
            if (pos) *pos = intrev32ifbe(is-&gt;length);
            //返回0
            return 0;
        } else if (value &lt; _intsetGet(is,0)) { //如果该值小于最小索引对应的值
            //说明待插入位置为最开始
            if (pos) *pos = 0;
            //返回0
            return 0;
        }
    }

    //二分查找搜索找到对应的位置
    while(max &gt;= min) {
        //取中间位置
        mid = ((unsigned int)min + (unsigned int)max) &gt;&gt; 1;
        //获取中间位置对应的值
        cur = _intsetGet(is,mid);
        //如果待插入值大于当前值  缩小左边
        if (value &gt; cur) {
            min = mid+1;
        } else if (value &lt; cur) {//如果待插入值小于当前值 缩小右边
            max = mid-1;
        } else {
            break;
        }
    }

    //如果当前值 等于 待插入值
    if (value == cur) {
        //设置位置为mid
        if (pos) *pos = mid;
        //返回1
        return 1;
    } else {
        //不存在则说明要插入到 二分查找排序的最小位置
        if (pos) *pos = min;
        //返回0
        return 0;
    }
}

static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {
    //*src 起始值
    //*dst 目标值
    void *src, *dst;
    //from 到 length 的字节数
    uint32_t bytes = intrev32ifbe(is-&gt;length)-from;
    //当前编码
    uint32_t encoding = intrev32ifbe(is-&gt;encoding);

    if (encoding == INTSET_ENC_INT64) {
        //真正的起始值
        src = (int64_t*)is-&gt;contents+from;
        //真正的模板值
        dst = (int64_t*)is-&gt;contents+to;
        //增加字节大小
        bytes *= sizeof(int64_t);
    } else if (encoding == INTSET_ENC_INT32) {
        src = (int32_t*)is-&gt;contents+from;
        dst = (int32_t*)is-&gt;contents+to;
        bytes *= sizeof(int32_t);
    } else {
        src = (int16_t*)is-&gt;contents+from;
        dst = (int16_t*)is-&gt;contents+to;
        bytes *= sizeof(int16_t);
    }
    //结构移动到末尾
    memmove(dst,src,bytes);
}
</code></pre>
<p>集合插入元素流程图如下：</p>
<center>   
<img src="../../img/redis/intset/intsetAdd.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">插入流程图</div>
</center>

<p>主要思想就是找到插入位置，扩容集合大小并插入，最后更新结构。</p>
<ul>
  <li>首先判断新插入的值对应的编码是否大于现有编码，大于则需要升级整数集合并将元素插入到最后</li>
  <li>若不用升级编码则判断该值是否存在于集合中同时找到待插入位置，若存在则直接返回（注意因为集合是有序的，使用二分查找提高效率）</li>
  <li>若不存在于集合中，那必定找到要插入的位置了，先将集合扩容，并将待插入位置的现有值全部后移一位腾出空间</li>
  <li>
    <p>将值插入到指定位置，并更新集合长度</p>
  </li>
  <li>intsetRemove</li>
</ul>

<pre><code class="language-CPP">/* Delete integer from intset
 * 从整数列表中删除整数值
 * */
intset *intsetRemove(intset *is, int64_t value, int *success) {
    //确定待删除值的编码
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    //成功标识 默认为0 失败
    if (success) *success = 0;

    //待删除值编码 小于等于 整数集合编码  且  该值存在于整数集合中
    if (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) {
        //取出集合数量
        uint32_t len = intrev32ifbe(is-&gt;length);

        /* We know we can delete */
        //此时表明可以删除  设置删除标识为1
        if (success) *success = 1;

        /* Overwrite value with tail and update length
         * 用尾部覆盖值 且 更新长度
         * */
        //如果待删除值的位置 在集合中  直接用 pos+1 位置的值覆盖 pos位置
        if (pos &lt; (len-1)) intsetMoveTail(is,pos+1,pos);
        //整数集合大小减1
        is = intsetResize(is,len-1);
        //更新结构长度字段
        is-&gt;length = intrev32ifbe(len-1);
    }
    return is;
}
</code></pre>
<p>删除就简单很多了，直接查找元素是否存在于集合中，存在则删除元素并将集合大小减 1</p>

<ul>
  <li>intsetFind</li>
</ul>

<pre><code class="language-CPP">/* Determine whether a value belongs to this set
 * 确定该值是否属于该集合
 * */
uint8_t intsetFind(intset *is, int64_t value) {
    //确定该值对应的编码
    uint8_t valenc = _intsetValueEncoding(value);
    //保证该类型要小于集合中的类型  且 集合中可以找到该值
    return valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL);
}
</code></pre>
<p>查看该元素是否存在于集合中即可。</p>

<ul>
  <li>intsetGet</li>
</ul>

<pre><code class="language-CPP">/* Get the value at the given position. When this position is
 * out of range the function returns 0, when in range it returns 1.
 * 返回指定位置的值。
 * 如果位置超过集合长度返回 0 ，在范围内返回 1
 * */
uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {
    //是否越界
    if (pos &lt; intrev32ifbe(is-&gt;length)) {
        //查询索引对应的值
        *value = _intsetGet(is,pos);
        return 1;
    }
    return 0;
}
</code></pre>
<p>返回指定位置对应的值，成功则返回 1，失败返回0，同时值存储在 value 中。</p>

<blockquote>
  <p>参考博客<br />
http://zhangtielei.com/posts/blog-redis-intset.html<br />
https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html#%E6%95%B4%E6%95%B0%E9%9B%86-intset<br />
https://juejin.cn/post/6952824550140674061
https://developer.aliyun.com/article/1242611<br />
https://redisbook.readthedocs.io/en/latest/compress-datastruct/intset.html<br />
https://www.cnblogs.com/yinbiao/p/11249161.html</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">December 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">redis</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-30000006" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>字典/哈希表</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-kaiwalya-limaye-1997844793-29188005.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>dict</h3>
                            
                            </div>

                            <p><h3 id="字典哈希表">字典/哈希表</h3>
<hr />
<p>通常的存储结构是 Key-Value 形式的，通过 Hash函数 对 key 求 Hash 值来确定 Value 的位置，因此也叫 Hash表。是一种用来解决算法中的查找问题的数据结构，默认的算法复杂度接近 O(1)。</p>

<p>特点</p>
<ul>
  <li>Redis 字典的底层实现为哈希表。</li>
  <li>每个字典使用两个哈希表，一般情况下只使用 0 号哈希表，只有在 rehash 进行时，才会同时使用 0 号和 1 号哈希表。</li>
  <li>哈希表使用链地址法来解决键冲突的问题。</li>
  <li>自动 Rehash 扩展或收缩哈希表。</li>
  <li>对哈希表的 rehash 是分多次、渐进式地进行的。</li>
</ul>

<h3 id="数据结构">数据结构</h3>
<hr />
<p>示意图:</p>
<center>   
<img src="../../img/redis/dict/dict-structure.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">dict内存分布图</div>
</center>

<p>源码如下:</p>
<pre><code class="language-CPP">typedef struct dict {
    //哈希算法
    dictType *type;
    //私有数据，用于不同类型的哈希算法的参数
    void *privdata;
    //大小为2的数组，该数组存储元素类型为 dictht，虽然有两个元素，但一般情况下只会使用 ht[0]，只有当该字典扩容、缩容需要进行rehash时，才会用到 ht[1].
    dictht ht[2];
    // rehash 进行到的索引值，当没有在 rehash 的时候，值为-1
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    //rehash 暂停标志，如果大于 0 代表 rehash 暂停
    int16_t pauserehash; /* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */
} dict;

//dictType 实际上就是哈希算法
typedef struct dictType {
    //hash 方法，根据 key 计算哈希值
    uint64_t (*hashFunction)(const void *key);
    //复制 key
    void *(*keyDup)(void *privdata, const void *key);
    //复制 value
    void *(*valDup)(void *privdata, const void *obj);
    //key 比较
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    //销毁 key
    void (*keyDestructor)(void *privdata, void *key);
    //销毁 value
    void (*valDestructor)(void *privdata, void *obj);
    //允许扩容
    int (*expandAllowed)(size_t moreMem, double usedRatio);
} dictType;
</code></pre>
<p>其主要作用是对散列表在进行一层封装，当字典需要进行一些特殊操作时要用到里面的辅助字段。</p>

<pre><code class="language-CPP">/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table.
 * 这是我们的哈希表结构。
 * 当我们实现增量渐进式哈希时，每个字典都有两个这样的表，将旧表放到新表中。
 * */
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;
    //哈希表大小掩码，用于计算索引值
    //总是等于 size-1
    unsigned long sizemask;
    //该哈希表已有节点的数量
    unsigned long used;
} dictht;
</code></pre>
<p>哈希表的结构体整体占用 32 字节，是由数组 table 组成，table中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p>

<pre><code class="language-CPP">typedef struct dictEntry {
    //对应的键
    void *key;
    //对应的值 可以是一个指针，也可以是数字类型
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    //指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
</code></pre>
<p>整体占用 24 字节，key 用来保存键，val 属性用来保存值，是个联合体，值可以是一个指针，也可以是数值类型（包含整数和小数）。<br />
注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过 next 指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。</p>

<h3 id="常用api">常用API</h3>
<hr />
<pre><code class="language-CPP">// 创建字典
dict *dictCreate(dictType *type, void *privDataPtr);
// 字典扩容
int dictExpand(dict *d, unsigned long size);
// 添加键值对，已存在则不添加
int dictAdd(dict *d, void *key, void *val);
// 添加或查找
dictEntry *dictAddOrFind(dict *d, void *key);
// 添加键值对，若存在则修改，反之，添加
int dictReplace(dict *d, void *key, void *val);
// 删除节点
int dictDelete(dict *d, const void *key);
// 删除节点，但不释放内存
dictEntry *dictUnlink(dict *ht, const void *key);
// 释放字典
void dictRelease(dict *d);
// 查找
dictEntry * dictFind(dict *d, const void *key);
// 收缩字典
int dictResize(dict *d);
// 开启 ressize
void dictEnableResize(void);
// 渐进式 rehash, n 为执行几步
int dictRehash(dict *d, int n);
// 扫描字典
unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, dictScanBucketFunction *bucketfn, void *privdata);
</code></pre>

<p><strong>源码解析</strong></p>

<ul>
  <li>dictCreate</li>
</ul>

<pre><code class="language-CPP">/* Create a new hash table
 * 创建哈希表
 * */
dict *dictCreate(dictType *type,
        void *privDataPtr)
{
    //分配初始内存
    dict *d = zmalloc(sizeof(*d));

    //初始化哈希表
    _dictInit(d,type,privDataPtr);
    return d;
}

/* Initialize the hash table
 * 初始化哈希表
 * */
int _dictInit(dict *d, dictType *type,
        void *privDataPtr)
{
    //哈希表 1 重置
    _dictReset(&amp;d-&gt;ht[0]);
    //哈希表 2 重置
    _dictReset(&amp;d-&gt;ht[1]);
    d-&gt;type = type;
    d-&gt;privdata = privDataPtr;
    d-&gt;rehashidx = -1;
    d-&gt;pauserehash = 0;
    return DICT_OK;
}

/* Reset a hash table already initialized with ht_init().
 * 重置已经用 ht_init() 初始化的哈希表
 * NOTE: This function should only be called by ht_destroy().
 * 请注意，这个方法应该只被 ht_destory() 调用
 * */
static void _dictReset(dictht *ht)
{
    ht-&gt;table = NULL;
    ht-&gt;size = 0;
    ht-&gt;sizemask = 0;
    ht-&gt;used = 0;
}
</code></pre>
<p>创建哈希列表，先分配结构对应的初始内存，接着初始化哈希表中各字段对应的值，主要是 dict 对象中的字段</p>

<ul>
  <li>dictExpand</li>
</ul>

<pre><code class="language-CPP">/* return DICT_ERR if expand was not performed
 * 如果扩容执行失败返回 DICT_ERR
 * */
int dictExpand(dict *d, unsigned long size) {
    return _dictExpand(d, size, NULL);
    

/* Expand or create the hash table,
 * when malloc_failed is non-NULL, it'll avoid panic if malloc fails (in which case it'll be set to 1).
 * Returns DICT_OK if expand was performed, and DICT_ERR if skipped.
 * 扩容或创建哈希表，
 * 当malloc_failed为非null时，它将避免malloc失败时的恐慌（在这些情况下，它将被设置为1）
 *
 * */
int _dictExpand(dict *d, unsigned long size, int* malloc_failed)
{
    //如果已尝试扩容失败，重置失败标识 继续扩容
    if (malloc_failed) *malloc_failed = 0;

    /* the size is invalid if it is smaller than the number of
     * elements already inside the hash table
     * 如果该大小 小于哈希表中已存在的元素数量，则该大小无效
     * */
    //不能在重哈希过程中 或 扩容后的数量不能小于等于已使用的数量
    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size)
        return DICT_ERR;

    //扩容后的哈希表
    dictht n; /* the new hash table */
    //扩容后的数量，数量乘2
    unsigned long realsize = _dictNextPower(size);

    /* Detect overflows
     * 检查扩容后是否溢出
     * */
    if (realsize &lt; size || realsize * sizeof(dictEntry*) &lt; realsize)
        return DICT_ERR;

    /* Rehashing to the same table size is not useful.
     * 如果扩容后的数量等于表1的数量 返回失败，无需扩容
     * */
    if (realsize == d-&gt;ht[0].size) return DICT_ERR;

    /* Allocate the new hash table and initialize all pointers to NULL
     * 给新表分配内存 且 初始化所有指针指向null
     * */
    //给扩容后的哈希表初始化属性
    n.size = realsize;
    n.sizemask = realsize-1;
    if (malloc_failed) {
        n.table = ztrycalloc(realsize*sizeof(dictEntry*));
        *malloc_failed = n.table == NULL;
        if (*malloc_failed)
            return DICT_ERR;
    } else
        n.table = zcalloc(realsize*sizeof(dictEntry*));

    n.used = 0;

    /* Is this the first initialization? If so it's not really a rehashing
     * we just set the first hash table so that it can accept keys.
     * 这是第一次初始化吗？如果是这样，那就不是重新散列了，我们只是设置了第一个哈希表，这样他就可以接受键了
     * */
    if (d-&gt;ht[0].table == NULL) {
        d-&gt;ht[0] = n;
        return DICT_OK;
    }

    /* Prepare a second hash table for incremental rehashing
     * 为增量哈希准备第二个哈希表
     * */
    d-&gt;ht[1] = n;
    d-&gt;rehashidx = 0;
    return DICT_OK;
}

/* Our hash table capability is a power of two
 * 我们哈希表的数量都是2的幂数
 * */
static unsigned long _dictNextPower(unsigned long size)
{
    unsigned long i = DICT_HT_INITIAL_SIZE;

    //如果超长则新增后返回
    if (size &gt;= LONG_MAX) return LONG_MAX + 1LU;
    //数量一直累乘2
    while(1) {
        if (i &gt;= size)
            return i;
        i *= 2;
    }
}
</code></pre>
<p>哈希表扩容场景为：当前哈希表空间不足，需要扩容以支撑新元素，还记得 dict#ht[2] 中有两张哈希表吗，扩容实际就是新增一张空哈希表到 h[1] 中，然后通过渐进式哈希逐渐将数据从 h[0] 移动到 h[1] 中。每次扩容后的数量为当前数量最近的 2次幂。</p>

<ul>
  <li>dictAdd</li>
</ul>

<center>   
<img src="../../img/redis/dict/dictAdd.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">字典插入流程图</div>
</center>

<pre><code class="language-CPP">/* Add an element to the target hash table
 * 添加元素到目标哈希表中
 * */
int dictAdd(dict *d, void *key, void *val)
{
    //哈希表新增key
    dictEntry *entry = dictAddRaw(d,key,NULL);

    //若新增失败返回失败
    if (!entry) return DICT_ERR;
    //设置对应的值
    dictSetVal(d, entry, val);
    return DICT_OK;
}

/* Low level add or find:
 * This function adds the entry but instead of setting a value returns the
 * dictEntry structure to the user, that will make sure to fill the value
 * field as they wish.
 * 低级别添加或查询：
 * 此函数添加条目，但不设置值，而是向用户返回 dictEntry 结构，这将确保按用户的意愿填充字段
 *
 * This function is also directly exposed to the user API to be called
 * mainly in order to store non-pointers inside the hash value, example:
 * 这个函数也直接暴露给用户API，主要是为了在哈希值中存储非指针，例如：
 *
 * entry = dictAddRaw(dict,mykey,NULL);
 * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);
 *
 * Return values:
 *
 * If key already exists NULL is returned, and "*existing" is populated
 * with the existing entry if existing is not NULL.
 * 如果key已经存在直接返回null， 如果 existing 非null， *existing 则填充为已有的节点
 *
 * If key was added, the hash entry is returned to be manipulated by the caller.
 * 如果添加了 key，则返回哈希项以供调用者操作
 */
dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
{
    long index;
    dictEntry *entry;
    dictht *ht;

    //判断哈希表是否在重新哈希中
    if (dictIsRehashing(d)) _dictRehashStep(d);

    /* Get the index of the new element, or -1 if
     * the element already exists.
     * 获取新元素的索引位置，如果元素已经存在则为-1
     * */
    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
        return NULL;

    /* Allocate the memory and store the new entry.
     * Insert the element in top, with the assumption that in a database
     * system it is more likely that recently added entries are accessed
     * more frequently.
     * 分配内存且存储新节点
     * 将新元素插入到顶部，假设在数据库系统中，最近添加的条目更有可能被频繁的访问
     * */
    //判断是否处于渐进式哈希，是则返回表1否则返回表0
    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];
    //分配新节点的内存
    entry = zmalloc(sizeof(*entry));
    //新节点的下一个指针指向 当前哈希表数组对应位置
    entry-&gt;next = ht-&gt;table[index];
    //将新节点替换原索引
    ht-&gt;table[index] = entry;
    //已使用节点++
    ht-&gt;used++;

    /* Set the hash entry fields.
     * 设置哈希字段
     * */
    dictSetKey(d, entry, key);
    return entry;
}

/* This function performs just a step of rehashing, and only if hashing has
 * not been paused for our hash table. When we have iterators in the
 * middle of a rehashing we can't mess with the two hash tables otherwise
 * some element can be missed or duplicated.
 * 这个函数只执行重新散列的一个步骤，并且只有在散列没有暂停的情况下才执行。
 * 当我们在重新散列过程中使用迭代器时，我们不能混淆两个哈希表，否则可能会丢失或重复某些元素
 *
 * This function is called by common lookup or update operations in the
 * dictionary so that the hash table automatically migrates from H1 to H2
 * while it is actively used.
 * 该函数由字典中的常见查找或更新操作调用，以便哈希表在活跃使用时自动从 H1迁移到 H2.
 * */
static void _dictRehashStep(dict *d) {
    //当 pauserehash 为0 ，表示在哈希中
    if (d-&gt;pauserehash == 0) dictRehash(d,1);
}

/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 * 执行 N 步增量哈希。如果仍然存在键需要从旧表移动到新表则返回1，否则返回0
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time.
 * 请注意 一个重哈希步骤包含移动一个桶(正如我们使用的链式包含不止一个kry) 从旧表到新表，
 * 但是由于哈希表的其他部分可能包含空白空间，它不保证这个方法重新哈希甚至是单个桶，因为它总共会访问最大 N*10 个空桶，
 * 否则它所做的工作将被解除绑定，而且这个方法可能会阻塞很长时间
 * */
int dictRehash(dict *d, int n) {
    //空桶的最大访问数量
    int empty_visits = n*10; /* Max number of empty buckets to visit. */
    //初始化 两个哈希表的当前大小
    unsigned long s0 = d-&gt;ht[0].size;
    unsigned long s1 = d-&gt;ht[1].size;
    //判断哈希是否被禁止 返回0
    if (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) return 0;
    //如果允许哈希，但是 当前比率 小于 dict_force_resize_ratio 即不允许调整大小 则返回0
    if (dict_can_resize == DICT_RESIZE_AVOID &amp;&amp;
        ((s1 &gt; s0 &amp;&amp; s1 / s0 &lt; dict_force_resize_ratio) ||
         (s1 &lt; s0 &amp;&amp; s0 / s1 &lt; dict_force_resize_ratio)))
    {
        return 0;
    }

    //循环 n 直到为 0，且 哈希表 0 已使用的节点不等于0
    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0
         * 请注意，rehashidx 不能溢出，因为我们确信有更多的元素，因为 哈希表0 使用的元素不等于 0
         * */
        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);
        //若哈希表0 所对应的 rehashidx 索引位置的值为 null
        //说明访问到空桶了，哈希索引值++， 最大空桶访问量empty_visits--，直到等于0，说明 rehash结束返回1
        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {
            d-&gt;rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        //取出当前哈希索引所对应的值
        de = d-&gt;ht[0].table[d-&gt;rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT
         * 将这个桶中的所有键从旧的哈希表中移动到新的哈希表中
         * */
        //因为 de 是dictEntry，是链表，所以需要将整个链表中的元素都重哈希到 表1 中
        while(de) {
            //初始化重哈希的值
            uint64_t h;
            //保留下一个链表要处理的值，因为当前要处理 de
            nextde = de-&gt;next;
            /* Get the index in the new hash table
             * 使用表1的 sizemask 重新计算索引位置
             * */
            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;
            //将表1中 h 对应字典值插入到 待插入值 de 的后面
            de-&gt;next = d-&gt;ht[1].table[h];
            //将de 赋值给新位置
            d-&gt;ht[1].table[h] = de;
            //表0可用元素 --
            d-&gt;ht[0].used--;
            //表1可用元素++
            d-&gt;ht[1].used++;
            //将de设置为链表对应的下一个值
            de = nextde;
        }
        //上述操作遍历完后说明 表0的元素都重哈希结束 将 rehashidx 索引位置的值设置为0
        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;
        //rehashidx 索引位置+1
        d-&gt;rehashidx++;
    }

    /* Check if we already rehashed the whole table...
     * 检查是否已经将整个哈希表都重哈希
     * */
    //若表0 已使用的节点数量为 0 说明都重哈希过了
    if (d-&gt;ht[0].used == 0) {
        //释放表0的内存
        zfree(d-&gt;ht[0].table);
        //将表1 替换 表0
        d-&gt;ht[0] = d-&gt;ht[1];
        //重置表1
        _dictReset(&amp;d-&gt;ht[1]);
        //重置rehashidx为-1
        d-&gt;rehashidx = -1;
        return 0;
    }

    /* More to rehash...
     * 还有剩余的值需要哈希
     * */
    return 1;
}

/* Returns the index of a free slot that can be populated with
 * a hash entry for the given 'key'.
 * If the key already exists, -1 is returned
 * and the optional output parameter may be filled.
 * 返回空闲槽位的索引，它可以用给定 key 的散列条目填充
 * 如果 key 已经存在，直接返回-1， 且 可选的输出参数可能被填充。
 *
 * Note that if we are in the process of rehashing the hash table, the
 * index is always returned in the context of the second (new) hash table.
 * 请注意 如果处于正在重新哈希的过程中时，这个索引总是在新哈希表的上下文中返回
 * */
static long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **existing)
{
    unsigned long idx, table;
    dictEntry *he;
    if (existing) *existing = NULL;

    /* Expand the hash table if needed
     * 如果需要的话扩容哈希表
     * */
    if (_dictExpandIfNeeded(d) == DICT_ERR)
        //扩容失败返回-1
        return -1;
    //从表0和表1中根据哈希值找到对应的值
    for (table = 0; table &lt;= 1; table++) {
        //计算哈希位置
        idx = hash &amp; d-&gt;ht[table].sizemask;
        /* Search if this slot does not already contain the given key
         * 检查这个槽位是否已经存在给定的key
         * */
        //找到当前表中指定哈希位置的节点
        he = d-&gt;ht[table].table[idx];
        //遍历哈希表数组，如果 对应键key 相同 或值相同则返回-1，不存在则返回后计算的哈希值
        while(he) {
            if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) {
                if (existing) *existing = he;
                return -1;
            }
            he = he-&gt;next;
        }
        if (!dictIsRehashing(d)) break;
    }
    return idx;
}
</code></pre>
<p>哈希表插入元素核心逻辑就是检查原有哈希表是否需要扩容，需要则直接扩容，然后计算新值哈希后对应的索引位置，从 表0 和 表1 (因为处于渐进式哈希过程中会导致表0和表1都有值) 查找是否已经存在该值，不存在则插入到对应的哈希表中，如果产生哈希冲突，则使用链地址法将新值插入到链表中。<br />
其中需要注意，插入时如果处于渐进式哈希过程中，需要先处理渐进式哈希再执行插入逻辑。</p>

<ul>
  <li>dictDelete</li>
</ul>

<pre><code class="language-CPP">/* Remove an element, returning DICT_OK on success or DICT_ERR if the
 * element was not found.
 * 移除元素，成功返回 DICT_OK ，若元素不存在返回 DICT_ERR
 * */
int dictDelete(dict *ht, const void *key) {
    //删除节点并且释放内存
    return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
}

/* Search and remove an element. This is an helper function for
 * dictDelete() and dictUnlink(), please check the top comment
 * of those functions.
 * 搜索并移除元素。他是dictDelete() and dictUnlink()的辅助函数，请检查这些函数的头部注释
 *
 * d:哈希表
 * key:待删除的key
 * nofree:是否释放内存  0-释放 1-不释放
 * */
static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
    //初始化变量
    //h: key对应的哈希值
    //idx: key对应的索引位置
    uint64_t h, idx;
    //*he: idx对应的哈希链表节点
    //*prevHe: 遍历*he时对应的前节点
    dictEntry *he, *prevHe;
    //哈希表d对应的表0和表1
    int table;

    //如果哈希表1和表2的已使用元素都为0说明哈希表为空，直接返回null
    if (d-&gt;ht[0].used == 0 &amp;&amp; d-&gt;ht[1].used == 0) return NULL;

    //若哈希表处于重哈希过程中，执行重哈希方法
    if (dictIsRehashing(d)) _dictRehashStep(d);

    //计算新key对应的哈希值
    h = dictHashKey(d, key);

    //遍历表0和表1检查是否需要删除元素
    for (table = 0; table &lt;= 1; table++) {
        //计算对应的索引位置
        //例如：h为5，哈希表的大小初始化为4，sizemask则为size-1
        //故有 h&amp;sizemask = 2，所以该键值对就是存放在索引位置为2的地方
        idx = h &amp; d-&gt;ht[table].sizemask;
        //找到对应位置哈希链表节点
        he = d-&gt;ht[table].table[idx];

        //前置节点
        prevHe = NULL;
        //若存在哈希链表节点
        while(he) {
            //若key相同，执行删除动作
            if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) {
                /* Unlink the element from the list
                 * 从链表中移除该元素
                 * */
                //判断是否存在前置节点
                if (prevHe)
                    //将前置节点的下一个节点指针指向当前节点的下一个节点
                    prevHe-&gt;next = he-&gt;next;
                else
                    //没有前置节点 直接将当前节点的下一个节点覆盖到表中
                    d-&gt;ht[table].table[idx] = he-&gt;next;
                //是否要释放内存 key和val
                if (!nofree) {
                    //哈希表释放
                    dictFreeKey(d, he);
                    dictFreeVal(d, he);
                    //空间释放
                    zfree(he);
                }
                //删除成功已使用元素
                d-&gt;ht[table].used--;
                return he;
            }
            //赋值前置节点 prevHe的值
            prevHe = he;
            //继续往下遍历
            he = he-&gt;next;
        }
        //如果哈希表不在重哈希过程中，说明元素都在一个表中，直接返回
        if (!dictIsRehashing(d)) break;
    }
    //若没有发现相同key的元素直接返回null
    return NULL; /* not found */
}
</code></pre>
<p>删除节点基本同插入节点。</p>
<ol>
  <li>首先还是执行渐进式哈希</li>
  <li>计算待删除的键对应的哈希值</li>
  <li>分别遍历表0和表1，并计算哈希值对应的索引位置</li>
  <li>找到对应的哈希链表节点，如果值相同则删除该节点并释放内存，否则继续遍历下一个节点直到结束</li>
</ol>

<ul>
  <li>dictFind</li>
</ul>

<pre><code class="language-CPP">//根据key查找元素
dictEntry *dictFind(dict *d, const void *key)
{
    dictEntry *he;
    uint64_t h, idx, table;

    //如果哈希表为空直接返回null
    if (dictSize(d) == 0) return NULL; /* dict is empty */
    //如果哈希表处于重哈希过程中执行渐进式哈希
    if (dictIsRehashing(d)) _dictRehashStep(d);
    //计算该key对应的哈希值
    h = dictHashKey(d, key);
    //遍历两个哈希表
    for (table = 0; table &lt;= 1; table++) {
        //计算当前表中 哈希对应的索引位置
        idx = h &amp; d-&gt;ht[table].sizemask;
        //取出对应索引位置的哈希链表节点
        he = d-&gt;ht[table].table[idx];
        //遍历链表节点
        while(he) {
            //若存在哈希值相同的key则返回
            if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))
                return he;
            //继续往下遍历
            he = he-&gt;next;
        }
        //若遍历过程中发现重哈希结束，直接返回null  说明元素都在另一个表中
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}
</code></pre>
<p>查找逻辑也基本类似，见代码逻辑即可。</p>

<h3 id="重点关注-渐进式hash">重点关注-渐进式hash</h3>
<hr />

<ul>
  <li>dictRehash</li>
</ul>

<center>   
<img src="../../img/redis/dict/dictRehash.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">字典渐进式哈希流程图</div>
</center>

<p>源码如下：</p>

<pre><code class="language-CPP">/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 * 执行 N 步增量哈希。如果仍然存在键需要从旧表移动到新表则返回1，否则返回0
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time.
 * 请注意 一个重哈希步骤包含移动一个桶(正如我们使用的链式包含不止一个kry) 从旧表到新表，
 * 但是由于哈希表的其他部分可能包含空白空间，它不保证这个方法重新哈希甚至是单个桶，因为它总共会访问最大 N*10 个空桶，
 * 否则它所做的工作将被解除绑定，而且这个方法可能会阻塞很长时间
 * */
int dictRehash(dict *d, int n) {
    //空桶的最大访问数量
    int empty_visits = n*10; /* Max number of empty buckets to visit. */
    //初始化 两个哈希表的当前大小
    unsigned long s0 = d-&gt;ht[0].size;
    unsigned long s1 = d-&gt;ht[1].size;
    //判断哈希是否被禁止 返回0
    if (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) return 0;
    //如果避免哈希，但是 当前比率 小于 dict_force_resize_ratio 即不允许调整大小 则返回0
    if (dict_can_resize == DICT_RESIZE_AVOID &amp;&amp;
        ((s1 &gt; s0 &amp;&amp; s1 / s0 &lt; dict_force_resize_ratio) ||
         (s1 &lt; s0 &amp;&amp; s0 / s1 &lt; dict_force_resize_ratio)))
    {
        return 0;
    }

    //循环 n 直到为 0，且 哈希表 0 已使用的节点不等于0
    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0
         * 请注意，rehashidx 不能溢出，因为我们确信有更多的元素，因为 哈希表0 使用的元素不等于 0
         * */
        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);
        //若哈希表0 所对应的 rehashidx 索引位置的值为 null
        //说明访问到空桶了，哈希索引值++， 最大空桶访问量empty_visits--，直到等于0，说明 rehash结束返回1
        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {
            d-&gt;rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        //取出当前哈希索引所对应的值
        de = d-&gt;ht[0].table[d-&gt;rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT
         * 将这个桶中的所有键从旧的哈希表中移动到新的哈希表中
         * */
        //因为 de 是dictEntry，是链表，所以需要将整个链表中的元素都重哈希到 表1 中
        while(de) {
            //初始化重哈希的值
            uint64_t h;
            //保留下一个链表要处理的值，因为当前要处理 de
            nextde = de-&gt;next;
            /* Get the index in the new hash table
             * 使用表1的 sizemask 重新计算索引位置
             * */
            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;
            //将表1中 h 对应字典值插入到 待插入值 de 的后面
            de-&gt;next = d-&gt;ht[1].table[h];
            //将de 赋值给新位置
            d-&gt;ht[1].table[h] = de;
            //表0可用元素 --
            d-&gt;ht[0].used--;
            //表1可用元素++
            d-&gt;ht[1].used++;
            //将de设置为链表对应的下一个值
            de = nextde;
        }
        //上述操作遍历完后说明 表0的元素都重哈希结束 将 rehashidx 索引位置的值设置为0
        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;
        //rehashidx 索引位置+1
        d-&gt;rehashidx++;
    }

    /* Check if we already rehashed the whole table...
     * 检查是否已经将整个哈希表都重哈希
     * */
    //若表0 已使用的节点数量为 0 说明都重哈希过了
    if (d-&gt;ht[0].used == 0) {
        //释放表0的内存
        zfree(d-&gt;ht[0].table);
        //将表1 替换 表0
        d-&gt;ht[0] = d-&gt;ht[1];
        //重置表1
        _dictReset(&amp;d-&gt;ht[1]);
        //重置rehashidx为-1
        d-&gt;rehashidx = -1;
        return 0;
    }

    /* More to rehash...
     * 还有剩余的值需要哈希
     * */
    return 1;
}
</code></pre>

<p>触发 rehash 的条件有两个：</p>
<ol>
  <li>总的元素个数 除 dict 桶的个数得到每一个桶平均存储的元素个数（pre_num），假设 pre_num &gt; dict_force_resize_ratio，就会触发 dict 扩容操作</li>
  <li>在总元素 * 10 &lt; 桶的个数，也就是填充率必须 &lt; 10%，dict便会进行收缩，让 total/bk_num 接近 1:1</li>
</ol>

<p>随着操作的不断进行，哈希表的长度会不断增减。哈希表的长度太长会造成空间浪费，太短哈希冲突明显导致性能下降，哈希表需要通过扩缩容让哈希表的长度保持在一个合理的范围内。<br />
redis 通过 ht[0] 和 ht[1] 来完成 rehash 的操作，步骤如下：</p>
<ol>
  <li>为 ht[1] 分配空间，分配的空间长度有两种情况：
    <ul>
      <li>扩容：第一个大于等于 ht[0].used*2 的 2^n 的数。例如 ht[0].used = 3，那么分配的是距离 6 最近的 2^3=8</li>
      <li>缩容：第一个大于等于 ht[0].used/2 的 2^n 的数。例如 ht[0].used = 6，那么分配的是距离 3 最近的 2^2=4</li>
    </ul>
  </li>
  <li>将 h[0] 上的键值对都迁移到 h[1]，迁移的时候都是重新计算索引值的。由于 h[1] 的长度较长，之前在 h[0] 拉链的元素大概率被分到不同的位置。</li>
  <li>ht[0] 所有的键值对迁移完之后，h[0] 释放，然后 h[0] 替换为 h[1]，并把 h[1] 清空，为下次 rehash 准备</li>
</ol>

<p>上面说的第二步，迁移的过程不是一次完成的。如果哈希表的长度比较小，一次完成很快。但是如果哈希表很长，例如百万千万，那这个迁移的过程就没有那么快了，会造成命令阻塞。<br />
下面来看，redis是如何渐进式地将 h[0] 中的键值对迁移到 h[1] 中的:</p>
<ol>
  <li>为 h[1] 开辟空间，字典同时持有 h[0] 和 h[1]</li>
  <li>字典中的 rehashidx 维护了 rehash 的进度，设置为 0 的时候，开始 rehash</li>
  <li>字典每次增删改查的时候，除了完成指定操作之外，还会顺带把 rehashidx 上的整个链表迁移到 h[1] 中，迁移完成后 rehashidx++</li>
  <li>随着字典的不断读取、操作，最终 h[0] 上的所有键值对都会迁移到 h[1] 中，全部迁移完成之后 rehashidx = -1</li>
</ol>

<p>这种渐进式 rehash 的方式的好处在于，将庞大的迁移工作，分摊到每次的增删改查中，避免了一次性操作带来的性能的巨大损耗。<br />
缺点就是迁移过程中 h[0] 和 h[1] 同时存在的时间比较长，空间利用率低</p>

<p><strong>rehash迁移过程</strong></p>

<center>   
<img src="../../img/redis/dict/rehash%231.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">渐进式哈希步骤1</div>
</center>
<center>   
<img src="../../img/redis/dict/rehash%232.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">渐进式哈希步骤2</div>
</center>
<center>   
<img src="../../img/redis/dict/rehash%233.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">渐进式哈希步骤3</div>
</center>
<center>   
<img src="../../img/redis/dict/rehash%234.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">渐进式哈希步骤4</div>
</center>
<center>   
<img src="../../img/redis/dict/rehash%235.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">渐进式哈希步骤5</div>
</center>
<center>   
<img src="../../img/redis/dict/rehash%236.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">渐进式哈希步骤6</div>
</center>
<center>   
<img src="../../img/redis/dict/rehash%237.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">渐进式哈希步骤7</div>
</center>

<h3 id="重点关注-字典扫描">重点关注-字典扫描</h3>
<hr />

<ul>
  <li>dictScan</li>
</ul>

<p>dict.c 中的 dictScan 函数用来遍历字典，迭代其中的每个元素，该函数使用的算法很巧妙。</p>

<p>遍历一个稳定的字段很简单，但 redis 中的字典因为有 rehash 的过程，使字典可能扩展，也可能缩小。这就带来了问题，如果在两次遍历中间，字典的结构发生了变化（扩展或者缩小），字典中的元素所在的位置相应的会发生变化，那如何保证字典中原有的元素都可以被遍历？又如何能尽可能少的重复迭代呢？这就是该算法的精妙所在，使用该算法，可以做到下面两点：</p>
<ul>
  <li>开始遍历那一刻的所有元素，只要不被删除，肯定能被遍历到，不管字典扩展还是缩小</li>
  <li>该算法可能会返回重复元素，但是已经把返回重复元素的可能性降到了最低</li>
</ul>

<p><strong>游标cursor的演变</strong><br />
该算法使用了游标 cursor 来遍历字典，它表示每次要访问的 bucket 的索引。bucket 中保存了一个链表，因此每次迭代都会把该 bucket 的链表中的所有元素都遍历一遍。<br />
第一次迭代时，cursor 置为 0，dictScan 函数的返回值作为下一个 cursor 再次调用 dictScan，最终，dictScan 函数返回0 表示迭代结束。<br />
首先看一下 cursor 的演变过程，也是该算法的核心所在。这里 cursor 的演变采用了 reverse binary iteration 方法，也就是每次向 cursor 的最高位加1，并向低位方向进位。</p>

<p>首先看下 cursor 的演变过程：</p>
<pre><code class="language-CPP">void test_dictScan_cursor(int tablesize)
{
    unsigned long v;
    unsigned long m0;

    v = 0;
    m0 = tablesize-1;

    printbits(v, (int)log2(tablesize));
    printf(" --&gt; ");

    do
    {   
        v |= ~m0;
        v = rev(v);
        v++;      
        v = rev(v);

        printbits(v, (int)log2(tablesize));
        printf(" --&gt; ");
    }while (v != 0);    
    
    printf("\b\b\b\b\b     \n");
}
</code></pre>
<p>以 tablesize 为 8 和 16 分别运行该函数，结果如下：</p>
<blockquote>
  <p>8: 000 =&gt; 100 =&gt; 010 =&gt; 110 =&gt; 001 =&gt; 101 =&gt; 011 =&gt; 111 =&gt; 000<br />
16: 0000 =&gt; 1000 =&gt; 0100 =&gt; 1100 =&gt; 0010 =&gt; 1010 =&gt; 1110 =&gt; 0001 =&gt; 1001 =&gt; 0101 =&gt; 1101 =&gt; 0011 =&gt; 1011 =&gt; 0111 =&gt; 1111 =&gt; 0000</p>
</blockquote>

<p>所谓的 reverse binary itreation 方法，也就是每次向 v 的最高位加 1，并向低位方向进位。比如 1101 的下一个数是 0011，因为 1101 的前三个数为 110，最高位加 1，并且向低位进位就是 001，所以最终得到 0011.</p>

<p>在 redis 中，字典的哈希表长度始终为 2^n 。因此 m0 始终是 一个低 n 位全为 1 ，其余位全为 0 的数。
整个计算过程，都是在 v 的低 n 位数中进行的，比如长度为 16 的哈希表，则 n=4，因此 v 是从 0到15 这几个数之间的转换。<br />
下面解释一下计算过程：<br />
第一步： v|=~m0  //用于保留 v 的低 n 位数，其余位全置为 1</p>
<center>   
<img src="../../img/redis/dict/rbi%23step1.png" class="img-responsive img-centered" alt="image-alt" />
</center>
<p>第二步： v = rev(v) //将 v 的二进制位进行翻转，所以 v 的低 n 位数成了 高 n 位数，并且进行了翻转</p>
<center>   
<img src="../../img/redis/dict/rbi%23step2.png" class="img-responsive img-centered" alt="image-alt" />
</center>
<p>第三步： v++</p>
<center>   
<img src="../../img/redis/dict/rbi%23step3.png" class="img-responsive img-centered" alt="image-alt" />
</center>
<p>最后一步： v = rev(v) //再次翻转</p>
<center>   
<img src="../../img/redis/dict/rbi%23step4.png" class="img-responsive img-centered" alt="image-alt" />
</center>
<p>因此，最终得到的新 v，就是向最高位加 1，且向低位方向进位。</p>

<p>或者参考下图：</p>
<center>   
<img src="../../img/redis/dict/逆二进制翻转.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">逆二进制翻转示意图</div>
</center>

<p><strong>为什么要这么设计</strong><br />
这样设计的原因就在于，字典中的哈希表有可能扩展，也有可能缩小。在字典不稳定的情况下，既要遍历到所有没被删除的元素，又要尽可能较少的重复遍历。<br />
迭代哈希表时，有以下三种情况：</p>
<ul>
  <li>从迭代开始到结束，哈希表不 rehash</li>
  <li>从迭代开始到结束，哈希表 rehash，但每次迭代，哈希表要么不开始 rehash，要么已经结束 rehash</li>
  <li>从一次迭代开始到结束，哈希表在一次或多次迭代中 rehash - 即在 rehash 过程中，执行 Scan 命令，这时数据可能只迁移了一部分</li>
</ul>

<p>下面详细解释一下这样设计好处，以及为什么不是按照正常的 0,1,2,3… 这样的顺序迭代？</p>

<p>计算一个哈希表节点索引的方法是 hashkey&amp;mask ，其中，mask 的值永远是哈希表大小减 1。哈希表长度为 8，则 mask 为 111，因此，节点的索引值就取决于 hashkey 的低三位，假设是 abc，如果哈希表长度为16，则 mask 为 1111，同样的节点计算得到的哈希值不变，而索引值是 ?abc ，其中 ? 既可能是 0，也可能是 1，也就是说，该节点在长度为 16 的哈希表中，索引是 0abc 或者 1abc。以此类推，如何哈希表长度为 32，则该节点的索引是 00abc，01abc，10abc或者11abc 中的一个。<br />
重新看一下该算法中，哈希表长度分别为 8 和 16时，cursor 变化过程：</p>
<blockquote>
  <p>8: 000 =&gt; 100 =&gt; 010 =&gt; 110 =&gt; 001 =&gt; 101 =&gt; 011 =&gt; 111 =&gt; 000<br />
16: 0000 =&gt; 1000 =&gt; 0100 =&gt; 1100 =&gt; 0010 =&gt; 1010 =&gt; 1110 =&gt; 0001 =&gt; 1001 =&gt; 0101 =&gt; 1101 =&gt; 0011 =&gt; 1011 =&gt; 0111 =&gt; 1111 =&gt; 0000</p>
</blockquote>

<p>哈希表长度为 8 时，第 i 个 cursor（0&lt;=i&lt;=7），扩展到长度为 16 的哈希表中，对应的 cursor 是 2i和2i+1，它们是相邻的，这点很重要。</p>

<p>首先是 <strong>字典扩展</strong> 的情况，假设当前字典哈希表长度为 8，在迭代完索引为 010 的 bucket 之后，下一个 cursor 为 110。假设在下一次迭代前，字典哈希表长度扩展成了 16,110 这个 cursor，在长度为 16 的情况下，就成了 0110，因此开始迭代索引为 0110 的 bucket 中的节点。<br />
在长度为 8 时，已经迭代过的 cursor 分别是： 000,100,010。哈希表长度扩展到 16 后，在这些索引的 bucket 中的节点，分布到新的 bucket 中，新 bucket 的索引将会是：0000,1000,0100,1100,0010,1010。而这些，正好是将要迭代的 0110 之前的索引，从 0110 开始，按照长度为 16 的哈希表 cursor 变化过程迭代下去，这样既不会漏掉节点，也不会迭代重复的节点。</p>

<p>再看下 <strong>字典缩小</strong> 的情况，也就是由 16 缩小为 8。在长度为 16 时，迭代完 0100 的 cursor 之后，下一个 cursor 为 1100，假设此时哈希表长度缩小为 8。1100 这个cursor，在长度为 8 的情况下，就 成了 100. 因此开始迭代索引为 100 的 bucket 中的节点。<br />
在长度为 16 时，已经迭代过的 cursor 是：0000,1000,0100，哈希表长度缩小后，这些索引的 bucket 中的节点，分布到新的 bucket 中，新 bucket 的索引将会是 000 和 100.现在要从索引为 100 的 bucket 开始迭代，这样不会漏掉节点，但是之前长度为 16 时，索引为 0100 中的节点会被重复迭代，然而，也就仅 0100 这一个 bucket 中的节点会重复而已。<br />
原哈希表长度为 x，缩小后长度为 y，则最多会有 x/y - 1 个原 bucket 的节点会被重复迭代。比如由 16 缩小为 8，则最多就有 1 个 bucket 节点会重复迭代，要是由 32 缩小为 8，则最多会有 3 个。<br />
当然也有可能不产生重复迭代，还是从 16 缩小为 8 的情况，如果已经迭代完 1100，下一个 cursor 为 0010，此时长度缩小为 8，cursor 就成了 010。<br />
长度为 16 时，已经迭代过的 cursor 为 0000,1000,0100,1100，长度缩小后，这些 cursor 对应到新的索引是 000 和 100，正好是 010 之前的索引，从 010 开始，按照长度为 8 的 cursor 走下去，不会漏掉节点，也不会重复节点。<br />
所以说这种算法，保证了能迭代完所有节点而不会漏掉，又能尽可能少的重复遍历。</p>

<p>如果按照正常的顺序迭代，下面分别是长度为 8 和 16 对应的 cursor 变化过程：</p>
<blockquote>
  <p>8: 000 –&gt; 001 –&gt; 010 –&gt; 011 –&gt; 100 –&gt; 101 –&gt; 110 –&gt; 111 –&gt; 000
16: 0000 –&gt; 0001 –&gt; 0010 –&gt; 0011 –&gt; 0100 –&gt; 0101 –&gt; 0110 –&gt; 0111 –&gt; 1000 –&gt; 1001 –&gt; 1010 –&gt; 1011 –&gt; 1100 –&gt; 1101 –&gt; 1110 –&gt; 1111 –&gt; 0000</p>
</blockquote>

<p>字典扩展的情况下，当前字典哈希表长度为 8，假设在迭代完 cursor 为 010 的 bucket 之后，下一个 cursor 为 011。迭代 011 之前，字典长度扩展成了 16，011 这个 cursor ，在长度为 16 的情况下，就成了 0011，因此开始迭代索引为 0011 的 bucket 中的节点。<br />
在长度为 8 时，已经迭代过的 cursor 是：000,001,010. 哈希表长度扩展到 16 后，这些索引的 bucket 中的节点，会分布到新的 bucket 中，新 bucket 的索引将会是：0000,1000,0001,1001,0010和1010.现在要开始迭代的 cursor 为 0011，而 1000,1001,1010 这些 bucket 中的节点在后续还是会遍历到，这就产生了重复遍历。<br />
虽然这种情况不会发生漏掉节点的情况，但是肯定会有重复的情况发生，而且长度变化发生的时机越晚，重复遍历的节点越多，比如长度为 8 时，迭代完 110 后，下一个 cursor 为 111，长度扩展为 16 后，这个 cursor 就成了 0111.<br />
长度为 8 时，已经迭代过的 cursor 为 000,001,010，011,100，101,110扩展到长度为 16 的哈希表中，这些 bucket 中的节点会分布到索引为：0000,1000,0001,1001,0010,1010,0011,1011,0100,1100,0101,1101,0110，1110. 现在长度为 16，要开始迭代 cursor 为 0111，而 1000,1001,1010,1011和1110 这些节点后续还会遍历到，重复的节点增多了。</p>

<p>再看下长度缩小的情况下，长度由 16 缩小为 8.在长度为 16 时，迭代完 0100 的 cursor 之后，下一个 cursor 为 0101，此时长度缩小为 8。0101 这个 cursor，在长度为 8 的情况下，就成了 101.<br />
在长度为 16 时，尚未迭代过的 cursor 是：0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111。这些 cursor，在哈希表长度缩小后，分配到新的 bucket 中，索引将会是：000,001,010,011，100,101,110,111.现在要开始迭代的 cursor 为 101，那 101 之前的 000,001,010,011,100 这些 cursor 就不会迭代了，这样，原有的某些节点就被漏掉了。<br />
另外，还是从 16 缩小为 8 的情况，如果已经迭代完 1100，下一个 cursor 为 1101，在长度为 8 的情况下，就成了 101.<br />
长度为 16 时，已经迭代过的 cursor 为 0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100.这些 cursor，在哈希表长度缩小后，分配到新的 bucket 中，索引分别是：000,001,010,011,100,101,110,111。长度变为 8 后，从 101 开始，很明显，原来已经迭代过的 0101,0110,0111 就会产生重复迭代。<br />
因此顺序迭代不是一个满足要求的方法。</p>

<p>扫描执行流程图如下：</p>

<center>
<img src="../../img/redis/dict/dictScan.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">字典扫描执行流程</div>
</center>

<p><strong>scan迭代器的缺点</strong></p>
<ul>
  <li>函数可能返回重复的元素，需要在应用层去处理</li>
  <li>为了不遗漏任何元素，迭代器需要返回给定桶上的所有键，以及因为扩展哈希表而产生的新表，所以迭代器必须在一次迭代中返回多个元素</li>
  <li>具体英文注释见下方源码</li>
</ul>

<p>源码如下:</p>

<pre><code class="language-CPP">
/* dictScan() is used to iterate over the elements of a dictionary.
 *
 * dictScan 用于遍历字典中的元素
 *
 * Iterating works the following way:
 * 迭代的工作方式如下
 *
 * 1) Initially you call the function using a cursor (v) value of 0.
 * 1) 最初 你使用游标 0 来调用函数
 * 2) The function performs one step of the iteration, and returns the
 *    new cursor value you must use in the next call.
 * 2) 该函数执行迭代的一个步骤，返回你必须在下一个调用使用的新游标
 * 3) When the returned cursor is 0, the iteration is complete.
 * 3) 当返回的游标为0，迭代就已经完成
 *
 * The function guarantees all elements present in the
 * dictionary get returned between the start and end of the iteration.
 * However it is possible some elements get returned multiple times.
 * 该函数保证在迭代开始和结束之前返回字典中存在的所有元素。
 * 但是有可能一些元素返回多次
 *
 * For every element returned, the callback argument 'fn' is
 * called with 'privdata' as first argument and the dictionary entry
 * 'de' as second argument.
 * 对于每个返回的元素，回调参数 fn 被调用，private 作为第一个参数，字典条目 de 作为第二个参数
 *
 * HOW IT WORKS.
 * 他是如何工作的
 *
 * The iteration algorithm was designed by Pieter Noordhuis.
 * The main idea is to increment a cursor starting from the higher order
 * bits. That is, instead of incrementing the cursor normally, the bits
 * of the cursor are reversed, then the cursor is incremented, and finally
 * the bits are reversed again.
 * 这个迭代算法是由 Pieter Noordhuis 设计的。
 * 主要思想是将游标从二进制高位递增。也就是说，不是正常的增加游标，而是对光标的位进行反转，然后对光标进行递增，最后再次对位进行反转。
 *
 * This strategy is needed because the hash table may be resized between
 * iteration calls.
 * 这个策略是必须的，因为哈希表可能会在迭代调用之间调整大小
 *
 * dict.c hash tables are always power of two in size, and they
 * use chaining, so the position of an element in a given table is given
 * by computing the bitwise AND between Hash(key) and SIZE-1
 * (where SIZE-1 is always the mask that is equivalent to taking the rest
 *  of the division between the Hash of the key and SIZE).
 * 哈希表的大小总是2的幂次，并且他们使用链，因此给定表中元素的位置是通过计算 哈希key和 size-1 之间的按位与来给出的。
 * （其中 size-1 总是掩码，相当于取键的哈希值和size之间的剩余部分）
 *
 * For example if the current hash table size is 16, the mask is
 * (in binary) 1111. The position of a key in the hash table will always be
 * the last four bits of the hash output, and so forth.
 * 例如当前哈希表大小是16，二进制为1111。
 * 键在哈希表中的位置始终是哈希输出的最后四位，以此类推
 *
 * WHAT HAPPENS IF THE TABLE CHANGES IN SIZE?
 * 如果表的大小改变会发生什么？
 *
 * If the hash table grows, elements can go anywhere in one multiple of
 * the old bucket: for example let's say we already iterated with
 * a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).
 * 如果哈希表增长，元素可以在旧桶的一个倍数内移动到任何地方。
 * 举例来说：假设我们已经迭代了一个 4 位游标 1100（掩码是1111，因为哈希表大小为16）
 *
 * If the hash table will be resized to 64 elements, then the new mask will
 * be 111111. The new buckets you obtain by substituting in ??1100
 * with either 0 or 1 can be targeted only by keys we already visited
 * when scanning the bucket 1100 in the smaller hash table.
 * 如果哈希表大小调整到64个元素，新掩码将为 111111。
 * 通过将 ??1100 替换为0或1而获得的新桶只能通过我们在较小的哈希表中扫描 1100 时已经访问过的键来定位
 *
 * By iterating the higher bits first, because of the inverted counter, the
 * cursor does not need to restart if the table size gets bigger. It will
 * continue iterating using cursors without '1100' at the end, and also
 * without any other combination of the final 4 bits already explored.
 * 通过首先迭代较高的位，由于反向计数器，如果表大小变大，游标不需要重新启动。
 * 它将继续使用游标进行迭代，最后没有 1100 ，也没有最后4位的任何其他组合。
 *
 * Similarly when the table size shrinks over time, for example going from
 * 16 to 8, if a combination of the lower three bits (the mask for size 8
 * is 111) were already completely explored, it would not be visited again
 * because we are sure we tried, for example, both 0111 and 1111 (all the
 * variations of the higher bit) so we don't need to test it again.
 * 同样，当表大小随着时间的推移而缩小时，例如从16到8，如果已经完全探索了较低三位的组合（大小为8的掩码是111），则不会再次访问它，因为我们确信已经尝试过，
 * 例如 0111和1111 （较高位的所有变体），因此我们不会再尝试它
 *
 * WAIT... YOU HAVE *TWO* TABLES DURING REHASHING!
 * 等等，你有两个哈希表在重哈希
 *
 * Yes, this is true, but we always iterate the smaller table first, then
 * we test all the expansions of the current cursor into the larger
 * table. For example if the current cursor is 101 and we also have a
 * larger table of size 16, we also test (0)101 and (1)101 inside the larger
 * table. This reduces the problem back to having only one table, where
 * the larger one, if it exists, is just an expansion of the smaller one.
 * 是的，这是真的，但是我们总是先迭代较小的表，然后我们测试当前游标在较大表中的所有扩展。
 * 例如当前游标是 101 而且我们有大表的大小为16，我们在大表中验证 0101 和 1101.
 * 这将问题减少到只有一个表，其中较大的表（如果存在的话）只是较小表的扩展
 *
 *
 * LIMITATIONS
 * 限制
 *
 * This iterator is completely stateless, and this is a huge advantage,
 * including no additional memory used.
 * 这个迭代器是完全无状态的，这是一个巨大的优势，包括不使用额外的内存
 *
 * The disadvantages resulting from this design are:
 * 这种设计的缺点是
 *
 * 1) It is possible we return elements more than once. However this is usually
 *    easy to deal with in the application level.
 * 1) 我们可能多次返回相同元素。但是它通常在程序级别易于处理
 * 2) The iterator must return multiple elements per call, as it needs to always
 *    return all the keys chained in a given bucket, and all the expansions, so
 *    we are sure we don't miss keys moving during rehashing.
 * 2) 迭代器每次调用必须返回多个元素，因为它总是需要返回给定桶中链接的所有键，以及所有的展开，所以我们确保在重新散列期间不会错过键的移动
 * 3) The reverse cursor is somewhat hard to understand at first, but this
 *    comment is supposed to help.
 * 3) 反向光标一开始有点难以理解，但是这条注释应该会有所帮助
 */
unsigned long dictScan(dict *d,
                       unsigned long v, //对应的游标 从0开始
                       dictScanFunction *fn,
                       dictScanBucketFunction* bucketfn,
                       void *privdata)
{
    //初始化 表0地址和表1地址
    dictht *t0, *t1;
    //初始化当前哈希节点和下一个哈希节点
    const dictEntry *de, *next;
    //初始化 表0和表1对应的掩码
    unsigned long m0, m1;

    //如果哈希表数量为0值返回
    if (dictSize(d) == 0) return 0;

    /* This is needed in case the scan callback tries to do dictFind or alike.
     * 这在扫描回调试图执行 dictFind 或类型操作时是需要的。
     * */
    //暂停重哈希
    dictPauseRehashing(d);

    //判断哈希表是在重哈希过程中
    //若不处于重哈希过程中直接根据 v 找到需要迭代的 Bucket索引，针对该bucket中链表中的所有节点，调用用户提供的fn函数
    if (!dictIsRehashing(d)) {
        //t0 指向表
        t0 = &amp;(d-&gt;ht[0]);
        //表0对应的掩码
        m0 = t0-&gt;sizemask;

        /* Emit entries at cursor
         * 在游标处发出项
         * */
        //执行对应bucketfn方法
        if (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);
        //取哈希对应索引位置的链表节点
        de = t0-&gt;table[v &amp; m0];
        //遍历链表
        while (de) {
            //取下一个哈希节点
            next = de-&gt;next;
            //执行对应fn方法
            fn(privdata, de); //将这个链表里的数据全部入队，准备返回客户端
            //指向下一个哈希节点
            de = next;
        }

        /* Set unmasked bits so incrementing the reversed cursor
         * operates on the masked bits
         * 设置非掩码位，以增加反向游标对掩码位的操作
         * */
        //用于保留 v 的低n位数，其余位全置位1
        v |= ~m0;

        /* Increment the reverse cursor
         * 增加反向光标
         * */
        //主要作用就是游标高位+1
        //游标倒置，将v的二进制位进行翻转，所以，v的低n位数成了高n位数，并且进行翻转
        v = rev(v);
        //游标加1，低位加1
        v++;
        //游标继续倒置，导致高位加1
        v = rev(v);

    } else {
        //表0的位置
        t0 = &amp;d-&gt;ht[0];
        //表1的位置
        t1 = &amp;d-&gt;ht[1];

        /* Make sure t0 is the smaller and t1 is the bigger table
         * 保证 t0 的数量小于 t1 的数量
         * */
        //保证t0数量最小，为后续遍历做准备，若t0大于t1，会导致部分数据漏掉
        if (t0-&gt;size &gt; t1-&gt;size) {
            t0 = &amp;d-&gt;ht[1];
            t1 = &amp;d-&gt;ht[0];
        }

        //表0 对应的掩码
        m0 = t0-&gt;sizemask;
        //表1 对应的掩码
        m1 = t1-&gt;sizemask;

        /* Emit entries at cursor */
        if (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);
        //取哈希对应索引位置的链表节点
        de = t0-&gt;table[v &amp; m0];
        //遍历链表 同上
        while (de) {
            //取下一个哈希节点
            next = de-&gt;next;
            //执行对应fn方法
            fn(privdata, de);
            //指向下一个哈希节点
            de = next;
        }

        /* Iterate over indices in larger table that are the expansion
         * of the index pointed to by the cursor in the smaller table
         * 迭代较大表中的索引，这些索引是游标在较小表中所指向的索引的扩展
         * */
        //同遍历表0
        do {
            /* Emit entries at cursor */
            if (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);
            de = t1-&gt;table[v &amp; m1];
            while (de) {
                next = de-&gt;next;
                fn(privdata, de);
                de = next;
            }

            /* Increment the reverse cursor not covered by the smaller mask.*/
            v |= ~m1;
            v = rev(v);
            v++;
            v = rev(v);

            /* Continue while bits covered by mask difference is non-zero
             * 当掩码差所覆盖的位不为零时继续执行
             * */
        } while (v &amp; (m0 ^ m1)); //表示直到 v 的低m1-m0位 到 低m1位（指 v 的高位都没有1） 之间全为0为止
    }

    //释放重哈希标志
    dictResumeRehashing(d);

    return v;
}


/* Function to reverse bits. Algorithm from:
 * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel 
 * 二进制反转  即 0000 0111  -&gt;  1110 0000
 * */
static unsigned long rev(unsigned long v) {
    unsigned long s = CHAR_BIT * sizeof(v); // bit size; must be power of 2
    unsigned long mask = ~0UL;
    while ((s &gt;&gt;= 1) &gt; 0) {
        mask ^= (mask &lt;&lt; s);
        v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);
    }
    return v;
}
</code></pre>

<blockquote>
  <p>相关参考：
https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html#%E5%AD%97%E5%85%B8-%E5%93%88%E5%B8%8C%E8%A1%A8-dict<br />
https://juejin.cn/post/7096097985976598564<br />
https://zhuanlan.zhihu.com/p/332480573<br />
https://www.cnblogs.com/yinbiao/p/10766357.html<br />
https://www.cnblogs.com/bhlsheji/p/5134465.html<br />
https://www.cnblogs.com/chenchuxin/p/14191156.html#%E5%93%88%E5%B8%8C%E8%A1%A8<br />
https://juejin.cn/post/7189826507110350904<br />
https://juejin.cn/post/7065498940883337253<br />
https://blog.csdn.net/yangbodong22011/article/details/78467583<br />
https://juejin.cn/post/6844903688528461831<br />
https://www.cnblogs.com/gqtcgq/p/7247075.html<br />
http://chenzhenianqing.com/articles/1101.html<br />
https://blog.csdn.net/damanchen/article/details/89468810<br />
https://www.lixueduan.com/posts/redis/redis-scan/</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">Nov 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">redis</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-30000005" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>快表</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-mutecevvil-28871575.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>quickList</h3>
                            
                            </div>

                            <p><h3 id="快表---quicklist">快表 - quicklist</h3>

<hr />

<p>quicklist 是一个 3.2 版本之后新增的基础数据结构，是 redis 自定义的一种复杂数据结构，将 ziplist 和 adlist 结合到一个数据结构中。主要是作为 list 的基础数据结构。<br />
在 3.2 之前，list 是根据元素数量的多少采用 ziplist 或者 adlist 作为基础数据结构， 3.2 之后统一改用 quicklist，从数据结构的角度来说， quicklist 结合了两种数据结构的优缺点，复杂但是实用:</p>
<ul>
  <li>链表在插入，删除节点的时间复杂度很低；但是内存利用率低，且由于内存不连续容易产生内存碎片</li>
  <li>压缩表内存连续，存储效率高；但是插入和删除的成本太高，需要频繁的进行数据搬移、释放或申请内存<br />
而 quicklist 通过将每个压缩列表用双向链表的方式连接起来，来寻求一种收益最大化。</li>
</ul>

<p><strong>redislist数据结构特点</strong></p>
<ul>
  <li>表 list 是一个能维持数据项先后顺序的双向链表</li>
  <li>在表 list 的两端追加和删除数据极为方便，时间复杂度为 O(1)</li>
  <li>表 list 也支持在任意中间位置的存取操作，时间复杂度为 O(N)</li>
  <li>表 list 经常被用作队列使用</li>
</ul>

<h3 id="数据结构">数据结构</h3>

<hr />

<p>内部分布图:</p>
<center>   
<img src="../../img/redis/quicklist/redis_quicklist_structure.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">quicklist内存分布图</div>
</center>

<p>需要注意的几点:</p>
<ul>
  <li>两端各有 2 个橙黄色的节点，是没有被压缩的。它们的数据指针 zl 指向真正的 ziplist。中间的其他节点是被压缩过的，它们的数据指针 zl 指向被压缩后的 ziplist 结构，即一个 quicklistLZF 结构。</li>
  <li>左侧头结点上的 ziplist 里有 2 项数据，右侧尾节点上的 ziplist 里有 1 项数据，中间其他节点上的 ziplist 里都有 3 项数据（包括压缩的节点内部）。这表示在表的两端执行过多次 push和pop 操作后的一个状态。</li>
</ul>

<p>首先是 quicklist 的节点 quicklistNode ，源码如下:</p>
<pre><code class="language-C++">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.
 * We use bit fields keep the quicklistNode at 32 bytes.
 * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).
 * encoding: 2 bits, RAW=1, LZF=2.
 * container: 2 bits, NONE=1, ZIPLIST=2.
 * recompress: 1 bit, bool, true if node is temporary decompressed for usage.
 * attempted_compress: 1 bit, boolean, used for verifying during testing.
 * extra: 10 bits, free for future use; pads out the remainder of 32 bits
 *
 * quicklistNode 是一个32字节的结构体，描述quickList的压缩列表。
 * 我们使用位字段将 quicklistNode 控制在 32 字节
 * count: 16位，最大 65536 （最终字节数为 65k，所以最大计数实际小于 32k）
 * encoding: 2位， 原始为1，使用LZF压缩算法为 2
 * container: 2位， 每个链表节点所持有的数据类型是什么，默认的实现是 ziplist，对应的值为2
 * quicklistNode: 1位，如果节点临时解压缩以供使用，则为true
 * attempted_compress: 1位，用于测试时的验证
 * extra:10位，免费供将来使用，补出32位的剩余部分
 *
 * */
typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *zl;
    unsigned int sz;             /* ziplist size in bytes */
    unsigned int count : 16;     /* count of items in ziplist */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can't compress; too small */
    unsigned int extra : 10; /* more bits to steal for future usage */
} quicklistNode;

/* quicklistLZF is a 4+N byte struct holding 'sz' followed by 'compressed'.
 * 'sz' is byte length of 'compressed' field.
 * 'compressed' is LZF data with total (compressed) length 'sz'
 * NOTE: uncompressed length is stored in quicklistNode-&gt;sz.
 * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF
 * quicklistLZF 是一个 4+N 字节的结构体，包含 sz 后面跟着 compressed。
 * sz 是 compressed 字段的长度。
 * compressed 是总长度为 sz 的LZF数据
 * 请注意：非压缩的长度存储在 quicklistNode 的 sz 字段中。
 * 当 quicklistNode 的 zl 是压缩的， 节点的 zl 字段指向 quicklistLZF
 * */
typedef struct quicklistLZF {
    unsigned int sz; /* LZF size in bytes*/
    char compressed[];
} quicklistLZF;

/* Bookmarks are padded with realloc at the end of of the quicklist struct.
 * They should only be used for very big lists if thousands of nodes were the
 * excess memory usage is negligible, and there's a real need to iterate on them
 * in portions.
 * When not used, they don't add any memory overhead, but when used and then
 * deleted, some overhead remains (to avoid resonance).
 * The number of bookmarks used should be kept to minimum since it also adds
 * overhead on node deletion (searching for a bookmark to update).
 * 书签在快速列表结构体的末尾使用 realloc 填充。
 * 它们只应该用于非常大的列表，如果有数千个节点，多余的内存使用可以忽略不计，并且确实需要对它们就行部分迭代。
 * 当不使用它们时，它们不会增加任何内存开销，但是当使用并删除它们时，会保留一些开心。
 * 使用的书签数量应该保持在最低限度，因为它也会增加删除节点时的开销。
 * */
typedef struct quicklistBookmark {
    quicklistNode *node;
    char *name;
} quicklistBookmark;
</code></pre>
<p>quicklistNode 实际上就是对 ziplist 的进一步封装，其中包括:</p>
<ul>
  <li>prev:指向链表前一个节点的指针</li>
  <li>next:指向链表后一个节点的指针</li>
  <li>zl:数据指针，如果当前节点的数据没有压缩，那么它指向一个 ziplist 结构；否则，它指向一个 quicklistLZF 结构</li>
  <li>sz:表示 zl 指向的 ziplist 的总大小（包括 zlbytes、zltail、zllen、zlend和各个数据项）。需要注意的是：如果 ziplist 被压缩了，那么这个 sz 的值仍然是压缩前的 ziplist 大小。</li>
  <li>count:表示 ziplist 里面包含的数据项个数，这个字段只有 16bit。</li>
  <li>encoding:表示 ziplist 是否压缩了以及用了哪个压缩算法。目前只有两种取值：2 表示被压缩了（而且用的是 LZF压缩算法），1 表示没有压缩</li>
  <li>container:是一个预留字段。本来设计是用来表明一个 quicklist 节点下面是直接存数据，还是使用 ziplist 存数据，或者用其他的数据结构来存数据。但是，在目前的实现中，这个值是一个固定的值 2，表示使用 ziplist 作为数据容器</li>
  <li>recompress:当我们使用类似 lindex 这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置 recompress=1 做一个标记，等有机会再把数据重新压缩</li>
  <li>attempted_compress:这个值只对 Redis 的自动化测试程序有用。不用管它</li>
  <li>extra:其他扩展字段，目前也没用上</li>
</ul>

<p>这里从变量 count 开始，都采用了位域的方式进行数据的内存声明，使用 6 个 unsigned int 变量只用到了一个 unsigned int 的内存大小。<br />
C语言支持位域的方式对结构体中的数据进行声明，也就是可以指定一个类型占用几位:</p>
<ol>
  <li>如果相邻位域字段的类型相同，且其位宽之和小于类型的 sizeof 大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li>
  <li>如果相邻位域字段的类型相同，且其位宽之和大于类型的 sizeof 大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍</li>
  <li>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++ 采取压缩方式</li>
  <li>如果位域字段之间穿插着非位域字段，则不进行压缩</li>
  <li>整个结构体的总大小为最宽基本类型成员大小的整数倍<br />
sizeof(quicklistNode): //output:32，通过位域的声明方式，quicklistNode 可以节省 24 个字节</li>
</ol>

<p>quicklistLZF 结构表示一个被压缩过的 ziplist。其中：</p>
<ul>
  <li>sz:表示压缩后的 ziplist 大小</li>
  <li>compressed: 是个柔性数组，存放压缩后的 ziplist字节数组</li>
</ul>

<p>通过 quicklist 将 quicklistNode 连接起来就是一个完整的数据结构。源码如下:</p>
<pre><code class="language-C++">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
 * 'count' is the number of total entries.
 * 'len' is the number of quicklist nodes.
 * 'compress' is: 0 if compression disabled, otherwise it's the number
 *                of quicklistNodes to leave uncompressed at ends of quicklist.
 * 'fill' is the user-requested (or default) fill factor.
 * 'bookmakrs are an optional feature that is used by realloc this struct,
 *      so that they don't consume memory when not used.
 *  quicklist 是一个 40 字节的结构体，描述一个快速列表
 *  count: 表示 ziplist 节点的总数量
 *  len: 表示 quicklist 节点的总数量
 *  compress: 如果关闭压缩则为0， 否则用来表示在 quicklist 的末尾保留未压缩的 quicklistNode 的数量  对应配置:list-compress-depth
 *  0-是个特殊值，表示不压缩。是Redis的默认值
 *  1-表示quicklist两端各有 1 个节点不压缩，中间的节点压缩
 *  2-表示quicklist两端各有 2 个节点不压缩，中间的节点压缩
 *  3-表示quicklist两端各有 3 个节点不压缩，中间的节点压缩
 *  以此类推
 *
 *  fill: ziplist 的大小设置  对应配置:list-max-ziplist-size
 *  当取正值的时候，表示按照数据项个数来限定每个 quicklist 节点上的 ziplist 长度。比如，当这个参数设置成 5 时，表示每个 quicklist 节点的 ziplist 最多包含 5 个数据项
 *  当取负值的时候，表示按照占用字节数来限定每个 quicklist 节点上的 ziplist 长度。这时，它只能取 -1 到 -5 这五个值，每个值含义如下：
 *  -1:每个 quicklist 节点上的 ziplist 大小不能超过 4kb
 *  -2:每个 quicklist 节点上的 ziplist 大小不能超过 8kb (Redis 给的默认值)
 *  -3:每个 quicklist 节点上的 ziplist 大小不能超过 16kb
 *  -4:每个 quicklist 节点上的 ziplist 大小不能超过 32kb
 *  -5:每个 quicklist 节点上的 ziplist 大小不能超过 64kb
 *  bookmakrs: 是 realloc 这个结构体使用的一个可选特性，这样他们在不使用时就不会消耗内存
 *      */
typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all ziplists */
    unsigned long len;          /* number of quicklistNodes */
    int fill : QL_FILL_BITS;              /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
} quicklist;
</code></pre>
<ul>
  <li>head:指向头节点（左侧第一个节点）的指针</li>
  <li>tail:指向尾节点（右侧第一个节点）的指针</li>
  <li>count:所有 ziplist 数据项的个数总和</li>
  <li>len:quicklist 节点的个数</li>
  <li>fill:16bit，ziplist 大小设置，默认为 -2，存放 list-max-ziplist-size 参数的值<br />
list-max-ziplist-size 数值含义:
    <ul>
      <li>-1:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 4kb （建议配置）</li>
      <li>-2:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 8kb （默认配置）</li>
      <li>-3:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 16kb</li>
      <li>-4:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 32kb</li>
      <li>-5:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 64kb</li>
      <li>任意正数:表示 ziplist 结构最多包含的 entry 个数，最大为 215215</li>
    </ul>
  </li>
</ul>

<p>list-max-ziplist-size 配置产生产生的原因?<br />
每个 quicklist 节点上的 ziplist 越短，则内存碎片越多。内存碎片多了，有可能在内存中产品很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个 quicklist 节点上的 ziplist 只包含一个数据项，这就退变成一个普通的双向链表。<br />
每个 quicklist 节点上的 ziplist 越长，则为 ziplist 分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间，但却找不到一块足够大的空闲空间分配给 ziplist 的情况。这同样会降低存储效率。这种情况的极端是整个 quicklist 只有一个节点，所有的数据项都分配在这仅有的一个节点的 ziplist 里面，这其实就退化成一个 ziplist 了。<br />
可见，一个 quicklist 节点上的 ziplist 要保持一个合理的长度。那么到底多长合理呢？Redis 提供了一个配置参数 list-max-ziplist-size ，就是为了让使用者可以来根据实际应用场景进行调整优化。</p>

<ul>
  <li>compress:16bit，节点压缩深度设置，存放 list-compress-depth 参数的值<br />
list-compress-depth:这个参数表示一个 quicklist 两端不被压缩的节点个数。注意:这里的节点个数是指 quicklist 双向链表的节点个数，而不是指 ziplist 里面的数据项个数。实际上，一个 quicklist 节点上的 ziplist，如果被压缩，就是整体被压缩的。<br />
list-compress-depth取值含义如下：
    <ul>
      <li>0:是个特殊值，表示都不压缩，是默认值</li>
      <li>1:表示 quicklist 两端各有 1 个节点不压缩，中间的节点压缩</li>
      <li>2:表示 quicklist 两端各有 2 个节点不压缩，中间的节点压缩</li>
      <li>3:表示 quicklist 两端各有 3 个节点不压缩，中间的节点压缩</li>
      <li>以此类推</li>
    </ul>
  </li>
</ul>

<p>list-compress-depth 配置产生原因？<br />
当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率较低。如果应用场景符合这个特点，那么 list 还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。</p>

<p><strong>数据压缩</strong></p>

<hr />

<p>quicklist 每个节点的实际数据存储结构为 ziplist，这种结构的主要优势在于节省存储空间。<br />
为了进一步降低 ziplist 所占用的空间，Redis 允许对 ziplist 进一步压缩，Redis 采用的压缩算法是 LZF，压缩过后的数据可以分成多个片段，每个片段有 2 部分：</p>
<ul>
  <li>一部分是解释字段，另一部分是存放具体的数据字段</li>
  <li>解释字段可以占用 1~3 个字节，数据字段可能不存在</li>
</ul>

<p>示例:</p>
<blockquote>
  <p>解释字段|数据|……|解释字段|数据</p>
</blockquote>

<p>LZF 压缩的数据格式有 3 种，即解释字段有 3 种:</p>
<ul>
  <li>000LLLLL:字面型，解释字段占用 1 个字节，数据字段长度由解释字段后 5 位决定；L 是数据长度字段，数据长度是长度字段组成的字面值加 1。例如：0000 0001 代表数据长度为 2</li>
  <li>LLLooooo oooooooo:简短重复型，解释字段占用 2 个字节，没有数据字段，数据内容与前面数据内容重复，重复长度小于 8；L 是长度字段，数据长度为长度字段的字面值加 2, o 是偏移量字段，位置偏移量是偏移字段组成的字面值加 1。例如： 0010 0000 0000 0100 代表与前面 5 字节处内容重复，重复 3 字节</li>
  <li>111ooooo LLLLLLLL oooooooo:批量重复型，解释字段占 3 个字节，没有数据字段，数据内容与前面内容重复；L 是长度字段，数据长度为长度字段的字面值加 9，o 是偏移量字段，位置偏移量是偏移字段组成的字面值加 1。例如：1110 0000 0000 0010 0001 0000 代表与前面 17 字节处内容重复，重复 11 个字节</li>
</ul>

<p>quicklistLZF结构:</p>
<pre><code class="language-C++">/* quicklistLZF is a 4+N byte struct holding 'sz' followed by 'compressed'.
 * 'sz' is byte length of 'compressed' field.
 * 'compressed' is LZF data with total (compressed) length 'sz'
 * NOTE: uncompressed length is stored in quicklistNode-&gt;sz.
 * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF
 * quicklistLZF 是一个 4+N 字节的结构体，包含 sz 后面跟着 compressed。
 * sz 是 compressed 字段的长度。
 * compressed 是总长度为 sz 的LZF数据
 * 请注意：非压缩的长度存储在 quicklistNode 的 sz 字段中。
 * 当 quicklistNode 的 zl 是压缩的， 节点的 zl 字段指向 quicklistLZF
 * */
typedef struct quicklistLZF {
    unsigned int sz; /* LZF size in bytes*/
    char compressed[];
} quicklistLZF;
</code></pre>
<ul>
  <li>sz:表示该压缩节点的总长度</li>
  <li>compressed:压缩后的数据片段（多个），每个数据片段由解释字段和数据字段组成</li>
  <li>当前 ziplist 未压缩长度存在于 quicklistNode -&gt; sz 字段中</li>
  <li>当 ziplist 被压缩后，node -&gt; zl字段将指向 quicklistLZF</li>
</ul>

<p>压缩<br />
LZF 数据压缩的基本思想是: 数据与前面重复的，记录重复位置以及重复长度，否则直接记录原始数据内容。<br />
压缩算法的流程如下: 遍历输入字符串，对当前字符及后面 2 个字符进行散列运算，如果在 Hash 表中找到曾经出现的记录，则计算重复字节的长度以及位置，反之直接输出数据。</p>
<pre><code class="language-CPP">/*
 * compressed format
 *
 * 000LLLLL &lt;L+1&gt;    ; literal, L+1=1..33 octets
 * LLLooooo oooooooo ; backref L+1=1..7 octets, o+1=1..4096 offset
 * 111ooooo LLLLLLLL oooooooo ; backref L+8 octets, o+1=1..4096 offset
 */
unsigned int
lzf_compress (const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)
</code></pre>

<p>解压缩<br />
根据 LZF 压缩后的数据格式，可以较为容易地实现 LZF 的解压缩。需要注意的是，可能存在重复数据与当前位置重叠的情况，例如在当前位置前的 15 个字节处，重复了 20 个字节，此时需要按位逐个复制。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">lzf_decompress</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="k">const</span> <span class="n">in_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">out_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out_len</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="源码解析">源码解析</h3>

<hr />

<p><em>创建节点</em></p>
<pre><code class="language-CPP">/* Create a new quicklist.
 * Free with quicklistRelease().
 * 创建一个快速列表
 * 通过quicklistRelease 释放
 * */
quicklist *quicklistCreate(void) {
    struct quicklist *quicklist;

    //分配内存
    quicklist = zmalloc(sizeof(*quicklist));
    //初始化头尾节点为null
    quicklist-&gt;head = quicklist-&gt;tail = NULL;
    //初始化快表节点的长度
    quicklist-&gt;len = 0;
    //初始化压缩列表的长度
    quicklist-&gt;count = 0;
    //初始化压缩的标识
    quicklist-&gt;compress = 0;
    //初始化 压缩列表的大小设置为-2
    quicklist-&gt;fill = -2;
    quicklist-&gt;bookmark_count = 0;
    return quicklist;
}
</code></pre>
<p>初始化快表，各个字段初始化默认值，fill 默认为 -2，也就是说每个 quicklistNode 中的 ziplist 最长是 8k 字节。</p>

<p><em>节点插入</em></p>

<p>插入流程图：</p>
<center>   
<img src="../../img/redis/quicklist/quicklistPush.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">quicklistPush</div>
</center>

<p>源码如下：</p>
<pre><code class="language-CPP">/* Wrapper to allow argument-based switching between HEAD/TAIL pop
 * 包装器允许在 头部和尾部 pop 之间基于参数的切换
 * */
void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
                   int where) {
    //若当前位置是头部 则在头部插入
    if (where == QUICKLIST_HEAD) {
        quicklistPushHead(quicklist, value, sz);
    } else if (where == QUICKLIST_TAIL) {//若当前位置是尾部 则在尾部插入
        quicklistPushTail(quicklist, value, sz);
    }
}

/* Add new entry to head node of quicklist.
 * 在快表的头部新增节点
 *
 * Returns 0 if used existing head.
 * Returns 1 if new head created.
 * 如果使用已存在的头部则返回0，如果创建新头部则返回1
 * */
int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    //定义原始快表头部
    quicklistNode *orig_head = quicklist-&gt;head;
    assert(sz &lt; UINT32_MAX); /* TODO: add support for quicklist nodes that are sds encoded (not zipped) */
    //检查头部是否能够允许插入新元素
    if (likely(
            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) {
        //将新元素插入到 压缩列表头部
        quicklist-&gt;head-&gt;zl =
            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);
        //更新压缩列表大小
        quicklistNodeUpdateSz(quicklist-&gt;head);
    } else {//若原头部没有空间插入则新建节点插入在头部
        //新建快表节点
        quicklistNode *node = quicklistCreateNode();
        //为 node 初始化压缩列表，同时将新节点插入压缩列表头部
        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
        //更新压缩长度
        quicklistNodeUpdateSz(node);
        //将新节点插入到快表头部
        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);
    }
    //节点计数+1
    quicklist-&gt;count++;
    quicklist-&gt;head-&gt;count++;
    return (orig_head != quicklist-&gt;head);
}

/* Add new entry to tail node of quicklist.
 * 同插入头部
 * Returns 0 if used existing tail.
 * Returns 1 if new tail created. */
int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_tail = quicklist-&gt;tail;
    assert(sz &lt; UINT32_MAX); /* TODO: add support for quicklist nodes that are sds encoded (not zipped) */
    if (likely(
            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) {
        quicklist-&gt;tail-&gt;zl =
            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);
        quicklistNodeUpdateSz(quicklist-&gt;tail);
    } else {
        quicklistNode *node = quicklistCreateNode();
        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);
    }
    quicklist-&gt;count++;
    quicklist-&gt;tail-&gt;count++;
    return (orig_tail != quicklist-&gt;tail);
}

/**
 * 检查插入位置的 ziplist 是否能容纳该元素
 * 计算新插入元素的大小（new_sz），这个大小等于 quicklistNode 的当前大小（node-&gt;sz）、插入元素的大小（）
 */
REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
                                           const int fill, const size_t sz) {
    if (unlikely(!node))
        return 0;

    int ziplist_overhead;
    /* size of previous offset
     * 计算下一个节点的 prev 的偏移量大小
     * */
    if (sz &lt; 254) //小于254时 后一个节点的 pre 只有 1字节，否则为 5字节
        ziplist_overhead = 1;
    else
        ziplist_overhead = 5;

    /* size of forward offset
     * 计算下一个节点的 encoding 大小
     * */
    if (sz &lt; 64) //若小于 64 字节当前节点的 encoding 为 1字节
        ziplist_overhead += 1;
    else if (likely(sz &lt; 16384)) //若小于 16384 encoding 为 2字节
        ziplist_overhead += 2;
    else
        ziplist_overhead += 5; //其余情况都为 5 字节

    /* new_sz overestimates if 'sz' encodes to an integer type
     * new_sz 高估了 sz 可以被编码整数类型的场景
     * */
    //计算新 sz 的值，原sz + 新sz + 新增偏移量大小   忽略连锁更新的情况
    unsigned int new_sz = node-&gt;sz + sz + ziplist_overhead;
    //检查 fill 为负数是否超过单存储限制，不超过直接返回1
    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))
        return 1;
    /* when we return 1 above we know that the limit is a size limit (which is
     * safe, see comments next to optimization_level and SIZE_SAFETY_LIMIT)
     * 当我们返回上面的 1 时，我们知道限制是一个大小限制
     * */
    //校验单个节点是否超过 8 kb，主要防止fill为正数时单个节点内存过大
    else if (!sizeMeetsSafetyLimit(new_sz))
        return 0;
    //fill 为正数 是否超过存储限制
    else if ((int)node-&gt;count &lt; fill)
        return 1;
    else
        return 0;
}


unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
    unsigned char *p;
    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
    //压缩列表插入
    return __ziplistInsert(zl,p,s,slen);
}


/* Wrappers for node inserting around existing node. */
REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
                                             quicklistNode *old_node,
                                             quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 0);
}

REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
                                            quicklistNode *old_node,
                                            quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 1);
}


/* Insert 'new_node' after 'old_node' if 'after' is 1.
 * Insert 'new_node' before 'old_node' if 'after' is 0.
 * Note: 'new_node' is *always* uncompressed, so if we assign it to
 *       head or tail, we do not need to uncompress it.
 * 如果 after=1 将 new_node 插入到 old_node 之后。
 * 如果 after=0 将 new_node 插入到 old_node 之前。
 * 注意：new_node 总是未压缩的，所以当我们将它设置到头部或者末尾时不需要解压缩他们
 *       */
REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
                                        quicklistNode *old_node,
                                        quicklistNode *new_node, int after) {
    //若 after=1，则将新节点插入到旧节点之后
    if (after) {
        //将新节点的 prev 指针指向旧节点
        new_node-&gt;prev = old_node;
        //若存在旧节点
        if (old_node) {
            //将 old_node 的 next 指针赋值给 new_node 的 next，即将新节点的下一个节点指向原来的下一个
            new_node-&gt;next = old_node-&gt;next;
            //若旧节点存在下一个节点
            if (old_node-&gt;next)
                //将旧节点的下一个节点的上一个节点指针指向新节点
                old_node-&gt;next-&gt;prev = new_node;
            //旧节点的下一个节点指针指向新节点
            old_node-&gt;next = new_node;
        }
        //快表最后一个节点为旧节点
        if (quicklist-&gt;tail == old_node)
            //更新结尾节点为新节点
            quicklist-&gt;tail = new_node;
    } else {//其他情况将新节点插入到旧节点之前
        //新节点的下一个节点指向到旧节点
        new_node-&gt;next = old_node;
        //如果存在旧节点
        if (old_node) {
            //将新节点的上一个节点指针指向旧节点的上一个节点指针
            new_node-&gt;prev = old_node-&gt;prev;
            //如果存在旧节点的上一个节点
            if (old_node-&gt;prev)
                //将上一个节点的下一个节点指针指向新节点
                old_node-&gt;prev-&gt;next = new_node;
            //将旧节点的上一个节点指针指向新节点
            old_node-&gt;prev = new_node;
        }
        //如果快表的头结点为旧节点
        if (quicklist-&gt;head == old_node)
            //更新头结点为新节点
            quicklist-&gt;head = new_node;
    }
    /* If this insert creates the only element so far, initialize head/tail.
     * 如果插入导致创建了只有一个元素，则初始化头结点和尾节点
     * */
    if (quicklist-&gt;len == 0) {
        quicklist-&gt;head = quicklist-&gt;tail = new_node;
    }

    /* Update len first, so in __quicklistCompress we know exactly len
     * 首先更新长度，所以在 __quicklistCompress 中我们知道长度
     * */
    quicklist-&gt;len++;

    //如果存在旧节点
    if (old_node)
        //尝试将旧节点压缩
        quicklistCompress(quicklist, old_node);
}
</code></pre>
<p>对于 list 而言，头部或者尾部插入是最简单的。<br />
头插和尾插方法调用过程相似，一个处理 head 节点，一个处理 tail 节点。方法内部都调用了 _quicklistNodeAllowInsert 先判断了是否能直接在当前头尾节点插入，如果能就直接插入到对应的 ziplist 里，否则就需要新建一个新节点再操作。  _quicklistNodeAllowInsert 其实就是根据 fill 的值来判断是否已经超过最大容量。</p>
<ul>
  <li>如果现有头部大小允许插入新节点，则直接插入到压缩列表中并更新压缩列表大小</li>
  <li>如果现有头部大小不允许插入新节点，则新建头部为待插入的节点的压缩列表并将其指向新增的快表节点 quicklistNode 的属性 zl，更新压缩列表大小，最后将新快表节点插入到原快表头部</li>
</ul>

<p><em>特定位置插入</em>
头插尾插比较简单，但 quicklist 在非头尾插入就比较繁琐了，因为要考虑到插入位置、前后节点的存储情况。</p>

<p>特定位置插入流程图如下：</p>
<center>   
<img src="../../img/redis/quicklist/quicklistInsert.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">quicklistInsert</div>
</center>

<p>源码如下:</p>
<pre><code class="language-CPP">/* Insert a new entry before or after existing entry 'entry'.
 * 在已有节点 entry 之前或之后插入一个新节点。
 *
 * If after==1, the new value is inserted after 'entry', otherwise
 * the new value is inserted before 'entry'.
 * 如果 after=1，新值插入在 entry 之后，否则新值插入在 entry 之前
 * */
REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,
                                   void *value, const size_t sz, int after) {
    int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;
    int fill = quicklist-&gt;fill;
    quicklistNode *node = entry-&gt;node;
    quicklistNode *new_node = NULL;
    assert(sz &lt; UINT32_MAX); /* TODO: add support for quicklist nodes that are sds encoded (not zipped) */

    //如果不存在已有节点，则直接新建节点插入
    if (!node) {
        /* we have no reference node, so let's create only node in the list
         * 没有参考节点，所以直接在列表中创建新节点
         * */
        D("No node given!");
        //创建新快表节点
        new_node = quicklistCreateNode();
        //创建压缩列表节点
        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
        //向 quicklist 中插入新节点
        __quicklistInsertNode(quicklist, NULL, new_node, after);
        //节点计数加1
        new_node-&gt;count++;
        quicklist-&gt;count++;
        return;
    }

    /* Populate accounting flags for easier boolean checks later
     * 填充记账标志，以便以后更容易地进行布尔检查
     * */
    //检查要插入的节点是否是满的，若已满 full设置为1，未满则为默认0
    if (!_quicklistNodeAllowInsert(node, fill, sz)) {
        D("Current node is full with count %d with requested fill %lu",
          node-&gt;count, fill);
        full = 1;
    }

    //检查要插入的节点是否在当前ziplist尾部  after == 1 且 当前偏移量等于节点数量
    if (after &amp;&amp; (entry-&gt;offset == node-&gt;count)) {
        D("At Tail of current ziplist");
        at_tail = 1;
        //检查下一个节点是否已满
        if (!_quicklistNodeAllowInsert(node-&gt;next, fill, sz)) {
            D("Next node is full too.");
            full_next = 1;
        }
    }

    //检查要插入的节点是否在头部 after==0 且 当前偏移量==0
    if (!after &amp;&amp; (entry-&gt;offset == 0)) {
        D("At Head");
        at_head = 1;
        //检查上一个节点是否已满
        if (!_quicklistNodeAllowInsert(node-&gt;prev, fill, sz)) {
            D("Prev node is full too.");
            full_prev = 1;
        }
    }

    /* Now determine where and how to insert the new element
     * 现在确定在哪里以及如何插入新元素
     * */
    //当前节点未满 且 在 entry 之后插入
    if (!full &amp;&amp; after) {
        D("Not full, inserting after current position.");
        //将已压缩节点解压
        quicklistDecompressNodeForUse(node);
        //取下一个节点，若在末尾节点则返回 null
        unsigned char *next = ziplistNext(node-&gt;zl, entry-&gt;zi);
        //若next 为 null，即代表往末尾插入，直接调用 ziplistPush 方法向末尾插入
        if (next == NULL) {
            node-&gt;zl = ziplistPush(node-&gt;zl, value, sz, ZIPLIST_TAIL);
        } else {
            //若不为null，则走插入逻辑，插入在 next 节点之后
            node-&gt;zl = ziplistInsert(node-&gt;zl, next, value, sz);
        }
        //节点计数加 1
        node-&gt;count++;
        //更新 sz 属性
        quicklistNodeUpdateSz(node);
        //重新压缩节点
        quicklistRecompressOnly(quicklist, node);
    } else if (!full &amp;&amp; !after) { //当前节点未满 且 在 entry 之前插入
        D("Not full, inserting before current position.");
        //将已压缩节点解压
        quicklistDecompressNodeForUse(node);
        //直接在当前节点之前插入新增节点
        node-&gt;zl = ziplistInsert(node-&gt;zl, entry-&gt;zi, value, sz);
        //同上
        node-&gt;count++;
        quicklistNodeUpdateSz(node);
        quicklistRecompressOnly(quicklist, node);
    } else if (full &amp;&amp; at_tail &amp;&amp; node-&gt;next &amp;&amp; !full_next &amp;&amp; after) {
        /* If we are: at tail, next has free space, and inserting after:
         *   - insert entry at head of next node.
         *   如果当前节点是满的，要插入的位置是当前节点的尾部，且下一个节点还有空间，那就插入到下一个节点的头部
         *   */
        D("Full and tail, but next isn't full; inserting next node head");
        new_node = node-&gt;next;
        quicklistDecompressNodeForUse(new_node);
        //在下一个节点的头部插入
        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_HEAD);
        new_node-&gt;count++;
        quicklistNodeUpdateSz(new_node);
        quicklistRecompressOnly(quicklist, new_node);
    } else if (full &amp;&amp; at_head &amp;&amp; node-&gt;prev &amp;&amp; !full_prev &amp;&amp; !after) {
        /* If we are: at head, previous has free space, and inserting before:
         *   - insert entry at tail of previous node.
         *   如果当前节点是满的，要插入的位置是当前节点的头部，且头一个节点还有空间，那就插入到前一个节点的尾部
         *   */
        D("Full and head, but prev isn't full, inserting prev node tail");
        new_node = node-&gt;prev;
        quicklistDecompressNodeForUse(new_node);
        //插入到前一个节点的尾部
        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_TAIL);
        new_node-&gt;count++;
        quicklistNodeUpdateSz(new_node);
        quicklistRecompressOnly(quicklist, new_node);
    } else if (full &amp;&amp; ((at_tail &amp;&amp; node-&gt;next &amp;&amp; full_next &amp;&amp; after) ||
                        (at_head &amp;&amp; node-&gt;prev &amp;&amp; full_prev &amp;&amp; !after))) {
        /* If we are: full, and our prev/next is full, then:
         *   - create new node and attach to quicklist
         * 如果当前节点是满的，前后节点也是满的，那就创建一个新的节点进入
         *   */
        D("\tprovisioning new node...");
        //新建一个节点
        new_node = quicklistCreateNode();
        //更新新节点 zl 信息
        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
        new_node-&gt;count++;
        quicklistNodeUpdateSz(new_node);
        //将新节点插入到旧节点之后
        __quicklistInsertNode(quicklist, node, new_node, after);
    } else if (full) {
        /* else, node is full we need to split it. */
        /* covers both after and !after cases
         * 否则，节点是满的，我们需要把它分裂成两个新节点，覆盖插入之前和之后两种情况，一般用于插入到当前节点 ziplist 中间某个位置时
         * */
        D("\tsplitting node...");
        quicklistDecompressNodeForUse(node);
        //按照 after 将节点拆分
        new_node = _quicklistSplitNode(node, entry-&gt;offset, after);
        //将新节点插入到刚创建的节点中
        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz,
                                   after ? ZIPLIST_HEAD : ZIPLIST_TAIL);
        new_node-&gt;count++;
        quicklistNodeUpdateSz(new_node);
        __quicklistInsertNode(quicklist, node, new_node, after);
        //旧节点合并
        _quicklistMergeNodes(quicklist, node);
    }

    quicklist-&gt;count++;
}


/* Insert 'new_node' after 'old_node' if 'after' is 1.
 * Insert 'new_node' before 'old_node' if 'after' is 0.
 * Note: 'new_node' is *always* uncompressed, so if we assign it to
 *       head or tail, we do not need to uncompress it.
 * 如果 after=1 将 new_node 插入到 old_node 之后。
 * 如果 after=0 将 new_node 插入到 old_node 之前。
 * 注意：new_node 总是未压缩的，所以当我们将它设置到头部或者末尾时不需要解压缩他们
 *       */
REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
                                        quicklistNode *old_node,
                                        quicklistNode *new_node, int after) {
    //若 after=1，则将新节点插入到旧节点之后
    if (after) {
        //将新节点的 prev 指针指向旧节点
        new_node-&gt;prev = old_node;
        //若存在旧节点
        if (old_node) {
            //将 old_node 的 next 指针赋值给 new_node 的 next，即将新节点的下一个节点指向原来的下一个
            new_node-&gt;next = old_node-&gt;next;
            //若旧节点存在下一个节点
            if (old_node-&gt;next)
                //将旧节点的下一个节点的上一个节点指针指向新节点
                old_node-&gt;next-&gt;prev = new_node;
            //旧节点的下一个节点指针指向新节点
            old_node-&gt;next = new_node;
        }
        //快表最后一个节点为旧节点
        if (quicklist-&gt;tail == old_node)
            //更新结尾节点为新节点
            quicklist-&gt;tail = new_node;
    } else {//其他情况将新节点插入到旧节点之前
        //新节点的下一个节点指向到旧节点
        new_node-&gt;next = old_node;
        //如果存在旧节点
        if (old_node) {
            //将新节点的上一个节点指针指向旧节点的上一个节点指针
            new_node-&gt;prev = old_node-&gt;prev;
            //如果存在旧节点的上一个节点
            if (old_node-&gt;prev)
                //将上一个节点的下一个节点指针指向新节点
                old_node-&gt;prev-&gt;next = new_node;
            //将旧节点的上一个节点指针指向新节点
            old_node-&gt;prev = new_node;
        }
        //如果快表的头结点为旧节点
        if (quicklist-&gt;head == old_node)
            //更新头结点为新节点
            quicklist-&gt;head = new_node;
    }
    /* If this insert creates the only element so far, initialize head/tail.
     * 如果插入导致创建了只有一个元素，则初始化头结点和尾节点
     * */
    if (quicklist-&gt;len == 0) {
        quicklist-&gt;head = quicklist-&gt;tail = new_node;
    }

    /* Update len first, so in __quicklistCompress we know exactly len
     * 首先更新长度，所以在 __quicklistCompress 中我们知道长度
     * */
    quicklist-&gt;len++;

    //如果存在旧节点
    if (old_node)
        //尝试将旧节点压缩
        quicklistCompress(quicklist, old_node);
}
</code></pre>
<p>代码比较长，总结如下:</p>
<ul>
  <li>如果当前被插入节点不满，直接插入。</li>
  <li>如果当前被插入节点是满的，要插入的位置是当前节点的尾部，且后一个节点有空间，那就插到后一个节点的头部。</li>
  <li>如果当前被插入节点是满的，要插入的位置是当前节点的头部，且前一个节点有空间，那就插到前一个节点的尾部。</li>
  <li>如果当前被插入节点是满的，前后节点也是满的，要插入的位置是当前节点的头部或者尾部，那就创建一个新的节点插进去。</li>
  <li>否则，当前节点是满的，且要插入的位置在当前节点的中间位置，我们需要把当前节点分裂成两个新节点，然后再插入。</li>
</ul>

<p><em>删除节点</em></p>

<p>源码分析:</p>
<pre><code class="language-CPP">/* Delete one element represented by 'entry'
 * 删除一个由 entry 表示的元素
 *
 * 'entry' stores enough metadata to delete the proper position in
 * the correct ziplist in the correct quicklist node.
 * entry 存储了足够的元数据以删除适当的位置，在正确的压缩列表在正确的快速列表节点
 * */
void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
    quicklistNode *prev = entry-&gt;node-&gt;prev;
    quicklistNode *next = entry-&gt;node-&gt;next;
    //删除当前节点
    int deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,
                                         entry-&gt;node, &amp;entry-&gt;zi);

    /* after delete, the zi is now invalid for any future usage.
     * 在删除之后， zi 现在对任何将来的使用都是无效的
     * */
    iter-&gt;zi = NULL;

    /* If current node is deleted, we must update iterator node and offset.
     * 如果当前节点已经被删除了，我们必须更新迭代节点和偏移
     * */
    if (deleted_node) {
        //若是迭代方向为头部
        if (iter-&gt;direction == AL_START_HEAD) {
            //迭代器当前指向下一个节点
            iter-&gt;current = next;
            //偏移设置为0
            iter-&gt;offset = 0;
        } else if (iter-&gt;direction == AL_START_TAIL) { //若是迭代方向为尾部
            //迭代器当前指向上一个节点
            iter-&gt;current = prev;
            //偏移设置为-1
            iter-&gt;offset = -1;
        }
    }
    /* else if (!deleted_node), no changes needed.
     * we already reset iter-&gt;zi above, and the existing iter-&gt;offset
     * doesn't move again because:
     *   - [1, 2, 3] =&gt; delete offset 1 =&gt; [1, 3]: next element still offset 1
     *   - [1, 2, 3] =&gt; delete offset 0 =&gt; [2, 3]: next element still offset 0
     *  if we deleted the last element at offet N and now
     *  length of this ziplist is N-1, the next call into
     *  quicklistNext() will jump to the next node. */
}

/* Delete one entry from list given the node for the entry and a pointer
 * to the entry in the node.
 * 从给定条目节点的列表中删除一个条目，还有一个指向节点中条目的指针
 *
 * Note: quicklistDelIndex() *requires* uncompressed nodes because you
 *       already had to get *p from an uncompressed node somewhere.
 *
 * Returns 1 if the entire node was deleted, 0 if node still exists.
 * Also updates in/out param 'p' with the next offset in the ziplist.
 * 返回1代表节点被删除了，0代表节点还存在
 * */
REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
                                   unsigned char **p) {
    int gone = 0;

    //删除压缩列表 zl
    node-&gt;zl = ziplistDelete(node-&gt;zl, p);
    //压缩列表节点减少
    node-&gt;count--;
    //如果节点数量为 0
    if (node-&gt;count == 0) {
        gone = 1;
        //删除快表中的节点
        __quicklistDelNode(quicklist, node);
    } else {
        //更新快表大小
        quicklistNodeUpdateSz(node);
    }
    //快表节点减少
    quicklist-&gt;count--;
    /* If we deleted the node, the original node is no longer valid
     * 如果我们删除了该节点，原始节点不再有效
     * */
    return gone ? 1 : 0;
}

REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
                                     quicklistNode *node) {
    /* Update the bookmark if any */
    quicklistBookmark *bm = _quicklistBookmarkFindByNode(quicklist, node);
    if (bm) {
        bm-&gt;node = node-&gt;next;
        /* if the bookmark was to the last node, delete it. */
        if (!bm-&gt;node)
            _quicklistBookmarkDelete(quicklist, bm);
    }

    //如果当前节点存在下一个节点
    if (node-&gt;next)
        //将当前节点的下一个节点的prev 指向当前节点的prev
        node-&gt;next-&gt;prev = node-&gt;prev;
    //如果当前节点存在前置节点
    if (node-&gt;prev)
        //将当前节点上一个节点的next 指向当前节点的next
        node-&gt;prev-&gt;next = node-&gt;next;

    //如果当前节点是快表的末尾节点
    if (node == quicklist-&gt;tail) {
        //更新快表末尾节点为 当前节点的上一个节点
        quicklist-&gt;tail = node-&gt;prev;
    }

    //如果当前节点是快表的头结点
    if (node == quicklist-&gt;head) {
        //更新快表头结点为当前节点的下一个节点
        quicklist-&gt;head = node-&gt;next;
    }

    /* Update len first, so in __quicklistCompress we know exactly len */
    //更新长度
    quicklist-&gt;len--;
    quicklist-&gt;count -= node-&gt;count;

    /* If we deleted a node within our compress depth, we
     * now have compressed nodes needing to be decompressed. */
    __quicklistCompress(quicklist, NULL);

    //释放内存
    zfree(node-&gt;zl);
    zfree(node);
}
</code></pre>
<p>quicklist 对于元素删除提供了删除单一元素以及删除区间元素 2 种方案。</p>
<ol>
  <li>对于删除单一元素，可以使用 quicklist 对外的接口 quicklistDelEntry 实现，也可以通过 quicklistPop 将头部或者尾部元素弹出。<br />
quicklistDelEntry 函数调用底层 quicklistDelIndex 函数，该函数可以删除 quicklistNode 指向的 ziplist 中的某个元素，其中 p 指向 ziplist 中某个entry 的起始位置。<br />
quicklistPop 可以弹出头部或者尾部元素，具体实现是通过 ziplist 的接口获取元素值，再通过上述的 quicklistDelIndex将数据删除。</li>
  <li>对于删除区间元素，quicklist 提供了 quicklistDelRange 接口，该函数可以从指定位置删除指定数量的元素。</li>
</ol>

<p>总体删除逻辑为：不管什么方式删除，最终都会通过 ziplist 来执行元素删除操作。先尝试删除该链表节点所指向的 ziplist 中的元素，如果 ziplist 中的元素已经为空了，就将该链表节点也删除掉。</p>

<blockquote>
  <p>https://pdai.tech/md/db/nosql-redis/db-redis-overview.html<br />
http://zhangtielei.com/posts/blog-redis-quicklist.html
https://czrzchao.github.io/redisSourceQuicklist
https://fanlv.fun/2019/08/12/reids-source-code-6/
https://juejin.cn/post/7093145133368999943</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">Ten 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">redis</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-30000004" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>压缩列表</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-ahmetkurt-12661193.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>ziplist</h3>
                            
                            </div>

                            <p><h3 id="压缩列表---ziplist">压缩列表 - ziplist</h3>
<blockquote>
  <p>ziplist 是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在 O(1) 的时间复杂度下完成 list 两端的 push 和 pop 操作。但是因为每次操作都需要重新分配 ziplist 的内存，所以实际复杂度和 ziplist 的内存使用量相关。</p>
</blockquote>

<p><strong>为什么 ZipList 特别省内存</strong></p>
<ul>
  <li>ziplist 节省内存是相对于普通的 list 来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显需要预留空间）</li>
  <li>所以 ziplist 在设计时就很容易想到尽量让每个元素按照实际的内容大小存储，所以增加 encoding 字段，针对不同的 encoding 来细化存储大小。</li>
  <li>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素？在普通数组中每个元素定长，所以不需要考虑这个问题；但是 ziplist 中每个 data 占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的 length，所以增加了 prelen 字段。</li>
</ul>

<p><strong>ziplist 数据结构</strong></p>

<center>   
<img src="../../img/redis/ziplist/ziplist结构图.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">ziplist结构图</div>
</center>
<p>由如下部分组成：</p>

<p><code class="language-plaintext highlighter-rouge">zlbytes</code>：uint32_t 类型，表示整个 ziplist 所占用内存的字节数，在执行内存分配时会被使用。<br />
<code class="language-plaintext highlighter-rouge">zltail</code>：uint32_t 类型，即上图到达 zlend 节点的偏移量，通过此偏移量可以快速定位到 zlend 节点。<br />
<code class="language-plaintext highlighter-rouge">zllen</code>：uint16_t 类型，ziplist 中节点的数量。当这个值小于 UINT16_MAX(65535) 时，这个值就是 ziplist 中节点的数量；当这个值等于 UINT16_MAX 时，节点的数量需要遍历整个 ziplist 才能计算得出。<br />
<code class="language-plaintext highlighter-rouge">entry</code>：ziplist 所保存的节点，各个节点的长度根据内容而定。<br />
<code class="language-plaintext highlighter-rouge">zlend</code>：uint8_t 类型，255 的二进制值 1111 1111(UINT8_MAX)，用于标记 ziplist 的末端。</p>

<p>官方描述如下：</p>
<pre><code class="language-C"> * ZIPLIST OVERALL LAYOUT
 * ======================
 *
 * The general layout of the ziplist is as follows:
 * ziplist的总体布局如下：
 *
 *   4字节     4字节     2字节                                1字节
 * &lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;
 *
 * NOTE: all fields are stored in little endian, if not specified otherwise.
 * 注意：如果没有另外指定，所有字段都以小端序存储（高位高存，顺序存放）
 *
 * &lt;uint32_t zlbytes&gt; is an unsigned integer to hold the number of bytes that
 * the ziplist occupies, including the four bytes of the zlbytes field itself.
 * This value needs to be stored to be able to resize the entire structure
 * without the need to traverse it first.
 * &lt;uint32_t zlbytes&gt; 是一个无符号整数来保存 ziplist 占用的字节数，包含 zlbytes 本身的四个字节。
 * 需要存储此值以便在不需要首先遍历它的情况下调整整个结构的大小。
 *
 * &lt;uint32_t zltail&gt; is the offset to the last entry in the list. This allows
 * a pop operation on the far side of the list without the need for full
 * traversal.
 * &lt;uint32_t zltail&gt; 是列表中最后一个entry的偏移量。它使得一个从列表另一边的 pop 操作无需全部遍历，时间复杂度为O(1)。
 *
 * &lt;uint16_t zllen&gt; is the number of entries. When there are more than
 * 2^16-2 entries, this value is set to 2^16-1 and we need to traverse the
 * entire list to know how many items it holds.
 * &lt;uint16_t zllen&gt; 代表 entry 的数量。 当entry的数量大于等于 2^16-2（即253） 时，它的值被设置为 2^16-1(即254)，并且我们需要遍历整个列表获取数量。为什么不是255，因为zlend默认使用255。
 *
 * &lt;uint8_t zlend&gt; is a special entry representing the end of the ziplist.
 * Is encoded as a single byte equal to 255. No other normal entry starts
 * with a byte set to the value of 255.
 * &lt;uint8_t zlend&gt; 是一个特殊的entry代表ziplist的结尾。 被编码为等于255的单个字节。 没有其他正常entry被设置为255.
</code></pre>

<p><strong>ziplist-entry 数据结构</strong></p>

<p>第一种情况，一般结构为：<code class="language-plaintext highlighter-rouge">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code><br />
<code class="language-plaintext highlighter-rouge">prevlen</code> : 前一个 entry 的大小，编码方式见下文；<br />
<code class="language-plaintext highlighter-rouge">encoding</code>：不同的情况下值不同，用于表示当前 entry 的类型和长度；<br />
<code class="language-plaintext highlighter-rouge">entry-data</code>：真正用于存储 entry 表示的数据;</p>

<p>第二种情况，在 entry 中存储的是 int 类型时，encoding 和 entry-data 会合并在 encoding 中表示，此时没有 entry-data 字段；<br />
redis 中，在存储数据时，会先尝试将 string 转换成 int 存储，节省空间；<br />
此时 entry 结构：<code class="language-plaintext highlighter-rouge">&lt;prevlen&gt; &lt;encoding&gt;</code></p>

<ul>
  <li>
    <p>prevlen编码<br />
当前一个元素长度小于 254 （255用于zlend） 的时候，prevlen长度为 1 个字节，值即为前一个 entry 的长度，如果长度大于等于 254 的时候，prevlen 用 5 个字节表示，第一个字节设置为 254 ，后面 4 个字节存储一个小端的无符号整型，表示前一个 entry 的长度：<br />
<code class="language-plaintext highlighter-rouge">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;</code> //长度小于 254 结构<br />
<code class="language-plaintext highlighter-rouge">0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;</code>  //长度大于等于 254 结构</p>
  </li>
  <li>
    <p>encoding编码<br />
encoding 的长度和值根据保存的是 int 还是 string，还有数据的长度而定；<br />
前两位用来表示类型，当为 11 时，表示 entry 存储的是 int 类型，其他表示存储的是 string；<br />
<strong>存储 string 时</strong>:<br />
<code class="language-plaintext highlighter-rouge">|00pppppp|</code>：此时 encoding 长度为 1 个字节，该字节的后六位表示 entry 中存储的 string 长度，因为是 6 位，所以entry 中存储的 string 长度不能超过 63；<br />
<code class="language-plaintext highlighter-rouge">|01pppppp|qqqqqqqq|</code>：此时 encoding 长度为 2 个字节；此时 encoding 的后 14 位用来存储 string 长度，长度不能超过 16383(2^14 - 1)；<br />
<code class="language-plaintext highlighter-rouge">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</code>：此时 encoding 长度为 5 个字节，后面的 4 个字节用来表示 encoding 中存储的字符串长度，长度不能超过 2^32 - 1；<br />
<strong>存储 int 时</strong>：<br />
<code class="language-plaintext highlighter-rouge">|11000000|</code>：encoding 为 3 个字节，后 2 个字节表示一个 int16；<br />
<code class="language-plaintext highlighter-rouge">|11010000|</code>：encoding 为 5 个字节，后 4 个字节表示一个 int32；<br />
<code class="language-plaintext highlighter-rouge">|11100000|</code>：encoding 为 9 个字节，后 8 个字节表示一个 int64；<br />
<code class="language-plaintext highlighter-rouge">|11110000|</code>：encoding 为 4 个字节，后 3 个字节表示一个有符号整型；<br />
<code class="language-plaintext highlighter-rouge">|11111110|</code>：encoding 为 2 个字节，后 1 个字节表示一个有符号整型；<br />
<code class="language-plaintext highlighter-rouge">|1111xxxx|</code>：encoding 长度就只有一个字节，xxxx 在 0001 到 1101 之前，表示无符号整数 0-12。 因为 0000和1111 不能被使用，实际编码值为 1-13，所以应该减去 1 获取正确的值； <br />
<code class="language-plaintext highlighter-rouge">|11111111|</code>：ziplist 特殊节点结尾；</p>
  </li>
</ul>

<p>官方描述如下：</p>
<pre><code class="language-C"> * ZIPLIST ENTRIES
 * ===============
 *
 * Every entry in the ziplist is prefixed by metadata that contains two pieces
 * of information. First, the length of the previous entry is stored to be
 * able to traverse the list from back to front. Second, the entry encoding is
 * provided. It represents the entry type, integer or string, and in the case
 * of strings it also represents the length of the string payload.
 * So a complete entry is stored like this:
 * ziplist中的每个节点都以包含两部分信息的元数据作为前缀。
 * 首先 将前一个节点的长度存储为能够从后到前遍历列表。
 * 第二 提供节点的编码，它代表节点的类型，整数或者字符串，在这种情况下的字符串，它也表示字符串有效载荷的长度。
 * 所以一个完整的节点按如下方式存储：
 *
 * &lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;
 *
 * Sometimes the encoding represents the entry itself, like for small integers
 * as we'll see later. In such a case the &lt;entry-data&gt; part is missing, and we
 * could have just:
 * 有时编码代表节点自身，像后面看到的短整数。在这种情况下 &lt;entry-data&gt; 部分将消失，类型如下：
 *
 * &lt;prevlen&gt; &lt;encoding&gt;
 *
 * The length of the previous entry, &lt;prevlen&gt;, is encoded in the following way:
 * If this length is smaller than 254 bytes, it will only consume a single
 * byte representing the length as an unsinged 8 bit integer. When the length
 * is greater than or equal to 254, it will consume 5 bytes. The first byte is
 * set to 254 (FE) to indicate a larger value is following. The remaining 4
 * bytes take the length of the previous entry as value.
 * &lt;prevlen&gt; : 上一个节点的长度，按以下方式编码：
 * 如果长度小于254字节，它将消耗 1 字节表示长度为 8bit 的整数。
 * 当长度大于等于254，它将占用 5 字节。第一个字节设置为 254（FE） 表明紧跟着的是较大值。剩下的 4 个字节以前一个节点的长度作为值。
 *
 * So practically an entry is encoded in the following way:
 * 因此 实际上节点是按照以下方式编码的
 *
 * &lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;
 * prevlen = [0, 253]
 *
 * Or alternatively if the previous entry length is greater than 253 bytes
 * the following encoding is used:
 * 或者 如果上一个节点长度大于 253 字节使用下面编码
 *
 * 0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;
 *
 * The encoding field of the entry depends on the content of the
 * entry. When the entry is a string, the first 2 bits of the encoding first
 * byte will hold the type of encoding used to store the length of the string,
 * followed by the actual length of the string. When the entry is an integer
 * the first 2 bits are both set to 1. The following 2 bits are used to specify
 * what kind of integer will be stored after this header. An overview of the
 * different types and encodings is as follows. The first byte is always enough
 * to determine the kind of entry.
 * 节点的编码字段取决于节点的内容。
 * 当节点是字符串时，编码的第一个字节的前 2 位将保存用于存储字符串的编码类型，然后是字符串的实际长度。
 * 当节点是整数时，前 2 位都设为 1，接下来的 2 位用来指定在这个头之后存储的整数类型。
 * 不同类型和编码的概述如下。第一个字节总是足够确定节点的类型
 *
 * 字符串
 * |00pppppp| - 1 byte
 *      String value with length less than or equal to 63 bytes (6 bits).
 *      "pppppp" represents the unsigned 6 bit length.
 *      长度小于等于 63(2^6-1) 字节的字符串， pppppp 代表无符号 6bit 长度
 * |01pppppp|qqqqqqqq| - 2 bytes
 *      String value with length less than or equal to 16383 bytes (14 bits).
 *      IMPORTANT: The 14 bit number is stored in big endian.
 *      长度小于等于 16383(2^14-1) 字节的字符串
 *      14位数字以大端序存储（高位低存，逆序存放）
 * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
 *      String value with length greater than or equal to 16384 bytes.
 *      Only the 4 bytes following the first byte represents the length
 *      up to 2^32-1. The 6 lower bits of the first byte are not used and
 *      are set to zero.
 *      IMPORTANT: The 32 bit number is stored in big endian.
 *      长度大于等于 16384（2^14） 字节的字符串。
 *      只有第一个字节之后的4个字节表示长度即 2^32-1。首字节的 6 个低bit位未使用且设置为0.
 *      32 bit 位以大端序存储（高位低存，逆序存放）
 *
 * 整数
 * |11000000| - 3 bytes
 *      Integer encoded as int16_t (2 bytes).
 *      整数编码为 int16_t（2字节）
 * |11010000| - 5 bytes
 *      Integer encoded as int32_t (4 bytes).
 *      整数编码为 int32_t（4字节）
 * |11100000| - 9 bytes
 *      Integer encoded as int64_t (8 bytes).
 *      整数编码为 int64_t（8字节）
 * |11110000| - 4 bytes
 *      Integer encoded as 24 bit signed (3 bytes).
 *      整数编码为24位有符号 （3字节）
 * |11111110| - 2 bytes
 *      Integer encoded as 8 bit signed (1 byte).
 *      整数编码为 8bit有符号 （1字节）
 * |1111xxxx| - (with xxxx between 0001 and 1101) immediate 4 bit integer.
 *      Unsigned integer from 0 to 12. The encoded value is actually from
 *      1 to 13 because 0000 and 1111 can not be used, so 1 should be
 *      subtracted from the encoded 4 bit value to obtain the right value.
 *      XXXX 在 0001到1101之间，即4bit 整数。
 *      无符号整数从0到12。编码值实际从1到13，因为0000和1111不能被使用，所以应该从4bit中减去 1 来获取正确的值
 *
 * |11111111| - End of ziplist special entry.
 *      ziplist特殊节点结尾
 *
 * Like for the ziplist header, all the integers are represented in little
 * endian byte order, even when this code is compiled in big endian systems.
</code></pre>

<p><strong>zlentry 数据结构</strong></p>
<pre><code class="language-C++">/* We use this function to receive information about a ziplist entry.
 * Note that this is not how the data is actually encoded, is just what we
 * get filled by a function in order to operate more easily.
 * 我们使用这个方法来接收 ziplist 节点的信息。
 * 注意这不是数据的实际编码方式，这只是为了更容易操作而由函数填充的内容
 */
typedef struct zlentry {
    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/
                                 //用于编码前一项 len 的字节，存储上一个元素的长度数值所需要的字节数
    unsigned int prevrawlen;     /* Previous entry len. */
                                 //前一个节点的长度
    unsigned int lensize;        /* Bytes used to encode this entry type/len.
                                    For example strings have a 1, 2 or 5 bytes
                                    header. Integers always use a single byte.*/
                                 //用于编码节点的类型或长度的字节。 例如字符串由 1、2、5字节的头部。 整数通常使用 1 字节
    unsigned int len;            /* Bytes used to represent the actual entry.
                                    For strings this is just the string length
                                    while for integers it is 1, 2, 3, 4, 8 or
                                    0 (for 4 bit immediate) depending on the
                                    number range. */
                                 //用于表示真正节点的字节。 对于字符串来说就是字符串的长度，对于整型来说依赖数字的范围，可能是 1,2,3，4,8 或 0的4bit位
    unsigned int headersize;     /* prevrawlensize + lensize. */
                                 //头部长度 前一个节点 加 当前节点的长度
    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
                                    the entry encoding. However for 4 bits
                                    immediate integers this can assume a range
                                    of values and must be range-checked. */
                                 //依赖节点的类型设置为 ZIP_STR_* or ZIP_INT_*。 然后对于 4bit位整数，可以假设为一个范围的值，必须进行范围检查
    unsigned char *p;            /* Pointer to the very start of the entry, that
                                    is, this points to prev-entry-len field. */
                                 //指向节点最开始的指针，即指向prev-entry-len(前一个节点长度) 字段
} zlentry;
</code></pre>
<p>上面说到列表元素的结构只有三个属性，分别是:</p>
<ul>
  <li>previous_entry_length: 前一个元素的字节长度</li>
  <li>encoding: 当前元素的编码</li>
  <li>content: 当前元素的内容</li>
</ul>

<p>previous_entry_length 属性记录了前一个元素的字节长度，却有 1 字节还是 5 字节之分，前一个元素的长度也根据字节数的不同，获取方式也不同。
因此我们可以把这个可变属性拆成 2 个属性:</p>
<ul>
  <li>prevrawlensize: 存储前一个元素的长度所需要的字节数</li>
  <li>prevrawlen: 前一个元素的长度</li>
</ul>

<p>encoding 属性表示当前元素的编码，记录着当前节点存储数据的类型及长度。 encoding 字段存储数据的长度也是采用变长的方式，可以是1、2、5字节，整数恒为 1 字节。<br />
encoding 值的前两位则能表示当前元素存储数据的类型。当 encoding 为 1111xxxx 时，xxxx还表示值的大小，此时 content 字段内容为空，所以连同 content 字段一起，我们可以把 encoding 属性拆分成三个属性:</p>
<ul>
  <li>lensize: 存储元素的长度数值所需要的字节数，可以为1、2、5字节，整数恒为 1 字节</li>
  <li>len: 表示元素的长度</li>
  <li>encoding: 标识是字节数组还是整数数组</li>
</ul>

<p>那么如何获取当前元素的内容呢，Redis是这个做的:</p>
<ul>
  <li>*p: 定义一个 char 类型指针，该指针指向当前元素的起始位置</li>
  <li>headersize: headersize 表示当前元素的首部长度，即 prevrawlensize + lensize</li>
</ul>

<p>通过指针 p 偏移 headersize 即可得到元素内容。</p>

<p>那么 Redis 是如何对压缩列表进行解码的呢？<br />
通过 zipEntry 函数进行解码压缩列表元素，并存于 zlentry 结构体。</p>
<pre><code class="language-C++">/* Fills a struct with all information about an entry.
 * This function is the "unsafe" alternative to the one blow.
 * Generally, all function that return a pointer to an element in the ziplist
 * will assert that this element is valid, so it can be freely used.
 * Generally functions such ziplistGet assume the input pointer is already
 * validated (since it's the return value of another function).
 * 用节点的所有信息填充结构体。这个函数是不安全的替代方法。
 * 一般来说，所有返回指向 ziplist 中元素指针的函数都回断言该元素是有效的，因此可以自由使用。
 * 一般来说 像ziplistGet的方法，假设输入的指针已经是有效的（因为它是其他方法返回的指针）
 */
static inline void zipEntry(unsigned char *p, zlentry *e) {
    //根据 prevrawlensize字节数解码 prevrawlen长度
    ZIP_DECODE_PREVLEN(p, e-&gt;prevrawlensize, e-&gt;prevrawlen);
    //根据 prevrawlensize字节数解码 encoding
    ZIP_ENTRY_ENCODING(p + e-&gt;prevrawlensize, e-&gt;encoding);
    //根据 prevrawlensize 和 encoding 解析节点长度及存储长度所需要的字节
    ZIP_DECODE_LENGTH(p + e-&gt;prevrawlensize, e-&gt;encoding, e-&gt;lensize, e-&gt;len);
    assert(e-&gt;lensize != 0); /* check that encoding was valid. */
    //设置节点头部大小 = 上一个节点长度 + 该节点长度
    e-&gt;headersize = e-&gt;prevrawlensize + e-&gt;lensize;
    e-&gt;p = p;
}


/* Return the length of the previous element, and the number of bytes that
 * are used in order to encode the previous element length.
 * 'ptr' must point to the prevlen prefix of an entry (that encodes the
 * length of the previous entry in order to navigate the elements backward).
 * The length of the previous entry is stored in 'prevlen', the number of
 * bytes needed to encode the previous entry length are stored in
 * 'prevlensize'.
 * 返回上一个元素的长度 和 用于编码上一个元素长度所需的字节数量。
 * 'ptr'必须指向节点的 prevlen 前缀（它对前一个节点长度进行编码以便向后导航元素）
 * 上一个节点的长度保存在 prevlen 中，编码前一个节点长度所需的字节数保存在 prevlensize 中
 */
#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
    /*解码 prevlensize 所占的字节数 要么为1字节要么为5字节，获取上一个节点真正的长度*/                                                                           \
    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
    /*若prevlensize为1，则ptr的第一个字节即为上一个节点的长度*/                                                                           \
    if ((prevlensize) == 1) {                                                  \
        (prevlen) = (ptr)[0];                                                  \
    } else { /* prevlensize == 5 若字节长度等于5，则取后面4个字节即32位作为上一个节点的长度 */            \
        /* 读取连续的4个字节（即32位），并将这4个字节的数据组合成一个整数len。
         * 这里的组合方式是按照小端字节序（little-endian）进行的，即最高有效字节（MSB）存放在最高的内存地址，最低有效字节（LSB）存放在最低的内存地址。
         * (ptr)[1]是第一个字节，它不会被移动，成为prevlen的最低8位
         * (pre)[2]是第二个字节，它会被左移8位，成为整数prevlen的次低8位
         * (pre)[3]是第三个字节，它会被左移16位，成为整数的prevlen的次高8位
         * (pre)[4]是第四个字节，它会被左移24位，成为整数的prevlen的最高8为
         * */                                                                       \
        (prevlen) = ((ptr)[4] &lt;&lt; 24) |                                         \
                    ((ptr)[3] &lt;&lt; 16) |                                         \
                    ((ptr)[2] &lt;&lt;  8) |                                         \
                    ((ptr)[1]);                                                \
    }                                                                          \
} while(0)

/* Return the number of bytes used to encode the length of the previous
 * entry. The length is returned by setting the var 'prevlensize'.
 * 返回用于编码上一个节点长度的字节数。 通过设置变量 prevlensize 来返回长度
 */
#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    /*若指针的第一个元素小于ZIP_BIG_PREVLEN 代表 prevlensize 为 1字节，否则为 5 字节*/  \
    if ((ptr)[0] &lt; ZIP_BIG_PREVLEN) {                                          \
        (prevlensize) = 1;                                                     \
    } else {                                                                   \
        (prevlensize) = 5;                                                     \
    }                                                                          \
} while(0)


/* Extract the encoding from the byte pointed by 'ptr' and set it into
 * 'encoding' field of the zlentry structure.
 * 从 ptr 所指向的字节中提取编码，并且将它设置到 zlentry 结构中的 encoding 字段
 * */
#define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
    (encoding) = ((ptr)[0]);                    \
    /* 若 encoding 小于ZIP_STR_MASK（字符串标志位），与ZIP_STR_MASK进行与运算获取 int类型编码 */                                            \
    if ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \
} while(0)


/* Decode the entry encoding type and data length (string length for strings,
 * number of bytes used for the integer for integer entries) encoded in 'ptr'.
 * The 'encoding' variable is input, extracted by the caller, the 'lensize'
 * variable will hold the number of bytes required to encode the entry
 * length, and the 'len' variable will hold the entry length.
 * On invalid encoding error, lensize is set to 0.
 * 解码节点中的编码类型和数据长度（对于字符串的字符串长度，对于整数项的整数所使用的字节数）。
 * encoding变量是输入，由调用者提取。变量 lensize 保留编码节点长度所需的字节。 变量 len 将保留节点的长度。
 * 在编码异常场景下，lensize将设置为0
 * */
#define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
    /*判断编码属于字节数组还是整数类型*/                                                                           \
    if ((encoding) &lt; ZIP_STR_MASK) {                                           \
        /*如果存储长度等于 ZIP_STR_06B（00000000）*/                                                                       \
        if ((encoding) == ZIP_STR_06B) {                                       \
            /*需要 1 字节存储字符串长度*/                                                                   \
            (lensize) = 1;                                                     \
            /* 元素长度为 (ptr)[0] 和 111111 做与运算获取实际长度 */                                                                   \
            (len) = (ptr)[0] &amp; 0x3f;                                           \
        } else if ((encoding) == ZIP_STR_14B) {/*如果存储长度等于 ZIP_STR_14B(0100 0000) */                                \
            (lensize) = 2;                                                     \
            (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \
        } else if ((encoding) == ZIP_STR_32B) {                                \
            (lensize) = 5;                                                     \
             /* 读取连续的4个字节（即32位），并将这4个字节的数据组合成一个整数len。
              * 这里的组合方式是按照大端字节序（big-endian）进行的，即最高有效字节（MSB）存放在最低的内存地址，最低有效字节（LSB）存放在最高的内存地址。
              * (ptr)[1]是第一个字节，它会被左移24位，成为整数的prevlen的最高8为
              * (pre)[2]是第二个字节，它会被左移16位，成为整数的prevlen的次高8位
              * (pre)[3]是第三个字节，它会被左移8位，成为整数prevlen的次低8位
              * (pre)[4]是第四个字节，它不会被移动，成为prevlen的最低8位
              * */                                                                       \
            (len) = ((uint32_t)(ptr)[1] &lt;&lt; 24) |                               \
                    ((uint32_t)(ptr)[2] &lt;&lt; 16) |                               \
                    ((uint32_t)(ptr)[3] &lt;&lt;  8) |                               \
                    ((uint32_t)(ptr)[4]);                                      \
        } else {                                                               \
            (lensize) = 0; /* bad encoding, should be covered by a previous */ \
            (len) = 0;     /* ZIP_ASSERT_ENCODING / zipEncodingLenSize, or  */ \
                           /* match the lensize after this macro with 0.
                            * 异常场景，赋值0*/ \
        }                                                                      \
    } else {                                                                   \
        /*判断编码属于整数类型*/                                                                           \
        (lensize) = 1;                                                         \
        if ((encoding) == ZIP_INT_8B)  (len) = 1;  /* 若encoding = ZIP_INT_8B 长度为1字节，即可以用 8bit 位数据表示 */                            \
        else if ((encoding) == ZIP_INT_16B) (len) = 2;  /* 若encoding = ZIP_INT_16B 长度为2字节，即可以用 16bit 位数据表示 */                         \
        else if ((encoding) == ZIP_INT_24B) (len) = 3;  /* 若encoding = ZIP_INT_24B 长度为3字节，即可以用 24bit 位数据表示 */                         \
        else if ((encoding) == ZIP_INT_32B) (len) = 4;  /* 若encoding = ZIP_INT_32B 长度为4字节，即可以用 32bit 位数据表示 */                         \
        else if ((encoding) == ZIP_INT_64B) (len) = 8;  /* 若encoding = ZIP_INT_64B 长度为8字节，即可以用 64bit 位数据表示 */                         \
        else if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX)  /* 异常情况 长度设置为0 */ \
            (len) = 0; /* 4 bit immediate */                                   \
        else                                                                   \
            (lensize) = (len) = 0; /* bad encoding */                          \
    }                                                                          \
} while(0)
</code></pre>
<p>可以看到解码主要分为三个步骤:</p>
<ol>
  <li>解码 previous_entry_length 字段，此时入参 ptr 指向元素首地址</li>
  <li>解码 encoding 字段，此时入参 ptr 指向元素首地址偏移 previous_entry_length 字段长度的位置</li>
  <li>解码 len 字段，根据 encoding 分别解析计算节点长度</li>
</ol>

<p><strong>创建压缩列表</strong><br />
源码如下：</p>
<pre><code class="language-C++">/* Create a new empty ziplist. */
//创建压缩列表
unsigned char *ziplistNew(void) {
    //初始化默认字节大小=11字节  即 zlbytes(4字节) + zltail(4字节) + zlen(2字节) + zlend(1字节)
    unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
    //分配内存11字节大小
    unsigned char *zl = zmalloc(bytes);
    //初始化 zlbytes 字段
    //intrev32ifbe 意思为 int32 reversal if big endian，即如果当前主机字节序为大端序，那么将它的内存存储进行翻转操作。  见https://blog.csdn.net/WhereIsHeroFrom/article/details/84643017
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
    //初始化 zltail 字段
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
    //长度设置为0
    ZIPLIST_LENGTH(zl) = 0;
    //初始化结束标志位
    zl[bytes-1] = ZIP_END;
    return zl;
}
</code></pre>
<p>创建压缩列表的代码很简单，函数无输入参数，只需要分配初始化存储空间 11（4+4+2+1）个，并对 zlytes、zltail、zllen 和 zlend 字段初始化值，最后返回压缩列表的首地址。</p>

<p><strong>插入元素</strong><br />
源码如下:</p>
<pre><code class="language-C++">
/* Insert item at "p".
 * 向指针 p 中插入元素
 * zl:压缩列表字节大小
 * p:压缩列表指针
 * s: 待插入的节点
 * slen: 待插入的节点长度
 * */
unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    //curlen 表示插入元素前压缩列表的长度
    //reqlen表示新插入元素的长度
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, newlen;
    //prevlensize 表示前一个字节的长度
    //prevlen 表示存储前一个字节需要的字节数
    unsigned int prevlensize, prevlen = 0;
    size_t offset;
    //nextdiff 表示插入元素后一个元素长度的变化，取值可能是0（长度不变），4（长度增加4）或-4（长度减少4）
    int nextdiff = 0;
    //encoding 用于存储当前元素编码
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized.
                                    初始化以避免警告。使用该值可以很简单的看出未初始化
                                    */
    zlentry tail;

    /* Find out prevlen for the entry that is inserted.
     * 计算已插入节点的 prevlen
     * */
    //找出待插入节点的前置节点长度，有三种场景
    if (p[0] != ZIP_END) {
        //若非结尾标识，直接计算上一个节点的长度
        //1.如果p[0] 不指向列表末尾，说明列表非空，并且 p 指向其中一个节点，所以新插入节点的前置节点长度可以通过节点 p 指向的节点信息中获取
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); //通过 ZIP_DECODE_PREVLEN 方法获取 prevlen 长度
    } else {
        //获取尾节点位置，用来判断当前压缩列表是否为空列表
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        //若末尾节点非结束标识
        //2. 如果尾节点指针不指向压缩列表末尾，说明当前压缩列表不为空，那么新插入节点的前置节点长度就是尾节点的长度
        if (ptail[0] != ZIP_END) {
            //获取尾节点的总长度 头部大小+总长度
            prevlen = zipRawEntryLengthSafe(zl, curlen, ptail);
        }
        //3. 第三种情况就是 p 指向压缩列表末尾，但是压缩列表中节点为空，所以 p 的前置节点长度为 0 ，故不做处理
    }

    /* See if the entry can be encoded
     * 尝试将节点从String转为int，计算当前节点的长度
     * */
    //s指针指向新增节点数据  slen为数据长度
    //确定数据编码，为整数时返回对应固定长度，为字符串时使用slen
    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {
        /* 'encoding' is set to the appropriate integer encoding
         * encoding 已经设置为最合适的整数编码，并获取编码长度
         * */
        reqlen = zipIntSize(encoding);
    } else {
        /* 'encoding' is untouched, however zipStoreEntryEncoding will use the
         * string length to figure out how to encode it.
         * encoding 未受影响，但是 zipStoreEntryEncoding 将使用字符串长度来决定如何编码
         * */
        reqlen = slen;
    }

    /* We need space for both the length of the previous entry and
     * the length of the payload.
     * 我们需要为前一个节点的长度和有效负载的长度分配空间 即更新当前节点场景
     * */
    //编码前置节点长度所需字节数
    reqlen += zipStorePrevEntryLength(NULL,prevlen);
    //编码当前字符串长度所需字节数
    //此时 reqlen 为新加入节点的整体长度
    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

    /* When the insert position is not equal to the tail, we need to
     * make sure that the next entry can hold this entry's length in
     * its prevlen field.
     * 当插入的位置不在尾部时，我们需要保证下一个节点可以在 prevlen 字段中保存当前节点的长度
     * */
    int forcelarge = 0; //在nextdiff==-4 &amp;&amp; reqlen&lt;4 时使用，该条件说明，插入元素导致压缩列表变小了，即函数 ziplistResize内部调用 realloc 重新分配空间小于 zl 指向的空间，此时 realloc 会将多余空间回收，导致数据丢失（丢失了尾部），所以为了避免这种情况，我们使用forcelarge来标记这种情况，并将 nextdiff 置为0，详情见https://segmentfault.com/a/1190000018878466?utm_source=tag-newest
    //计算原来 p 位置上的节点将要保存的 prevlen（当前待插入节点的大小） 是否变化
    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
    //连锁更新的时候会出现问题
    if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) {
        nextdiff = 0; //将nextdiff 设置为0，此时内存重分配不会出现回收空间的情况，造成数据丢失
        forcelarge = 1;
    }

    /* Store offset because a realloc may change the address of zl.
     * 重新分配内存肯呢个会改变 zl 的地址，所以存储偏移
     * */
    offset = p-zl; //偏移量，用来表示 p 相对于压缩列表首地址的偏移量，由于重新分配了空间，新元素插入的位置指针 p 会时效，可以预先计算好指针 p 对于压缩列表首地址的偏移量，待空间分配之后再便宜
    //最新空间大小   当前压缩列表大小 + 插入元素大小 + 差值长度
    newlen = curlen+reqlen+nextdiff;
    //重新分配压缩列表大小
    zl = ziplistResize(zl,newlen);
    //根据偏移找到新插入元素 P 的位置
    p = zl+offset;

    /* Apply memory move when necessary and update tail offset.
     * 必要时应用内存移动并更新尾偏移量
     * */
    //非空列表插入
    if (p[0] != ZIP_END) {
        /* Subtract one because of the ZIP_END bytes
         * 因为是 ZIP_END 字节，所以减去1
         * */
        //将 p 节点后移（没有移动 p 节点前一节点长度信息），留出当前节点位置
        //p+reqlen: 偏移量是这个，就是将原来的数据移动到新插入节点之后
        //curlen-offset-1+nextdiff: 移动的长度，就是位置 P 之后的所有元素的长度 -1（结束符大小恒为 0XFF，不需要移动），再加上 nextdiff（下一个元素长度的变化）
        //p-nextdiff: 表示从哪个位置需要复制移动，因为下一个元素长度会发生变化，所以需要提前预留出这部分空间，就多复制一块空间，到时候覆盖即可
        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);

        /* Encode this entry's raw length in the next entry.
         * 在下一个节点中编码节点原始长度 并且判断是否需要加大上一个节点长度
         * */
        //写入 p 节点以前一个节点长度信息（要插入节点的长度）
        if (forcelarge)
            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
        else
            zipStorePrevEntryLength(p+reqlen,reqlen);

        /* Update offset for tail
         * 更新末尾节点的偏移
         * */
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);

        /* When the tail contains more than one entry, we need to take
         * "nextdiff" in account as well. Otherwise, a change in the
         * size of prevlen doesn't have an effect on the *tail* offset.
         * 当尾部包含多个节点时，还需要考虑 nextdiff，否则，prevlen大小的变化不会对尾部偏移量产生影响
         * */
        assert(zipEntrySafe(zl, newlen, p+reqlen, &amp;tail, 1));
        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
        }
    } else {
        /* This element will be the new tail.
         * 如果在末尾 则该节点将变成新的末尾节点
         * */
        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);
    }

    /* When nextdiff != 0, the raw length of the next entry has changed, so
     * we need to cascade the update throughout the ziplist
     * 当 nextdiff 不为0，下一个节点的原始长度已经改变，所以需要级联更新
     * */
    if (nextdiff != 0) {
        //计算偏移
        offset = p-zl;
        //级联更新压缩链表
        zl = __ziplistCascadeUpdate(zl,p+reqlen);
        //更新后添加偏移
        p = zl+offset;
    }

    /* Write the entry
     * 写节点信息
     * */
    //写入前一节点长度信息
    p += zipStorePrevEntryLength(p,prevlen);
    //写入节点编码与长度信息
    p += zipStoreEntryEncoding(p,encoding,slen);
    //如果是字符串则分配内存
    if (ZIP_IS_STR(encoding)) {
        memcpy(p,s,slen);
    } else {
        //是整数则添加整数值
        zipSaveInteger(p,value,encoding);
    }
    //压缩列表长度加1
    ZIPLIST_INCR_LENGTH(zl,1);
    return zl;
}


/* Return the length of the previous element, and the number of bytes that
 * are used in order to encode the previous element length.
 * 'ptr' must point to the prevlen prefix of an entry (that encodes the
 * length of the previous entry in order to navigate the elements backward).
 * The length of the previous entry is stored in 'prevlen', the number of
 * bytes needed to encode the previous entry length are stored in
 * 'prevlensize'.
 * 返回上一个元素的长度 和 用于编码上一个元素长度所需的字节数量。
 * 'ptr'必须指向节点的 prevlen 前缀（它对前一个节点长度进行编码以便向后导航元素）
 * 上一个节点的长度保存在 prevlen 中，编码前一个节点长度所需的字节数保存在 prevlensize 中
 */
#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
    /*解码 prevlensize 所占的字节数 要么为1字节要么为5字节，获取上一个节点真正的长度*/                                                                           \
    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
    /*若prevlensize为1，则ptr的第一个字节即为上一个节点的长度*/                                                                           \
    if ((prevlensize) == 1) {                                                  \
        (prevlen) = (ptr)[0];                                                  \
    } else { /* prevlensize == 5 若字节长度等于5，则取后面4个字节即32位作为上一个节点的长度 */            \
        /* 读取连续的4个字节（即32位），并将这4个字节的数据组合成一个整数len。
         * 这里的组合方式是按照小端字节序（little-endian）进行的，即最高有效字节（MSB）存放在最高的内存地址，最低有效字节（LSB）存放在最低的内存地址。
         * (ptr)[1]是第一个字节，它不会被移动，成为prevlen的最低8位
         * (pre)[2]是第二个字节，它会被左移8位，成为整数prevlen的次低8位
         * (pre)[3]是第三个字节，它会被左移16位，成为整数的prevlen的次高8位
         * (pre)[4]是第四个字节，它会被左移24位，成为整数的prevlen的最高8为
         * */                                                                       \
        (prevlen) = ((ptr)[4] &lt;&lt; 24) |                                         \
                    ((ptr)[3] &lt;&lt; 16) |                                         \
                    ((ptr)[2] &lt;&lt;  8) |                                         \
                    ((ptr)[1]);                                                \
    }                                                                          \
} while(0)


/* Return the total number of bytes used by the entry pointed to by 'p'.
 * 返回 p 所指向的节点所使用的总字节数
 * */
static inline unsigned int zipRawEntryLengthSafe(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &amp;e, 0));
    return e.headersize + e.len;
}


/* Check if string pointed to by 'entry' can be encoded as an integer.
 * Stores the integer value in 'v' and its encoding in 'encoding'.
 * 检查 entry 所指向的字符串是否可以被编码为整数。
 * 将整数值存储在 v 中，它的编码存储在 encoding 字段中
 * */
int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {
    long long value;

    if (entrylen &gt;= 32 || entrylen == 0) return 0;
    if (string2ll((char*)entry,entrylen,&amp;value)) {
        /* Great, the string can be encoded. Check what's the smallest
         * of our encoding types that can hold this value. */
        if (value &gt;= 0 &amp;&amp; value &lt;= 12) {
            *encoding = ZIP_INT_IMM_MIN+value;
        } else if (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) {
            *encoding = ZIP_INT_8B;
        } else if (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) {
            *encoding = ZIP_INT_16B;
        } else if (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) {
            *encoding = ZIP_INT_24B;
        } else if (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) {
            *encoding = ZIP_INT_32B;
        } else {
            *encoding = ZIP_INT_64B;
        }
        *v = value;
        return 1;
    }
    return 0;
}


/* Return bytes needed to store integer encoded by 'encoding'
 * 返回存储由 encoding 编码的整数所需的字节数
 * */
static inline unsigned int zipIntSize(unsigned char encoding) {
    switch(encoding) {
    case ZIP_INT_8B:  return 1;
    case ZIP_INT_16B: return 2;
    case ZIP_INT_24B: return 3;
    case ZIP_INT_32B: return 4;
    case ZIP_INT_64B: return 8;
    }
    if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX)
        return 0; /* 4 bit immediate */
    /* bad encoding, covered by a previous call to ZIP_ASSERT_ENCODING */
    redis_unreachable();
    return 0;
}


/* Encode the length of the previous entry and write it to "p". Return the
 * number of bytes needed to encode this length if "p" is NULL.
 * 编码上一个节点的长度且将它写入到 p 节点中。
 * 如果节点 p 为null，返回编码该长度需要的字节数
 * */
unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
    //如果节点 p 为空，返回当前 len 对应的编码即可
    if (p == NULL) {
        //如果 len 小于254返回1字节，否则返回 4字节 + 1字节
        return (len &lt; ZIP_BIG_PREVLEN) ? 1 : sizeof(uint32_t) + 1;
    } else {
        //若节点 p 不为空
        //当前长度小于 254 更新节点 p 长度并返回 1字节
        if (len &lt; ZIP_BIG_PREVLEN) {
            p[0] = len;
            return 1;
        } else {
            //返回上一个节点的更大字节 用于更新场景
            return zipStorePrevEntryLengthLarge(p,len);
        }
    }
}


/* Encode the length of the previous entry and write it to "p". This only
 * uses the larger encoding (required in __ziplistCascadeUpdate).
 * 对前一项的长度进行编码，并将其写入 p 。这只用于更大的编码 用于 __ziplistCascadeUpdate 方法
 * */
int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
    uint32_t u32;
    //若p 不为null，更新长度编码即长度
    if (p != NULL) {
        p[0] = ZIP_BIG_PREVLEN;
        u32 = len;
        memcpy(p+1,&amp;u32,sizeof(u32));
        memrev32ifbe(p+1);
    }
    //返回 1 + 4 字节
    return 1 + sizeof(uint32_t);
}


/* Write the encoding header of the entry in 'p'. If p is NULL it just returns
 * the amount of bytes required to encode such a length. Arguments:
 * 将节点的编码头部写入到 p 中，如果 p 为null则返回编码头部需要的长度
 *
 * 'encoding' is the encoding we are using for the entry. It could be
 * ZIP_INT_* or ZIP_STR_* or between ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX
 * for single-byte small immediate integers.
 * encoding 是我们为节点使用的编码。它可以是 ZIP_INT_* or ZIP_STR_* 或 大小在 ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX 表示单字节小的直接整数。
 *
 * 'rawlen' is only used for ZIP_STR_* encodings and is the length of the
 * string that this entry represents.
 * rawlen 只用于 ZIP_STR_* 编码且该节点所代表的字符串长度
 *
 * The function returns the number of bytes used by the encoding/length
 * header stored in 'p'.
 * 该方法返回  存储在 p 中用于 encoding/length 头部的字节大小
 * */
unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
    unsigned char len = 1, buf[5];

    //判断是否字符串 并更新 编码字段
    if (ZIP_IS_STR(encoding)) {
        /* Although encoding is given it may not be set for strings,
         * so we determine it here using the raw length. */
        if (rawlen &lt;= 0x3f) {
            if (!p) return len;
            buf[0] = ZIP_STR_06B | rawlen;
        } else if (rawlen &lt;= 0x3fff) {
            len += 1;
            if (!p) return len;
            buf[0] = ZIP_STR_14B | ((rawlen &gt;&gt; 8) &amp; 0x3f);
            buf[1] = rawlen &amp; 0xff;
        } else {
            len += 4;
            if (!p) return len;
            buf[0] = ZIP_STR_32B;
            buf[1] = (rawlen &gt;&gt; 24) &amp; 0xff;
            buf[2] = (rawlen &gt;&gt; 16) &amp; 0xff;
            buf[3] = (rawlen &gt;&gt; 8) &amp; 0xff;
            buf[4] = rawlen &amp; 0xff;
        }
    } else {
        /* Implies integer encoding, so length is always 1.
         * 暗示整数编码，长度总为1
         * */
        if (!p) return len;
        buf[0] = encoding;
    }

    /* Store this length at p.
     * 将长度保存在 p 中
     * */
    memcpy(p,buf,len);
    return len;
}


/* Given a pointer 'p' to the prevlen info that prefixes an entry, this
 * function returns the difference in number of bytes needed to encode
 * the prevlen if the previous entry changes of size.
 * 给定一个指针 p ，指向一个节点的 prevlen 信息，如果前一个节点的大小改变了，该方法则返回 编码 prevlen长度的差值
 *
 * So if A is the number of bytes used right now to encode the 'prevlen'
 * field.
 * 如果 A 是当前 prevlen字段编码的字节大小
 *
 * And B is the number of bytes that are needed in order to encode the
 * 'prevlen' if the previous element will be updated to one of size 'len'.
 * 如果前一个节点将被更新为大小为 len 的元素， 则B 是编码 prevlen 所需的字节数
 *
 * Then the function returns B - A
 * 该方法返回 b-a
 *
 * So the function returns a positive number if more space is needed,
 * a negative number if less space is needed, or zero if the same space
 * is needed.
 * 如果该方法返回正数代表需要更多的空间，返回负数代表需要更少的空间，或 0 代表无需改动
 * */
int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
    unsigned int prevlensize;
    //当前节点的 prevlen 字节大小 A
    ZIP_DECODE_PREVLENSIZE(p, prevlensize);
    //最新节点长度的 prevlen 字节大小 B
    return zipStorePrevEntryLength(NULL, len) - prevlensize;
}


/* Return the number of bytes used to encode the length of the previous
 * entry. The length is returned by setting the var 'prevlensize'.
 * 返回用于编码上一个节点长度的字节数。 通过设置变量 prevlensize 来返回长度
 */
#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    /*若指针的第一个元素小于ZIP_BIG_PREVLEN 代表 prevlensize 为 1字节，否则为 5 字节*/  \
    if ((ptr)[0] &lt; ZIP_BIG_PREVLEN) {                                          \
        (prevlensize) = 1;                                                     \
    } else {                                                                   \
        (prevlensize) = 5;                                                     \
    }                                                                          \
} while(0)


/* Resize the ziplist.
 * 重新调整压缩列表的大小
 * */
unsigned char *ziplistResize(unsigned char *zl, size_t len) {
    assert(len &lt; UINT32_MAX);
    zl = zrealloc(zl,len);
    ZIPLIST_BYTES(zl) = intrev32ifbe(len);
    zl[len-1] = ZIP_END;
    return zl;
}


/* Encode the length of the previous entry and write it to "p". Return the
 * number of bytes needed to encode this length if "p" is NULL.
 * 编码上一个节点的长度且将它写入到 p 节点中。
 * 如果节点 p 为null，返回编码该长度需要的字节数
 * */
unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
    //如果节点 p 为空，返回当前 len 对应的编码即可
    if (p == NULL) {
        //如果 len 小于254返回1字节，否则返回 4字节 + 1字节
        return (len &lt; ZIP_BIG_PREVLEN) ? 1 : sizeof(uint32_t) + 1;
    } else {
        //若节点 p 不为空
        //当前长度小于 254 更新节点 p 长度并返回 1字节
        if (len &lt; ZIP_BIG_PREVLEN) {
            p[0] = len;
            return 1;
        } else {
            //返回上一个节点的更大字节 用于更新场景
            return zipStorePrevEntryLengthLarge(p,len);
        }
    }
}
</code></pre>
<p>插入元素可以简要分为 3 个步骤:</p>
<ol>
  <li>将元素内容编码</li>
  <li>重新分配内存空间</li>
  <li>复制数据</li>
</ol>

<p>下面详细介绍每个步骤的实现:<br />
<strong>编码</strong><br />
编码即计算 previous_entry_length 字段， encoding 字段和 content 字段的内容。那么如何获取前一个元素的长度呢？此时就需要根据元素的插入位置分情况讨论了。插入元素的位置如下图所示:</p>

<center>   
<img src="../../img/redis/ziplist/插入元素位置示意.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">插入元素位置示意</div>
</center>

<ol>
  <li>当插入列表为空、插入位置为 P0 时，不存在前一个元素，即前一个元素的长度为0；</li>
  <li>当插入位置为 P1 时，需要获取 entryX 元素的长度，而 entryX+1 元素的 previous_len 字段存储的就是 entryX 元素的长度，比较容易获取</li>
  <li>当插入位置为 P2 时，需要获取 entryN 元素的长度，entryN 是压缩列表的尾元素，计算元素长度时需要将其 3 个字段长度相加<br />
找出元素插入位置代码如下：</li>
</ol>

<pre><code class="language-C++">/* Find out prevlen for the entry that is inserted.
 * 计算已插入节点的 prevlen
 * */
//找出待插入节点的前置节点长度，有三种场景
if (p[0] != ZIP_END) {
    //若非结尾标识，直接计算上一个节点的长度
    //1.如果p[0] 不指向列表末尾，说明列表非空，并且 p 指向其中一个节点，所以新插入节点的前置节点长度可以通过节点 p 指向的节点信息中获取
    ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); //通过 ZIP_DECODE_PREVLEN 方法获取 prevlen 长度
} else {
    //获取尾节点位置，用来判断当前压缩列表是否为空列表
    unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
    //若末尾节点非结束标识
    //2. 如果尾节点指针不指向压缩列表末尾，说明当前压缩列表不为空，那么新插入节点的前置节点长度就是尾节点的长度
    if (ptail[0] != ZIP_END) {
        //获取尾节点的总长度 头部大小+总长度
        prevlen = zipRawEntryLengthSafe(zl, curlen, ptail);
    }
    //3. 第三种情况就是 p 指向压缩列表末尾，但是压缩列表中节点为空，所以 p 的前置节点长度为 0 ，故不做处理
}
</code></pre>

<p>当插入位置为压缩列表末尾且压缩列表不为空时，计算前一个元素长度代码如下所示：</p>

<pre><code class="language-C++">/* Return the total number of bytes used by the entry pointed to by 'p'.
 * 返回 p 所指向的节点所使用的总字节数
 * */
static inline unsigned int zipRawEntryLengthSafe(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &amp;e, 0));
    return e.headersize + e.len;
}
</code></pre>

<p>encoding 字段标识的是当前元素存储的数据类型和数据长度。</p>
<ul>
  <li>编码时首先尝试将数据内容解析为整数，如果解析成功，则按照压缩列表整数类型编码存储</li>
  <li>如果解析失败，则按照压缩列表字节数类型编码存储</li>
</ul>

<pre><code class="language-C++">/* See if the entry can be encoded
 * 尝试将节点从String转为int，计算当前节点的长度
 * */
//s指针指向新增节点数据  slen为数据长度
//确定数据编码，为整数时返回对应固定长度，为字符串时使用slen
if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {
    /* 'encoding' is set to the appropriate integer encoding
     * encoding 已经设置为最合适的整数编码，并获取编码长度
     * */
    reqlen = zipIntSize(encoding);
} else {
    /* 'encoding' is untouched, however zipStoreEntryEncoding will use the
     * string length to figure out how to encode it.
     * encoding 未受影响，但是 zipStoreEntryEncoding 将使用字符串长度来决定如何编码
     * */
    reqlen = slen;
}

/* We need space for both the length of the previous entry and
 * the length of the payload.
 * 我们需要为前一个节点的长度和有效负载的长度分配空间 即更新当前节点场景
 * */
//编码前置节点长度所需字节数
reqlen += zipStorePrevEntryLength(NULL,prevlen);
//编码当前字符串长度所需字节数
//此时 reqlen 为新加入节点的整体长度
reqlen += zipStoreEntryEncoding(NULL,encoding,slen);
</code></pre>
<p>上述代码尝试按照整数解析新添加元素的数据内容，数值存储在变量的 value 中，编码存储在变量 encoding 中。如果解析成功，还需要计算整数整数所占字节数。
变量 reqlen 最终存储的是当前元素所需空间大小，初始赋值为元素 content 字段所需空间的大小，再累加 previous_entry_length 和 encoding 字段所需空间大小</p>

<p><strong>重新分配空间</strong><br />
由于新插入了元素，压缩列表所需空间增大，因此需要重新分配存储空间。那么空间大小是不是添加元素前的压缩列表长度与新添加元素长度之和呢？并不完全是，因为 previous_entry_length 字段长度是根据前一个字段长度变化的。</p>

<p>我们假设插入元素前， entryX 元素的长度为 128 字节， entryX+1 元素的 previous_entry_length 字段占 1 字节；
添加元素 entryNew，元素长度为 1024 字节，此时 entryX+1 元素的 previous_entry_length 字段需要占 5 个字节，即压缩列表的长度不仅增加了 1024 字节，还要加上 entryX+1 元素扩展的 4 个字节。而 entryX+1 元素的长度可能增加 4 个字节、减少 4 个字节或者不变。<br />
压缩列表长度变化如下图所示：</p>

<center>   
<img src="../../img/redis/ziplist/压缩列表长度变化示意.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">压缩列表长度变化示意</div>
</center>

<p>由于重新分配了空间，新元素插入的位置指针 P 会失效，可以预先计算好指针 P 相对于压缩列表首地址的偏移量，待分配空间之后再偏移即可。<br />
代码实现如下：</p>
<pre><code class="language-C++">/* We need space for both the length of the previous entry and
 * the length of the payload.
 * 我们需要为前一个节点的长度和有效负载的长度分配空间 即更新当前节点场景
 * */
//编码前置节点长度所需字节数
reqlen += zipStorePrevEntryLength(NULL,prevlen);
//编码当前字符串长度所需字节数
//此时 reqlen 为新加入节点的整体长度
reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

/* When the insert position is not equal to the tail, we need to
 * make sure that the next entry can hold this entry's length in
 * its prevlen field.
 * 当插入的位置不在尾部时，我们需要保证下一个节点可以在 prevlen 字段中保存当前节点的长度
 * */
int forcelarge = 0; //在nextdiff==-4 &amp;&amp; reqlen&lt;4 时使用，该条件说明，插入元素导致压缩列表变小了，即函数 ziplistResize内部调用 realloc 重新分配空间小于 zl 指向的空间，此时 realloc 会将多余空间回收，导致数据丢失（丢失了尾部），所以为了避免这种情况，我们使用forcelarge来标记这种情况，并将 nextdiff 置为0，详情见https://segmentfault.com/a/1190000018878466?utm_source=tag-newest
//计算原来 p 位置上的节点将要保存的 prevlen（当前待插入节点的大小） 是否变化
nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
//连锁更新的时候会出现问题
if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) {
    nextdiff = 0; //将nextdiff 设置为0，此时内存重分配不会出现回收空间的情况，造成数据丢失
    forcelarge = 1;
}

/* Store offset because a realloc may change the address of zl.
 * 重新分配内存肯呢个会改变 zl 的地址，所以存储偏移
 * */
offset = p-zl; //偏移量，用来表示 p 相对于压缩列表首地址的偏移量，由于重新分配了空间，新元素插入的位置指针 p 会时效，可以预先计算好指针 p 对于压缩列表首地址的偏移量，待空间分配之后再便宜
//最新空间大小   当前压缩列表大小 + 插入元素大小 + 差值长度
newlen = curlen+reqlen+nextdiff;
//重新分配压缩列表大小
zl = ziplistResize(zl,newlen);
//根据偏移找到新插入元素 P 的位置
p = zl+offset;
</code></pre>
<p>nextdiff 用来表示 entryX+1 元素长度变化，取值可能为 0 （长度不变）、4（长度增加4）、-4（长度减少4）<br />
forcelarge 用来表示一种特殊的情况，即 nextdiff==-4&amp;&amp;reqlen&lt;4 ，该情况有可能会导致内存重分配时回收内存空间，进而数据丢失。所以表示这种特殊情况并做处理。<br />
offset 表示指针 P 相对于压缩列表首地址的偏移位置，内存重分配后计算指针 P 的新的位置时使用</p>

<blockquote>
  <p>下面详细说下 nextdiff == -4 &amp;&amp; reqlen &lt; 4 这个情况<br />
nextdiff == -4 &amp;&amp; reqlen &lt; 4 时会发生什么呢？插入元素导致压缩列表所需空间变小了。即函数 ziplistResize 内部调研 realloc 重新分配的空间小于指针 zl指向的空间。我们知道 realloc 重新分配空间时，返回的地址可能不变（当前位置有足够的内存空间可供分配），当重新分配的空间减少时，realloc 可能会将多余的空间回收，导致数据丢失（压缩列表后面一部分数据丢失）。因此需要避免这种情况的发生，Redis 采用的方法是重新赋值 nextdiff=0，同时使用 forcelarge 标记这种情况。<br />
那么，nextdiff=-4 时，reqlen 会小于 4 吗？nextdiff=-4 说明插入元素之前 entryX+1 的元素的总长度大于等于 254 字节，所以 entryNew 元素的 previous_entry_length 字段同样需要 5 个字节，即 entryNew 元素的总长度肯定是大于 5 个字节的，reqlen 又怎么会小于 4 呢？正常情况下是不会出现这种情况的，但是由于连锁更新，可能会出现 nextdiff=-4 但 entryX 元素的总长度小于 254 字节的情况，此时 reqlen 可能会小于 4 。</p>
</blockquote>

<p><strong>数据复制</strong><br />
重新分配空间之后，需要将位置 P 后的元素移动到指定位置，将新元素插入到位置 P。我们假设 entryX+1 元素的长度增加 4（即nextdiff=4）。代码如下：</p>
<pre><code class="language-C++">  /* Apply memory move when necessary and update tail offset.
     * 必要时应用内存移动并更新尾偏移量
     * */
    //非空列表插入
    if (p[0] != ZIP_END) {
        /* Subtract one because of the ZIP_END bytes
         * 因为是 ZIP_END 字节，所以减去1
         * */
        //将 p 节点后移（没有移动 p 节点前一节点长度信息），留出当前节点位置
        //p+reqlen: 偏移量是这个，就是将原来的数据移动到新插入节点之后
        //curlen-offset-1+nextdiff: 移动的长度，就是位置 P 之后的所有元素的长度 -1（结束符大小恒为 0XFF，不需要移动），再加上 nextdiff（下一个元素长度的变化）
        //p-nextdiff: 表示从哪个位置需要复制移动，因为下一个元素长度会发生变化，所以需要提前预留出这部分空间，就多复制一块空间，到时候覆盖即可
        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);

        /* Encode this entry's raw length in the next entry.
         * 在下一个节点中编码节点原始长度 并且判断是否需要加大上一个节点长度
         * */
        //写入 p 节点以前一个节点长度信息（要插入节点的长度）
        if (forcelarge)
            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
        else
            zipStorePrevEntryLength(p+reqlen,reqlen);

        /* Update offset for tail
         * 更新末尾节点的偏移
         * */
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);

        /* When the tail contains more than one entry, we need to take
         * "nextdiff" in account as well. Otherwise, a change in the
         * size of prevlen doesn't have an effect on the *tail* offset.
         * 当尾部包含多个节点时，还需要考虑 nextdiff，否则，prevlen大小的变化不会对尾部偏移量产生影响
         * */
        assert(zipEntrySafe(zl, newlen, p+reqlen, &amp;tail, 1));
        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
        }
    } else {
        /* This element will be the new tail.
         * 如果在末尾 则该节点将变成新的末尾节点
         * */
        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);
    }
</code></pre>
<p>数据复制分为两种情况：</p>
<ol>
  <li>一种是当前插入的位置不是最后，因此需要进行数据赋值</li>
  <li>另一种是当前插入的位置为尾节点后面，就不需要进行数据复制了</li>
</ol>

<p>主要看第一种情况，其中下面这段代码需要仔细理解下：</p>
<blockquote>
  <p>memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);<br />
C库函数 void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1。</p>
</blockquote>

<ul>
  <li>p+reqlen 很好理解，就是将 P 后面的数据复制到新节点之后</li>
  <li>curlen-offset-1+nextdiff 表示复制的字符数量。即 P 后面元素的长度 + entryX+1 元素长度的变化 nextdiff，再减去 1 ，因为结束符恒为 0XFF,不需要移动</li>
  <li>p-nextdiff 将 P 后面的内容复制过去，然后多复制一块，因为下一个元素的长度空间会发生变化，供下一个元素的 previous_entry_length 使用</li>
</ul>

<p>为什么第一个更新尾元素偏移量之后，指向的元素可能不是尾元素呢？因为当 entryX+1 元素就是尾元素时，只需要更新一次尾元素的偏移量；但是当 entryX+1 元素不是尾元素时且 entryX+1 元素的长度发生了改变时，尾元素偏移量还需要加上 nextdiff 的值。</p>

<p><strong>连锁更新</strong><br />
每个节点的 previous_entry_length 属性都记录了前一个节点的长度：</p>
<ul>
  <li>如果前一个节点的长度小于 254 字节，那么 previous_entry_length 属性需要用 1 字节长度的空间来保存这个长度值</li>
  <li>如果前一个节点的长度大于等于 254 字节，那么 previous_entry_length 属性需要用 5 个字节的空间来保存这个长度值</li>
</ul>

<p>现在，考虑这样一种情况：在一个压缩列表中，有多个连续的、长度介于 250 字节到 253 字节之间的节点 e1 到 eN ，如下图所示：</p>

<center>   
<img src="../../img/redis/ziplist/包含节点 e1 至 eN 的压缩列表.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">包含节点 e1 至 eN 的压缩列表</div>
</center>

<p>因为 e1 到 eN 的所有节点的长度都小于 254 字节，所以记录这些节点的长度只需要 1 字节长的 previous_entry_length 属性。
这时，如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点，那么 new 将成为 e1 的前置节点，如下图所示：</p>

<center>   
<img src="../../img/redis/ziplist/插入新节点到压缩列表.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">插入新节点到压缩列表</div>
</center>

<p>因为 e1 的 previous_entry_length 属性仅长 1 字节，它没办法保存新节点 new 的长度，所以程序将对压缩列表执行空间重分配操作，并将 e1 节点的 previous_entry_length 属性从原来的 1 字节扩展为 5 字节长。<br />
现在，麻烦的事情来了，e1 原本的长度介于 250 字节至 253 字节之间，在为 previous_entry_length 属性新增 4 个字节空间之后， e1 的长度就变成了介于 254 字节至 257 字节之间，而这种长度使用 1 字节长的 previous_entry_length 属性是没办法保存的。</p>

<p>因此，为了让 e2 的 previous_entry_length 属性可以记录下 e1 的长度，程序需要再次对压缩列表执行空间重分配操作，并将 e2 节点的 previous_entry_length 属性从原来的 1 字节扩展为 5 字节。</p>

<p>正如扩展 e1 引发了对 e2 的扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展。为了让每个节点的 previous_entry_length 属性都符合压缩列表对节点的要求，程序需要不断地对压缩列表执行空间分配操作，指导 eN 位置。</p>

<p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为 连续更新，下图展示了这一过程：</p>

<center>   
<img src="../../img/redis/ziplist/连锁更新过程.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">连锁更新过程</div>
</center>

<p>除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。</p>

<p>考虑到上图所示的压缩列表，如果 e1 至 eN 都是大小介于 250 字节至 253 字节的节点，big 节点的长度大于等于 254 字节（需要 5 字节的 previous_entry_length 来保存），而 small 节点的长度小于 254 字节（只需要 1 字节的 previous_entry_length 来保存），那么当我们将 small 节点从压缩列表中删除之后，为了让 e1 的 pervious_entry_length 属性可以记录 big 节点的长度，程序将扩展 e1 的空间，并由此引发之后的连锁更新。</p>

<center>   
<img src="../../img/redis/ziplist/删除节点引发连锁更新.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">删除节点引发连锁更新</div>
</center>

<p>因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作，而每次空间重分配的最坏复杂度为 O(N) ，所以连锁更新的最坏复杂度为 O(N^2)。</p>

<p>需要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p>
<ul>
  <li>首先，压缩列表里要恰好有多个连续、长度介于 250 字节至 253 字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li>
  <li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响；比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>

<p>因为以上原因，ziplistPush 等命令的平均复杂度仅为 O(N) ，在实际中，可以放心使用这些函数，而不必担心连锁更新会影响压缩列表的性能。</p>

<p>源码代码如下：</p>
<pre><code class="language-C++">/* When an entry is inserted, we need to set the prevlen field of the next
 * entry to equal the length of the inserted entry. It can occur that this
 * length cannot be encoded in 1 byte and the next entry needs to be grow
 * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,
 * because this only happens when an entry is already being inserted (which
 * causes a realloc and memmove). However, encoding the prevlen may require
 * that this entry is grown as well. This effect may cascade throughout
 * the ziplist when there are consecutive entries with a size close to
 * ZIP_BIG_PREVLEN, so we need to check that the prevlen can be encoded in
 * every consecutive entry.
 * 当插入一个节点时，我们需要将下一个节点的 prevlen 字段设置为等于插入节点的长度。
 * 可能会出现这种情况，这个长度不能被 1 字节编码，下一个节点需要变大以存储 5字节的 prevlen 编码。
 * 这可以免费完成，因为这只会发生在节点已经被插入（这会导致realloc和memmove）。
 * 但是，编码 prevlen 同样需要节点增长。
 * 当存在大小接近 ZIP_BIG_PREVLEN 的连续节点时，这种效果可能会在整个 ziplist 中级联，因为我们需要检查 prevlen 是否可以在每个连续条目中编码
 *
 *
 * Note that this effect can also happen in reverse, where the bytes required
 * to encode the prevlen field can shrink. This effect is deliberately ignored,
 * because it can cause a "flapping" effect where a chain prevlen fields is
 * first grown and then shrunk again after consecutive inserts. Rather, the
 * field is allowed to stay larger than necessary, because a large prevlen
 * field implies the ziplist is holding large entries anyway.
 * 请注意，这种效果也可以反过来发生，在这种情况下，编码 prevlen 字段所需的字节会缩小。
 * 这种效果被故意忽略了，因为它会导致扑动效果，即在连续插入之后，链上的字段首先增长，然后再次收缩。
 * 相反，允许字段保持比需要的更发，因为较大的 prevlen 字段意味着 ziplist 无论如何多包涵较大的节点。
 *
 *
 * The pointer "p" points to the first entry that does NOT need to be
 * updated, i.e. consecutive fields MAY need an update.
 * 指针 p 指向第一个不需要被更新节点，即连续的字段可能需要更新
 * */
unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    zlentry cur;
    size_t prevlen, prevlensize, prevoffset; /* Informat of the last changed entry. 最后更改的节点信息 */
    size_t firstentrylen; /* Used to handle insert at head. 用于处理头部插入 */
    size_t rawlen, curlen = intrev32ifbe(ZIPLIST_BYTES(zl));
    size_t extra = 0, cnt = 0, offset;
    size_t delta = 4; /* Extra bytes needed to update a entry's prevlen (5-1).  更新节点的 prevlen 所需的额外字节（5-1） */
    unsigned char *tail = zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl));

    /* Empty ziplist */
    if (p[0] == ZIP_END) return zl;

    //将 p 所指向的节点的信息保存到 cur 结构中
    zipEntry(p, &amp;cur); /* no need for "safe" variant since the input pointer was validated by the function that returned it. */
    //当前节点的长度
    firstentrylen = prevlen = cur.headersize + cur.len;
    //计算编码当前节点的长度所需的字节数
    prevlensize = zipStorePrevEntryLength(NULL, prevlen);
    //记录 p 的偏移量
    prevoffset = p - zl;
    //记录下一节点的偏移量
    p += prevlen;

    /* Iterate ziplist to find out how many extra bytes do we need to update it.
     * 迭代压缩列表找出需要更新的额外字节数
     * */
    while (p[0] != ZIP_END) {
        assert(zipEntrySafe(zl, curlen, p, &amp;cur, 0));

        /* Abort when "prevlen" has not changed. 当 prevlen 没有改变时终止 */
        if (cur.prevrawlen == prevlen) break;

        /* Abort when entry's "prevlensize" is big enough. 当节点的 prevlensize 足够大时宗旨 */
        if (cur.prevrawlensize &gt;= prevlensize) {
            if (cur.prevrawlensize == prevlensize) {
                zipStorePrevEntryLength(p, prevlen);
            } else {
                /* This would result in shrinking, which we want to avoid.
                 * So, set "prevlen" in the available bytes. */
                zipStorePrevEntryLengthLarge(p, prevlen);
            }
            break;
        }

        /* cur.prevrawlen means cur is the former head entry. */
        assert(cur.prevrawlen == 0 || cur.prevrawlen + delta == prevlen);

        /* Update prev entry's info and advance the cursor. 更新前一个节点的信息并移动光标 */
        rawlen = cur.headersize + cur.len;
        prevlen = rawlen + delta; 
        prevlensize = zipStorePrevEntryLength(NULL, prevlen);
        prevoffset = p - zl;
        p += rawlen;
        extra += delta;
        cnt++;
    }

    /* Extra bytes is zero all update has been done(or no need to update).
     * 额外字节为零，表示更新已完成（或不需要更新）
     * */
    if (extra == 0) return zl;

    /* Update tail offset after loop.
     * 循环后更新尾部偏移量
     * */
    if (tail == zl + prevoffset) {
        /* When the the last entry we need to update is also the tail, update tail offset
         * unless this is the only entry that was updated (so the tail offset didn't change). */
        if (extra - delta != 0) {
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra-delta);
        }
    } else {
        /* Update the tail offset in cases where the last entry we updated is not the tail. */
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);
    }

    /* Now "p" points at the first unchanged byte in original ziplist,
     * move data after that to new ziplist.
     * 现在 p 指向原始 ziplist 中第一个未更改的字节，将其之后的数据移动到ziplist中
     * */
    offset = p - zl;
    zl = ziplistResize(zl, curlen + extra);
    p = zl + offset;
    memmove(p + extra, p, curlen - offset - 1);
    p += extra;

    /* Iterate all entries that need to be updated tail to head.
     * 迭代所有需要从头到尾更新的节点
     * */
    while (cnt) {
        zipEntry(zl + prevoffset, &amp;cur); /* no need for "safe" variant since we already iterated on all these entries above. */
        rawlen = cur.headersize + cur.len;
        /* Move entry to tail and reset prevlen. 将入口移动至尾部并重置预设值 */
        memmove(p - (rawlen - cur.prevrawlensize), 
                zl + prevoffset + cur.prevrawlensize, 
                rawlen - cur.prevrawlensize);
        p -= (rawlen + delta);
        if (cur.prevrawlen == 0) {
            /* "cur" is the previous head entry, update its prevlen with firstentrylen. */
            zipStorePrevEntryLength(p, firstentrylen);
        } else {
            /* An entry's prevlen can only increment 4 bytes. */
            zipStorePrevEntryLength(p, cur.prevrawlen+delta);
        }
        /* Foward to previous entry. 跳转到上一个节点 */
        prevoffset -= cur.prevrawlen;
        cnt--;
    }
    return zl;
}
</code></pre>

<p><strong>删除元素</strong><br />
ziplistDelete 函数可以同时删除多个元素，输入参数 p 指向的是首个待删除元素的地址，num 表示待删除元素数据。<br />
删除元素同样可以简要分为三个步骤：</p>
<ol>
  <li>计算待删除元素的总长度</li>
  <li>数据复制</li>
  <li>重新分配空间</li>
</ol>

<p>计算待删除元素的总长度<br />
相关代码如下：</p>
<pre><code class="language-C++">//解码第一个待删除元素
zipEntry(p, &amp;first); /* no need for "safe" variant since the input pointer was validated by the function that returned it. */
//遍历所有待删除元素，通知指针后移
for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) {
    p += zipRawEntryLengthSafe(zl, zlbytes, p);
    deleted++;
}

assert(p &gt;= first.p);
//待删除元素的总长度
totlen = p-first.p; /* Bytes taken by the element(s) to delete. 要删除的元素所占的字节数*/
</code></pre>
<p>即遍历压缩列表，计算待删除元素的长度之和。</p>

<p>数据复制<br />
第一步完成之后，指针 first 与指针 p 之间的元素都是待删除的。当指针 p 恰好指向 zlend 字段时，不需要复制数据，只需要更新尾节点的偏移量即可。</p>

<p>接下来，我们看另外一种情况，即指针 p 指向的是某一个元素，而不是 zlend 字段。 删除元素时，压缩列表所需空间减少，那么减少的量是否仅为待删除元素的总长度呢？那肯定不是了，因为需要更新下一个节点的 previous_entry_length 的值。见下图：</p>
<center>   
<img src="../../img/redis/ziplist/压缩列表删除元素示意.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">压缩列表删除元素示意</div>
</center>

<p>删除元素 entryX+1 到元素 entryN-1 之间的 N-X-1 个元素，元素 entryN-1 的长度为 12 字节，因此元素 entryN 的 previous_entry_length 字段占 1 字节；<br />
删除这些元素之后，entryX 成为了 entryN 的前一个元素，元素 entryX 的长度为 512 字节，因此元素 entryN 的 previous_entry_length 字段还需要占 5 个字节，即删除元素之后的压缩列表的总长度还与元素 entryN 长度的变化量有关。<br />
源码如下：</p>
<pre><code class="language-C++">/* Storing `prevrawlen` in this entry may increase or decrease the
 * number of bytes required compare to the current `prevrawlen`.
 * There always is room to store this, because it was previously
 * stored by an entry that is now being deleted.
 * 在此表项中存储 prevrawlen 可能会比当前 prevrawlen 增加或减少所需的字节数。
 * 总是有空间来存储它，因为它以前是一个现在被删除的节点存储的。
 * 计算删除的 最后一个元素 entryN-1 之后的元素 entryN 的长度变化量
 * */
nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);

/* Note that there is always space when p jumps backward: if
 * the new previous entry is large, one of the deleted elements
 * had a 5 bytes prevlen header, so there is for sure at least
 * 5 bytes free and we need just 4.
 * 请注意，当 p 向后跳转时总是有空间：如果新的前一个节点很大，则删除的元素之一具有 5 字节的 prevlen 头部，因此肯定至少有 5 字节的空闲空间，而我们只需要 4 字节。
 * */
//更新 entryN 的 previous_entry_length 字段
p -= nextdiff;
assert(p &gt;= first.p &amp;&amp; p&lt;zl+zlbytes-1);
zipStorePrevEntryLength(p,first.prevrawlen);

/* Update offset for tail
 * 尾部更新偏移
 * */
set_tail = intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen;

/* When the tail contains more than one entry, we need to take
 * "nextdiff" in account as well. Otherwise, a change in the
 * size of prevlen doesn't have an effect on the *tail* offset.
 * 当尾部包含多个节点时，我们还需要考虑 nextdiff 。
 * 否则， prevlen  大小的变化不会对 尾 偏移量产生影响。
 * */
assert(zipEntrySafe(zl, zlbytes, p, &amp;tail, 1));
if (p[tail.headersize+tail.len] != ZIP_END) {
    set_tail = set_tail + nextdiff;
}

/* Move tail to the front of the ziplist
 * 将尾部移到压缩列表的签名
 * */
/* since we asserted that p &gt;= first.p. we know totlen &gt;= 0,
 * so we know that p &gt; first.p and this is guaranteed not to reach
 * beyond the allocation, even if the entries lens are corrupted.
 * 因为我们断言 p &gt;= first.p。 我们知道 totlen&gt;=0，所以我们知道 p&gt;first.p ，这保证不会超出分哦，即使节点长度被损坏
 * */
size_t bytes_to_move = zlbytes-(p-zl)-1;
memmove(first.p,p,bytes_to_move);
</code></pre>

<p>重新分配空间<br />
重新分配空间与插入元素的类似，代码如下：</p>
<pre><code class="language-C++">/* Resize the ziplist
 * 重新调整压缩列表大小
 * */
offset = first.p-zl;
zlbytes -= totlen - nextdiff;
zl = ziplistResize(zl, zlbytes);
p = zl+offset;
</code></pre>

<p>另外，在插入元素时，调用 ziplistResize 函数重新分配空间时，如果重新分配的空间小于指针 zl 指向的空间时，可能会出现问题。而删除元素时，压缩列表的长度肯定时减小的。<br />
因为删除元素时，先复制数据，再重新分配空间，即调用 ziplistResize 函数时，多余的那部分空间存储的数据已经被复制，此时回收这部分空间并不会造成数据的损失。</p>

<blockquote>
  <p>https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html#ziplist%E7%BB%93%E6%9E%84<br />
http://zhangtielei.com/posts/blog-redis-ziplist.html<br />
https://juejin.cn/post/6914456200650162189#heading-17
https://juejin.cn/post/7097856013776191518
https://segmentfault.com/a/1190000018878466?utm_source=tag-newest
https://wenfh2020.com/2020/01/30/redis-ziplist/</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">July 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">redis</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-30000003" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>简单动态字符串</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-matreding-23105882.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>sds</h3>
                            
                            </div>

                            <p><h3 id="简单动态字符串---sds">简单动态字符串 - sds</h3>
<blockquote>
  <p>一种用于存储二进制数据的一种结构，具有动态扩容的特点，其实现位于src/sds.h和src/sds.c中。从版本3.2开始，sds底层数据结构也发生改变。</p>
</blockquote>

<p><strong>字符串编码类型</strong><br />
字符串有三种 encoding 类型 int 、 raw 、 embstr 。</p>
<ul>
  <li>int：用于整数类型</li>
  <li>embstr：用于短字符串</li>
  <li>raw：用于长字符串</li>
</ul>

<p>定义在 server.h 中，下面列出 string 类型的编码</p>
<pre><code class="language-C">#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
</code></pre>

<p><strong>int</strong><br />
如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型来表示，那么这个整数值将会保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ），并将字符串对象的编码设置为 int 。<br />
相对于用 raw 编码， int 编码既节省了指针占用的内存，也节省了 sds 结构的内存。</p>

<center>   
<img src="../../img/redis/sds/string-int.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">int示例</div>
</center>

<p><strong>embstr</strong><br />
embstr 编码是专门用于保存短字符串的一种优化编码方式。当字符串的长度小于等于 44(redis 3.2版本之前为39) 字节的时候，将采用 embstr 编码。<br />
创建字符串对象的代码如下（object.c）：</p>
<pre><code class="language-C">/* Create a string object with EMBSTR encoding if it is smaller than
 * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is
 * used.
 * 如果字符串小于等于OBJ_ENCODING_EMBSTR_SIZE_LIMIT 创建embstr编码，否则使用raw编码
 *
 * The current limit of 44 is chosen so that the biggest string object
 * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc.
 * 选择当前44的限制是为了作为embstr分配的最大字符串对象仍然适合64字节的jemalloc
 *
 */
#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
robj *createStringObject(const char *ptr, size_t len) {
    if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return createRawStringObject(ptr,len);
}
</code></pre>
<p>embstr 有个显著的特点，就是 redisObject 跟 sds 的内存是连在一起的。好处有：</p>
<ul>
  <li>分配内存的时候只需要分配一次。而 raw 编码的 sds 跟 RedisObject 分离，就是分配两次内存</li>
  <li>同样，释放内存也只需要释放一次</li>
  <li>连续内存能更好利用内存带来的优势</li>
</ul>

<center>   
<img src="../../img/redis/sds/embstr结构示意图.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">embstr结构示意图</div>
</center>

<p><strong>raw</strong><br />
raw 编码主要用来保存长度超过 44（redis 3.2版本之后） 字节的字符串。其真实数据由sdshdr结构来表示存储，外层还是由 RedisObject 包装。<br />
sds 的结构大致如下：</p>

<center>   
<img src="../../img/redis/sds/raw-sds结构.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">raw-sds结构</div>
</center>

<p>redisObject 中的 ptr 指针，就是指向 sds 。</p>
<center>   
<img src="../../img/redis/sds/raw-robj.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">raw-robj</div>
</center>

<p><strong>编码转换</strong><br />
<strong>int 转 raw</strong></p>
<ul>
  <li>当字符串传的不是整数的时候，int 就会转成 raw 编码</li>
  <li>如果执行了一些修改命令，如 append 等（set 不算），都会转成 raw 编码</li>
  <li>一旦编码变为 raw 之后，将不会再转成 embstr</li>
</ul>

<p><strong>embstr 转 raw</strong></p>
<ul>
  <li>如果执行了一些修改的命令，如 append 等，都会转成 raw 编码，不管修改后字符串的长度。因为没有给 embstr 编码实现修改接口，实际上 embstr 是只读的。</li>
  <li>一旦编码为 raw 之后，将不会再转成 embstr</li>
</ul>

<p><strong>embstr编码为什么从 39 位修改为 44 位</strong></p>
<blockquote>
  <p>embstr 编码中，RedisObject 和 sds 是一块连续的内存空间，这块内存空间 Redis 限制了 64 个字节，而 RedisObject 固定占了 16 字节，
redis3.2 版本之前的 sds 占了 8 个字节，再加上字符串末尾 \0 占用了 1 个字节，所以：64-16-8-1=39 字节。<br />
redis3.2 版本之后 sds 做了优化，对于 embstr 编码会采用 sdshdr8 来存储，而 sdshdr8 占用的空间只有 24 位，即 3 字节（len+alloc+flag） + \0 字符(1字节)，
所以最后为： 64-16-3-1=44 字节。</p>
</blockquote>

<p><strong>sds结构优化</strong></p>

<center>   
<img src="../../img/redis/sds/sds结构图-3.0.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">sds结构图-3.0</div>
</center>

<pre><code class="language-C">#redis3.2 sdshdr结构  

struct sdshdr {
    //记录buf数组中已使用字节的数量  4字节
    //等于SDS所保存字符串的长度
    unsigned int len;

    //记录buf数组中未使用字节的数量  4字节
    unsigned int free;

    //char数组，用于保存字符串
    char buf[];
};
</code></pre>

<ul>
  <li>len为6，表示这个SDS保存了一个长度为5的字符串  4字节</li>
  <li>free为0，表示这个SDS没有剩余空间  4字节</li>
  <li>buf是个char类型的数组，注意末尾保存了一个空字符 ‘\0’(1字节)</li>
</ul>

<pre><code class="language-C">#redis6.2 sdshdr结构  

struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */ 已使用 1字节存储
    uint8_t alloc; /* excluding the header and null terminator */ 1字节存储
    unsigned char flags; /* 3 lsb of type, 5 unused bits */ 1字节存储
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
</code></pre>

<p>其中 <strong>sdshdr</strong> 是头部，它的大小可以通过 sizeOf() 方法计算， <strong>buf</strong> 是真实存储用户数据的地方，另外注意，从命名上能看出来，这个数据结构除了能存储二进制数据，显然是用于设计作为字符串使用的，所以在 <strong>buf</strong> 中，用户数据后总跟着一个 <strong>\0</strong>，即图中的 “数据”+”\0” 就是所谓的buf。</p>
<ul>
  <li>len:保存了SDS保存字符串的长度   (len-alloc 即为之前的 free)</li>
  <li>alloc:分别以uint8, uint16, uint32, uint64表示整个SDS，除头部与末位的 \0，剩余的字节数</li>
  <li>flags:始终为 1 字节，以低三位标示着头部的类型，高五位未使用</li>
  <li>buf[]:数组用来保存字符串的每个元素，注意末尾保存了一个空字符 ‘\0’</li>
</ul>

<p>每个字段大小可以根据不同 sdshdr 来计算，比如 sdshdr8 代表 8bit 即 1字节，以此类推。</p>
<pre><code class="language-C">printf("%ld\n", sizeof(struct sdshdr8));  // 3
printf("%ld\n", sizeof(struct sdshdr16)); // 5
printf("%ld\n", sizeof(struct sdshdr32)); // 9
printf("%ld\n", sizeof(struct sdshdr64)); // 17
</code></pre>

<p>另外，我们还需要注意以下源码中的 <strong>attribute</strong> ((<strong>packed</strong>)) 。它的作用就是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用的字节数进行对齐。<br />
从上面我们已经知道，结构体会按照所有变量中最宽的基本数据类型做字节对齐。但是用 packed 修饰后，结构体则变为按 1 字节对齐。<br />
以 sdshdr32 为例，修饰前按 4 字节对齐大小为 12（4*3 - [len=4;alloc=4;flags=4(实际是1)]） 字节；修饰后按 1 字节对齐，共 9 （4*2+1 - [len=4;alloc=4;flags=1(实际是1)]）  字节。注意 buf 是个 char 类型的柔性数组，地址连续，始终在 flags 之后，packed 修饰前后如下图所示。</p>

<center>   
<img src="../../img/redis/sds/packed修饰前后示意.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">packed修饰前后示意</div>
</center>

<p>这样做有两个好处：<br />
1 - 节省内存：例如 sdshdr32 可节省 3 个字节（12-9）<br />
2 - SDS 返回给上层的，不是结构体首地址，而是指向内容的 buf 指针。因为此时按 1 字节对齐，故 SDS创建成功后， 无论是 sdshdr8、sdsdhr16、还是 sdshdr32，都能通过 (char*)sh+hdrlen 得到 buf 指针地址（其中 hdrlen 是结构体长度，通过 sizeof 计算得到）。修饰后，无论是 sdshdr8、sdshdr16 还是 sdshdr32，都能通过 buf[-1] 找到 flags，因为此时按 1 字节对齐。若没有 packed 的修饰，还需要对不同结构进行处理，实现更复杂。</p>

<p><br /></p>

<p>存在问题:<br />
  不同长度的字符串是否有必要占用大小相同的头部？一个int占 4 字节，在实际应用中，存放与redis的字符串往往没有这么长，每个字符串都用 4 字节存储未免太浪费空间。<br />
  短字符串，len 和 free 的长度为 1 字节就够了；长字符串，用 2 字节或 4 字节；更长的字符串，用 8 字节。<br />
<br /><br />
这样确实更省内存，但依然存在以下问题：<br />
1-如何区分三种情况？<br />
2-对于短字符串来说，头部还是太长了。以长度为 1 字节的字符串为例，len 和 free 本身就占了 2 字节，能不能进一步压缩呢？<br />
对于问题 1，考虑增加一个字符 flags 来标识类型，用最小的 1 字节来存储，且把 flags 加在柔性数组 buf 之前，这样虽然多了 1 字节，但是通过偏移柔性数组的指针即能快速定位 flags ，区分类型也可以接受。<br />
对于问题 2，由于 len 已经是最小的 1 字节了，再压缩只能考虑用位长来存储长度了。</p>

<p>  结合以上两个问题，5 种类型（长度 1 字节、2 字节、4 字节、8 字节、小于 1 字节）的SDS至少需要 3 位来存储类型（2^3=8），1 个字节 8 位，剩余的 5 位存储长度，可以满足长度小于 32 的短字符串。</p>

<p>在 Redis 5.0 中，我们用如下结构来存储长度小于 32 的短字符串。</p>
<pre><code class="language-C">struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 低 3 位存储类型，高 5 位存储长度 */
    char buf[];
};
</code></pre>
<p>sdshdr5 结构如下，flags 占 1 个字节，其低三位（bit）表示 type，高 5 位（bit）表示长度。能表示的长度区间为 0~31(2^5)。flags 后面就是字符串的内容。</p>

<center>   
<img src="../../img/redis/sds/sdshdr5结构.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">sdshdr5结构</div>
</center>

<p>而长度大于 31 的字符串，1 字节依然放不下。按之前的思路，将 len 和 free 单独存放。sdshdr8、sdshdr16、sdshdr32和sdshdr64的结构相同，以 sdshdr8 为例，结构如下：</p>

<center>   
<img src="../../img/redis/sds/sdshdr8结构.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">sdshdr8结构</div>
</center>

<p>其中表头共占用了 S[1(len) + 1(alloc) + 1(flags)] 个字节。flags的内容与 sdshdr5 类型，依然采用 3 位存储类型，但剩余 5 位不存储长度。</p>

<p><strong>sds源码分析</strong></p>

<p><strong>字符串创建</strong><br />
核心代码在 sds.c#sdsnewlen() :</p>
<pre><code class="language-C">/* Create a new sds string with the content specified by the 'init' pointer
 * and 'initlen'.
 * 通过init指针和initlen指定的内容创建一个新的sds字符串
 * If NULL is used for 'init' the string is initialized with zero bytes.
 * 如果init为null 字符串将被初始化为0字节
 * If SDS_NOINIT is used, the buffer is left uninitialized;
 * 如果使用SDS_NOINIT，缓冲区将不会初始化
 *
 * The string is always null-termined (all the sds strings are, always) so
 * even if you create an sds string with:
 * 字符串总是空结尾（适用于所有的sds字符串），即使你创建mystring = sdsnewlen("abc",3) 字符串
 *
 * mystring = sdsnewlen("abc",3);
 *
 * You can print the string with printf() as there is an implicit \0 at the
 * end of the string. However the string is binary safe and can contain
 * \0 characters in the middle, as the length is stored in the sds header.
 * 你可以通过printl()打印字符串，在字符串末尾会有一个隐含的 \0. 然而 字符串是二进制安全的，可以包含中间的 \0 字符，因为长度存储在sds头部
 *
 */
sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) {
    void *sh;
    sds s;
    //根据字符串长度初始化sds类型
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    //空字符串通常是为了添加而创建。使用 8 代替 5
    if (type == SDS_TYPE_5 &amp;&amp; initlen == 0) type = SDS_TYPE_8;
    //根据上一步获取的type计算header的长度
    int hdrlen = sdsHdrSize(type);
    //标志位的指针
    unsigned char *fp; /* flags pointer. */
    //已分配的空间
    size_t usable;

    assert(initlen + hdrlen + 1 &gt; initlen); /* Catch size_t overflow */
    //申请内存 大小为 头部+字符串大小+null字符串结尾
    sh = trymalloc?
        s_trymalloc_usable(hdrlen+initlen+1, &amp;usable) ://尝试分配内存，失败返回null
        s_malloc_usable(hdrlen+initlen+1, &amp;usable);//分配内存或抛出异常
    if (sh == NULL) return NULL;
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        //初始化内存 将 sh 内存块中前 hdrlen+initlen+1 个字节设置为 0
        memset(sh, 0, hdrlen+initlen+1);
    //将 s 指向字符串的首地址 即指向buf，从首地址向右偏移 hdrlen 长度
    s = (char*)sh+hdrlen;
    //fp 指向头部的最后一个字节 即flag
    fp = ((unsigned char*)s)-1;

    //已使用大小 即申请内容大小减去 头部大小 + 末尾 1 字节占位符
    usable = usable-hdrlen-1;
    if (usable &gt; sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    //根据类型初始化字符串
    switch(type) {
        case SDS_TYPE_5: {
            //sdshdr5 的 flags 的 高5bit 存放着 len， 低3bit位存放着 type
            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            sh-&gt;len = initlen;//初始化总长度
            sh-&gt;alloc = usable;//初始化已使用长度
            *fp = type;//初始化类型
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            sh-&gt;len = initlen;
            sh-&gt;alloc = usable;
            *fp = type;
            break;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            sh-&gt;len = initlen;
            sh-&gt;alloc = usable;
            *fp = type;
            break;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            sh-&gt;len = initlen;
            sh-&gt;alloc = usable;
            *fp = type;
            break;
        }
    }
    if (initlen &amp;&amp; init)
        //将 init 字符串的内容复制到 s 中
        memcpy(s, init, initlen);
    //初始化字符串结尾 占位符
    s[initlen] = '\0';
    return s;
}


/**
 * 根据字符串长度判断 sds类型
 * 1&lt;&lt;5 = 32 :      SDS_TYPE_5
 * 1&lt;&lt;5 = 256:      SDS_TYPE_8
 * 1&lt;&lt;16 = 65536:   SDS_TYPE_16
 * 1&lt;&lt;32 = 4294967296:   SDS_TYPE_32
 * else:   SDS_TYPE_64
 * @param string_size
 * @return
 */
static inline char sdsReqType(size_t string_size) {
    if (string_size &lt; 1&lt;&lt;5)
        return SDS_TYPE_5;
    if (string_size &lt; 1&lt;&lt;8)
        return SDS_TYPE_8;
    if (string_size &lt; 1&lt;&lt;16)
        return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size &lt; 1ll&lt;&lt;32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}


/**
 * 获取不同类型头部长度
 * @param type 
 * @return 
 */
static inline int sdsHdrSize(char type) {
    switch(type&amp;SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return sizeof(struct sdshdr5);
        case SDS_TYPE_8:
            return sizeof(struct sdshdr8);
        case SDS_TYPE_16:
            return sizeof(struct sdshdr16);
        case SDS_TYPE_32:
            return sizeof(struct sdshdr32);
        case SDS_TYPE_64:
            return sizeof(struct sdshdr64);
    }
    return 0;
}
</code></pre>
<p><strong>总结</strong><br />
根据字符串长度选择合适的 sds 类型并分配内存，根据字符串类型初始化 sds 。返回值是 sds 结构中 buf 的指针。<br />
<br /></p>

<p><strong>字符串扩容</strong><br />
核心代码在 sds.c#sdscat()#sdsMakeRoomFor()</p>
<pre><code class="language-C">/* Append the specified null terminated C string to the sds string 's'.
 * 将指定的以空结尾的C字符串追加到sds字符串 's'后面
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串不再有效，所有的引用必须被该调用返回的指针替代
 */
sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}

/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the
 * end of the specified sds string 's'.
 * 将指定的以空结尾的C字符串追加到sds字符串 's'后面
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串不再有效，所有的引用必须被该调用返回的指针替代
 */
sds sdscatlen(sds s, const void *t, size_t len) {
    //获取字符串 s 的长度，即取 len 属性 sds5取flags的高五位
    size_t curlen = sdslen(s);
    //字符串扩容
    s = sdsMakeRoomFor(s,len);
    if (s == NULL) return NULL;
    //将 len 长度 t 复制到 s字符串中， 从 s+curlen 位置开始
    memcpy(s+curlen, t, len);
    //更新字符串长度 即len属性， sds5更新flags的高五位
    sdssetlen(s, curlen+len);
    //末尾添加占位符
    s[curlen+len] = '\0';
    return s;
}


/* Enlarge the free space at the end of the sds string so that the caller
 * is sure that after calling this function can overwrite up to addlen
 * bytes after the end of the string, plus one more byte for nul term.
 * 扩大sds字符串末尾的可用空间，调用后可以保证在字符串结束后覆盖最多 addlen 个字节，再加上一个字节为 null 占位符
 *
 * Note: this does not change the *length* of the sds string as returned
 * by sdslen(), but only the free buffer space we have.
 * 注意：他不会改变 sds 字符串的长度，例如调用 sdslen()， 但是只有可用的缓冲空间
 */
sds sdsMakeRoomFor(sds s, size_t addlen) {
    void *sh, *newsh;
    //获取可用空间 即 len-alloc=free
    size_t avail = sdsavail(s);
    size_t len, newlen, reqlen;
    //获取 s 字符串类型 s指向buf的指针，s[-1]即为flags地址
    char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
    int hdrlen;
    size_t usable;

    /* Return ASAP if there is enough space left. */
    //如果 可用大于 addlen 直接返回
    if (avail &gt;= addlen) return s;

    //获取字符串长度
    len = sdslen(s);
    //将指针向左偏移 hdr 长度，即当前指针指向 sds头部，而不是从 buf 开始
    sh = (char*)s-sdsHdrSize(oldtype);
    //初始化新增的长度
    reqlen = newlen = (len+addlen);
    assert(newlen &gt; len);   /* Catch size_t overflow */
    //如果拼接字符串后的长度小于 1M， 则扩容为拼接字符串后长度的两倍
    if (newlen &lt; SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        //否则在拼接长度的基础上新增 1M
        newlen += SDS_MAX_PREALLOC;

    //根据最终字符串长度 获取字符串类型
    type = sdsReqType(newlen);

    /* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    //获取新字符串类型长度
    hdrlen = sdsHdrSize(type);
    assert(hdrlen + newlen + 1 &gt; reqlen);  /* Catch size_t overflow */
    //如果扩容后结构体不变
    if (oldtype==type) {
        //根据原始字符串及扩容后的长度重新分配内存，并将内容复制到新内存中，并清空原内存空间
        //usable会被设置为当前分配的大小
        newsh = s_realloc_usable(sh, hdrlen+newlen+1, &amp;usable);
        if (newsh == NULL) return NULL;
        //将 s 字符串指针指向 buf 数组
        s = (char*)newsh+hdrlen;
    } else {
        /* Since the header size changes, need to move the string forward,
         * and can't use realloc */
        //由于头部长度改变，需要向前移动字符串，不能使用内存重新分配
        //分配最新长度的内存空间，从堆上重新申请数据空间
        newsh = s_malloc_usable(hdrlen+newlen+1, &amp;usable);
        if (newsh == NULL) return NULL;
        //将 len+1 长度的 s 内容复制新内存空间中
        memcpy((char*)newsh+hdrlen, s, len+1);
        //释放原内容空间
        s_free(sh);
        //将 s 字符串指针指向 buf 数组
        s = (char*)newsh+hdrlen;
        //设置字符串类型 flags
        s[-1] = type;
        //更新新字符串长度
        sdssetlen(s, len);
    }
    //获取实际可用数据空间
    usable = usable-hdrlen-1;
    if (usable &gt; sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    //设置新字符串已使用总长度 alloc
    sdssetalloc(s, usable);
    return s;
}
</code></pre>
<p><strong>总结</strong><br />
扩容阶段：</p>
<ul>
  <li>若 SDS 中剩余空闲空间 avail 大于新增内容的长度 addlen，则无需扩容；</li>
  <li>若 SDS 中剩余空闲空间 avail 小于或等于新增内容的长度 addlen：
    <ul>
      <li>若新增后的总长度 len+addlen &lt; 1MB ，则按新长度的两倍扩容；</li>
      <li>若新增后的总长度 len+addlen &gt;= 1MB ，则按新长度加上 1MB 扩容。</li>
    </ul>
  </li>
</ul>

<p>内容分配阶段：</p>
<ul>
  <li>根据扩容后的长度选择对应的SDS类型：
    <ul>
      <li>若类型不变，则只需通过 s_realloc_usable 扩大 buf 数组即可；</li>
      <li>若类型变化，则需要为整个 SDS 重新分配内存，并将原来的 SDS 内容拷贝至新位置。</li>
    </ul>
  </li>
</ul>

<center>   
<img src="../../img/redis/sds/sdsMakeRoomFor流程图.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">sdsMakeRoomFor流程图</div>
</center>
<p><br /></p>

<p><strong>字符串释放（惰性空间释放）</strong><br />
重置len属性清空SDS在 sds.c#sdsclear()<br />
真正清空SDS在 sds.c#sdsfree()<br />
清空空闲缓存在 sds.c#sdsRemoveFreeSpace()</p>
<pre><code class="language-C">/* Modify an sds string in-place to make it empty (zero length).
 * However all the existing buffer is not discarded but set as free space
 * so that next append operations will not require allocations up to the
 * number of bytes previously available.
 * 原地修改 SDS 字符串使用为空（长度为0）
 * 但是所有的缓冲区不会被丢弃而是被设置为空闲区域，这样下一个追加操作不需要分配之前可用的字节数
 */
void sdsclear(sds s) {
    //将长度设置为0
    sdssetlen(s, 0);
    s[0] = '\0';
}

/* Free an sds string. No operation is performed if 's' is NULL.
 * 释放 sds字符串。当 s 为 NULL 时不会执行任何操作
 */
void sdsfree(sds s) {
    if (s == NULL) return;
    //s-sdsHdrSize(s[-1]):指针指向sds起始地址  s_free释放内存
    s_free((char*)s-sdsHdrSize(s[-1]));
}

/* Reallocate the sds string so that it has no free space at the end. The
 * contained string remains not altered, but next concatenation operations
 * will require a reallocation.
 * 重新分配sds字符串，使得结尾没有任何空余空间。
 * 原来包含的字符串不会改动，但是下一个串联操作将需要重新分配内存
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串将不再有效。且所有的引用将被调用返回的新指针代替
 */
sds sdsRemoveFreeSpace(sds s, int would_regrow) {
    return sdsResize(s, sdslen(s), would_regrow);
}

/* Resize the allocation, this can make the allocation bigger or smaller,
 * if the size is smaller than currently used len, the data will be truncated.
 * 调整分配大小，这可以使分配更大或更小，如果大小小于当前已使用的长度，数据将被截断
 *
 * The when the would_regrow argument is set to 1, it prevents the use of
 * SDS_TYPE_5, which is desired when the sds is likely to be changed again.
 * 当would_regrow参数为1时，它将阻止使用sds5，这是在sds可能再次更改时所需要的
 *
 * The sdsAlloc size will be set to the requested size regardless of the actual
 * allocation size, this is done in order to avoid repeated calls to this
 * function when the caller detects that it has excess space.
 * 无论实际大小多少，sdsAlloc大小都将被设置为请求的大小，这么做是为了当调用者检测到它有多余的空间时防止重复调用此方法
 */
sds sdsResize(sds s, size_t size, int would_regrow) {
    void *sh, *newsh;
    //取原sds类型
    char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
    //取原sds头部长度
    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);
    //取sds 长度
    size_t len = sdslen(s);
    //指针指向sds起始位置
    sh = (char*)s-oldhdrlen;

    /* Return ASAP if the size is already good. */
    //如果大小已经满足则直接满足  即 len=alloc
    if (sdsalloc(s) == size) return s;

    /* Truncate len if needed. */
    //如果size小于len 直接直接截断
    if (size &lt; len) len = size;

    /* Check what would be the minimum SDS header that is just good enough to
     * fit this string. */
    //根据size  重新计算sds类型
    type = sdsReqType(size);
    if (would_regrow) {
        /* Don't use type 5, it is not good for strings that are expected to grow back. */
        //不要使用type5， 它不适合那些期望增长回来的字符串
        if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    }
    //根据sds类型计算头部大小
    hdrlen = sdsHdrSize(type);

    /* If the type is the same, or can hold the size in it with low overhead
     * (larger than SDS_TYPE_8), we just realloc(), letting the allocator
     * to do the copy only if really needed. Otherwise if the change is
     * huge, we manually reallocate the string to use the different header
     * type.
     * 如果类型相同，或可以用低位表示大小（type大于8），我们只需要 realloc()，让分配器只在真正需要的时候进行复制。
     * 如果改变很大，根据不同的头部大小手动重新分配内存
     */
    //判断是需要重新分配
    int use_realloc = (oldtype==type || (type &lt; oldtype &amp;&amp; type &gt; SDS_TYPE_8));
    //若重新分配使用原类型
    size_t newlen = use_realloc ? oldhdrlen+size+1 : hdrlen+size+1;
    int alloc_already_optimal = 0;
    #if defined(USE_JEMALLOC)
        /* je_nallocx returns the expected allocation size for the newlen.
         * We aim to avoid calling realloc() when using Jemalloc if there is no
         * change in the allocation size, as it incurs a cost even if the
         * allocation size stays the same. */
        alloc_already_optimal = (je_nallocx(newlen, 0) == zmalloc_size(sh));
    #endif

    //使用重新分配内存
    if (use_realloc &amp;&amp; !alloc_already_optimal) {
        //根据newlen重新分配内存
        newsh = s_realloc(sh, newlen);
        if (newsh == NULL) return NULL;
        //指针指向 buf 缓冲区
        s = (char*)newsh+oldhdrlen;
    } else if (!alloc_already_optimal) {
        //使用新建内存空间 新分配newlen的空间
        newsh = s_malloc(newlen);
        if (newsh == NULL) return NULL;
        //将s的len长度内存复制到newsh+hdrlen中
        memcpy((char*)newsh+hdrlen, s, len);
        //释放sh
        s_free(sh);
        //指针指向 buf缓冲区
        s = (char*)newsh+hdrlen;
        //设置flgas类型
        s[-1] = type;
    }
    //设置字符串末尾占位符
    s[len] = 0;
    //更新长度
    sdssetlen(s, len);
    //更新已使用大小
    sdssetalloc(s, size);
    return s;
}
</code></pre>
<p><strong>总结</strong><br />
redis提供了三种方法清空 SDS。<br />
sdsclear：重置len属性，不直接释放内存，新的数据可以复写，而不用重新申请内存。<br />
sdsfree：通过 s_free 释放内存。<br />
sdsRemoveFreeSpace：清空未使用缓存空间，执行字符串相关指令时通过 tryObjectEncoding 触发或通过 clientsCron 定时触发。</p>

<p><br /></p>

<h5 id="为什么使用sds">为什么使用sds</h5>
<ul>
  <li>常数复杂度获取字符串长度<br />
由于len属性的存在，我们获取sds字符串的长度只需要获取len属性，时间复杂度为O(1)。而对于C语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为O(n)。通过<strong>strlen key</strong>命令可以获取key的字符串长度。</li>
  <li>杜绝缓冲区溢出<br />
在C语言中使用strcat函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间就会造成缓冲区溢出。而对于SDS数据类型，在进行字符修改的时候，会首先根据记录的len属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</li>
  <li>减少修改字符串的内存重分配次数<br />
C语言由于不记录字符串长度，所以如果要修改字符串，必须要重新分配内存，如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄漏。<br />
而对于SDS，由于len和alloc属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略:
    <ol>
      <li>空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li>
      <li>惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重分配来回收缩短后多余的字节，而是使用<strong>alloc</strong>属性将这些字节的数量记录下来，等待后续使用。</li>
    </ol>
  </li>
  <li>二进制安全<br />
因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件，内容可能包括空字符串，因此C字符串无法正确存取；而所有SDS的API都是以处理二进制的方式来处理buf里面的元素，并且SDS不是以空字符串来判断是否结束，而是以len属性表示的长度来判断字符串是否结束。</li>
  <li>兼容部分C字符串函数<br />
虽然SDS是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用C语言库 string.h 中的一部分函数。</li>
</ul>

<p><br /></p>

<h5 id="空间预分配进一步理解">空间预分配进一步理解</h5>
<p>当执行追加操作时，比如现在给key=’Hello World’的字符后追加’ again!’，则这时的len=18，free由0变成了18，此时的 buf=’Hello World again!\0………………’(.表示空格)，也就是buf的内存空间是18+18+1=37字节，其中’\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，
就无须在进行空间分配了。在当前版本中，当新字符串长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。<br />
思考：<strong>这种分配策略会浪费内存资源吗？</strong> <br />
答：执行过APPEND命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭redis之后，再次启动时重新载入的字符串对象将不会有预分配空间。
因为执行APPEND命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND操作的键很多，而字符串的体积又很大的话，那可能就需要修改redis服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p>

<p><br /></p>

<h5 id="小结">小结</h5>
<p>redis的字符串表示为sds，而不是C字符串（以\0结尾的char*），它是redis底层所使用的字符串表示，对比如下：</p>

<center>   
<img src="../../img/redis/sds/sds和c字符串对比.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">redis字符串对比图</div>
</center>

<blockquote>
  <p>https://pdai.tech/md/db/nosql-redis/db-redis-overview.html<br />
https://blog.wangjunfeng.com/post/redis-sds/<br />
https://juejin.cn/post/7064359936842530830<br />
https://www.cnblogs.com/chenchuxin/p/14189925.html<br />
https://cloud.tencent.com/developer/article/1911682<br />
https://www.cnblogs.com/chenchuxin/p/14204452.html<br />
https://juejin.cn/post/6894539895084154887<br />
https://blog.csdn.net/yangbodong22011/article/details/78419966<br />
https://www.aphysia.cn/archives/redis-2—sdsyuan-ma-fen-xi</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">July 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">redis</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-30000002" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>redisObject</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-keval-padhiyar-245700856-19915666.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>redisObject</h3>
                            
                            </div>

                            <p><center>   
<img src="../../img/redis/redisObject/redisObject.jpg" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">redisObject概览</div>
</center>

<p>    上图展示了redisObject，Redis所有数据类型、Redis所有编码方式以及底层数据结构之间的关系。<br />
    它反映了redis的每种对象其实都由 <strong>对象结构（redisObject）</strong> 与 <strong>对应编码的数据结构</strong> 组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。<br />
所以，我们需要从几个角度来研究：</p>
<ul>
  <li>对象设计机制：对象结构（redisObject）</li>
  <li>编码类型和底层数据结构：对应编码的数据结构</li>
</ul>

<h3 id="为什么设计redisobject对象">为什么设计redisObject对象</h3>

<p>    在redis的命令中，用于对键进行处理的命令占了很大一部分，而对于键所保存的值的类型（键的类型），键能执行的命令又各不相同。
如：LPUSH和LLEN只能用于列表键，而SADD和SRANDMEMBER只能用于集合键等；另外一些命令，比如DEL、TTL和TYPE，可以用于任何类型的键；但是要正确实现这些命令，
必须为不同类型的键设置不同的处理方式，比如说，删除一个列表键和删除一个字符串键的操作过程就不太一样。<br />
    故：<strong>Redis必须让每个键都带有类型信息，使得程序可以检查键的类型，并为它选择合适的处理方式。</strong><br />
    比如说，集合类型就可以由字典和整数集合两种不同的数据结构实现，但是当用户执行ZADD命令时，它不关心集合使用的是什么编码，只要Redis能按照ZADD命令的指示，将新元素添加到集合就可以了。<br />
    这说明，<strong>操作数据类型的命令除了要对键的类型进行检查之外，还需要根据数据类型的不同编码进行多态处理。</strong><br />
    为了解决以上问题，Redis构建了自己的类型系统，这个系统的主要功能包括：</p>
<ul>
  <li>redisObject对象</li>
  <li>基于redisObject对象的类型检查</li>
  <li>基于redisObject对象的显示多态函数</li>
  <li>对redisObject进行分配、共享和销毁的机制</li>
</ul>

<h3 id="redisobject数据结构">redisObject数据结构</h3>
<p>    redisObject是Redis类型系统的核心，数据库中的每个键、值以及Redis本身处理的参数，都表示为这种数据类型。</p>
<pre><code class="language-C">typedef struct redisObject {
    unsigned type:4;            //redisObject的类型    4bit
    unsigned encoding:4;        //同一种类型的不同编码方式  4bit
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or  
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
                            //记录RedisObject的访问时间信息      24bit
                            //LRU时间（相对于全局 lru_clock）
                            //LFU数据(最低有效的8位频率和最高有效的16位访问时间)
    int refcount;           //引用计数      32bit
    void *ptr;              //指向底层实现数据结构的指针     64bit
} robj;
</code></pre>

<p>redisObject占用 16 个字节( 4 + 4 + 24 + 32 + 64 = 128 位)。<br />
其中type、encoding和ptr是最重要的三个属性。</p>
<ul>
  <li>type记录了对象所保存的值的类型，它的值可能是以下常量中的一个：</li>
</ul>

<pre><code class="language-C">/* A redis object, that is a type able to hold a string / list / set */

/* The actual Redis Object */
//真正的redis对象
#define OBJ_STRING 0    /* String object. */
#define OBJ_LIST 1      /* List object. */
#define OBJ_SET 2       /* Set object. */
#define OBJ_ZSET 3      /* Sorted set object. */
#define OBJ_HASH 4      /* Hash object. */
</code></pre>
<ul>
  <li>encoding记录了对象所保存的值的编码，它的值可能是以下常量中的一个：</li>
</ul>

<pre><code class="language-C">/* Objects encoding. Some kind of objects like Strings and Hashes can be
 * internally represented in multiple ways. The 'encoding' field of the object
 * is set to one of this fields for this object.
    对象编码。像字符串和哈希这种对象内部可以有多种方式标识。 encoding字段被设置为该对象的其中一个字段
 */
#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
</code></pre>
<ul>
  <li>
    <p>ptr是一个指针，指向实际保存值的数据结构，这个数据结构由type和encoding属性决定。<br />
举个例子，如果一个redisObject的type属性为 OJB_LIST ，encoding属性为 OBJ_ENCODING_QUICKLIST，那么这个对象就是一个Redis列表（List），它的值保存在一个QuickList的数据结构内，而ptr指针就指向quickList的对象；</p>
  </li>
  <li>
    <p>lru属性：记录了对象最后一次被命令程序访问的时间<br />
    空转时长：当前时间减去键的值对象lru时间，就是该键的空转时长。Redis idletime命令可以打印出给定键的空转时长。<br />
    如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>
  </li>
</ul>

<h3 id="命令的类型检查和多态">命令的类型检查和多态</h3>

<p>当执行一个处理数据类型命令的时候，redis执行以下步骤：</p>
<ul>
  <li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li>
  <li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li>
  <li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li>
  <li>返回数据结构的操作结果作为命令的返回值；</li>
</ul>

<h3 id="对象共享">对象共享</h3>

<p>    redis一般会把一些常见的值放在一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。<br />
redis预分配的值对象如下：</p>
<ul>
  <li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE等等</li>
  <li>包括0在内，小于REDIS_SHARED_INTEGERS的所有整数</li>
</ul>

<blockquote>
  <p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等的内存数据结构。</p>
</blockquote>

<p>    为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象？</p>
<ul>
  <li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高</li>
  <li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li>
  <li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度是O(N)</li>
  <li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其他对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N^2)</li>
</ul>

<h3 id="引用计数以及对象的销毁">引用计数以及对象的销毁</h3>

<p>    redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p>
<ul>
  <li>每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；</li>
  <li>当新创建一个对象时，它的refcount属性被设置为1；</li>
  <li>当对一个对象进行共享时，redis将这个对象的rfcount加一；</li>
  <li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的rfcount减一；</li>
  <li>当对象的rfcount降至0时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放；</li>
</ul>

<h3 id="redis底层数据结构">Redis底层数据结构</h3>
<ul>
  <li>简单动态字符串 - sds</li>
  <li>压缩列表 - ZipList</li>
  <li>快表 - QuickList</li>
  <li>字典/哈希表 - Dict</li>
  <li>整数集 - IntSet</li>
  <li>跳表 - ZSkipList<br />
下面就逐一介绍下以上数据结构。</li>
</ul>

<blockquote>
  <p>https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html
https://axlgrep.github.io/tech/redis-object.html</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">June 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">redis</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-30000001" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>redis概览</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-matt-g-623574593-17392834.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>redis概览</h3>
                            
                            </div>

                            <p><h3 id="redis-为什么这么快">Redis 为什么这么快</h3>

<center>   
<img src="../../img/redis/guide/whyRedisFast.png" class="img-responsive img-centered" alt="image-alt" />
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">Why is Redis so fast</div>
</center>

<h3 id="完全基于内存">完全基于内存</h3>

<p>    redis作为一种内存导向型数据库系统，其关键特性在于将所有的数据实体，包括键值对及其相关的复杂数据结构，完全寄宿于内存之中。相较于依赖磁盘存储的传统数据库系统，redis巧妙地运用内存的高速读写特性，显著提升了系统的响应速度与整体性能表现。<br />
    内存相对于磁盘具备无可比拟的读写速度优势，使得redis能够即时、高效地处理数据存取。在读取操作层面，redis无需经过耗时的磁盘I/O过程。只需要在内存空间内迅速定位所需数据，从而显著降低了访问延迟；而在写入操作时，redis同样直接作用于内存区域，新数据能立刻生效，仅在执行持久化策略时，例如RDB快照或AOF日志记录，数据才会被异步地或按需地同步到磁盘，以确保在系统重启后数据还能恢复，但此过程并不会妨碍redis在常规操作中维持其卓越的性能表现。<br />
    服务器的内存是有限的，redis究竟是如何在有限内存空间中进行精细且高效的内存管理呢？</p>

<p><strong>过期键删除</strong><br />
    Redis支持为键设置过期时间（TTL），并且在键过期后会通过两种方式自动删除它们:</p>

<ol>
  <li>惰性删除（Lazy Expire）：
  在访问某个键时，Redis会检查该键是否已经过期，如果已经过期，则在访问时将其删除。这意味胡总只有当客户端尝试访问过期键时，Redis才会执行删除操作。这种方式的优势在于避免了不必要的操作，只有在需要时才进行删除，但缺点是可能会导致过期键在一段时间内仍然占用内存。</li>
  <li>定期删除（Active Expire）： 
  Redis周期性地（默认每秒10次）随机抽取一部分键，并检查它们的过期时间。如果发现某个键已经过期，则立即删除。这种方式可以保证过期键在一定时间内被及时删除，避免了过期键长时间占用内存。但定期删除会带来额外的CPU消耗，因为需要再每次抽取时检查键的过期时间。</li>
</ol>

<p>    这两种方式结合起来，可以有效地管理和清理过期键，保证Redis的内存使用在合理范围内。同时，我们在日常开发中可以根据具体业务场景和需求调整过期策略的配置，以达到最佳的性能和内存利用率。</p>

<p><strong>内存淘汰策略</strong><br />
    内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的maxmemory），Redis会根据预先设置的淘汰策略来选择要删除的键，从而释放内存空间。通过合理选择和配置内存淘汰策略，可以有效地管理内存使用，防止内存溢出，并保证系统的稳定性和性能。<br />
    常见的内存淘汰策略：</p>
<ol>
  <li>LRU（最近最少使用）<br />
   LRU策略会删除最近最少被访问的键。Redis会记录每个键最后一次被访问的时间戳，并定期检查这些时间戳，选择最久未被访问的键进行删除。LRU策略适用于缓存场景，通常最久未被访问的键可能是最不常用的，因此删除这些键可以释放更多的内存空间。</li>
  <li>LFU（最不经常使用）<br />
   LFU策略会删除最不经常被访问的键。Redis会记录每个键被访问的频率，并定期检查这些频率，选择访问频率最低的键进行删除。LFU策略适用于对访问频率较低的键进行淘汰，从而释放内存空间。</li>
  <li>TTL（键的过期时间）<br />
   TTL策略会删除已经过期的键。Redis会定期检查键的过期时间，并删除已经过期的键。通过设置键的过期时间，可以自动清理不再需要的数据，释放内存空间。</li>
  <li>随机删除<br />
   随机删除策略会随机选择一些键进行删除。虽然这种策略不考虑键的使用频率或过期时间，但在某些情况下可能会是一种简单且有效地淘汰方式，尤其在内存空间不足时。</li>
  <li>淘汰固定数量的键<br />
   淘汰固定数量的键策略会选择要删除的键数量，然后安装一定的规则（如LRU或LFU）来选择要删除的键。这种策略可以保证每次淘汰都释放固定数量的内存空间。</li>
</ol>

<p>当Redis的内存使用达到配置的 <strong>maxmemory</strong> 限制时，就会触发内存淘汰策略，以释放内存空间。合理选择内存淘汰策略，并根据系统的需求设置 <strong>maxmemory</strong> 参数，可以有效地管理内存使用，保证系统的稳定性和性能。通过合理配置内存限制和内存淘汰策略，可以有效地管理Redis的内存使用，保证系统在内存空间不足时能够及时释放内存，避免因内存溢出而导致系统功能下降或者崩溃。</p>

<blockquote>
  <p>修改内存 <strong>maxmemory</strong> 只需要在 <strong>redis.config</strong> 配置文件中配置 <strong>maxmemory-policy</strong> 参数即可。</p>
</blockquote>

<p><strong>内存碎片管理</strong><br />
    内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。<br />
    在Redis中，由于数据的增删改查操作不断进行，会导致内存空间中出现大量的内存碎片。这些内存碎片虽然单个很小，但如果积累起来会导致内存碎片化，降低内存利用率，影响系统的性能和稳定性。<br />
    为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：</p>
<ol>
  <li>遍历内存空间：Redis会遍历整个内存空间，检查每个内存块的状态，包含已分配和未分配的内存块。</li>
  <li>合并相邻的空闲内存块：Redis会尝试合并相邻的空间内存块，将它们合并成一个更大的内存块。这样可以减少内存碎片的数量，提高内存利用率。</li>
  <li>移动数据：如果有必要，Redis可能会将数据从一个内存块移动到另一个内存块，以便更好地组织内存空间。这个过程可能会比较耗时，因为需要将数据从一个位置复制到另一个位置。</li>
  <li>释放不再使用的内存块：最后，Redis会释放那些不再使用的内存块，以便它们可以被重新分配给新的数据。</li>
</ol>

<p>    通过定期进行内存碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化的程度，提高内存利用率，从而提高系统的性能和稳定性。但是，内存碎片整理过程可能会消耗一定的系统资源，尤其在内存碎片较多的情况下。所以，通常情况下，Redis会选择在系统负载较低的时候进行碎片整理操作。</p>

<h3 id="高效的数据结构">高效的数据结构</h3>

<p>    Redis的每种对象其实都由 <strong>对象结构（redisObject）</strong> 与 <strong>对应编码的数据结构</strong> 组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</p>

<blockquote>
  <p>https://markdown.com.cn/basic-syntax/blockquotes.html
https://www.cnblogs.com/coderacademy/p/18099027
https://redis.io/docs/latest/develop/data-types/
https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">June 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">redis</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-30000001" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-kbra-arslaner-19767896.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>DDD基础概念</h3>
                            
                            </div>

                            <p><h1 id="图例">图例</h1>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD基本概念.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="DDD基本概念" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD基本概念.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">DDD基本概念</div>
    </a>
</center>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD脑图.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="DDD脑图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD脑图.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">DDD脑图</div>
    </a>
</center>

<h1 id="基本概念">基本概念</h1>
<ul>
  <li>通用类概念
    <ol>
      <li>领域驱动设计（DDD）<br />
<strong>DDD是Domain-Driven Design的缩写，是Eric Evans于2004年提出的一种软件设计方法和理念。</strong><br />
其主要思想是利用确定的业务模型来指导业务与应用的设计和实现。主张开发人员与业务人员持续地沟通和模型的持续迭代式演化，以保证业务模型与代码实现的一致性，从而实现有效管理业务复杂度，优化软件设计的目的。</li>
      <li>模型（Model）<br />
<strong>通常，模型是对对象、人或系统的信息表示。它通过较为简单的信息结构来代表我们需要理解的复杂事物或系统。</strong><br />
地图、乐高都是模型，模型可以简化复杂事物的认知。通俗来说模型就是经验的抽象集合，平时听到的谚语、公式、定理，本质上都是一种模型。</li>
      <li>建模（Modeling）<br />
<strong>建模是构建模型的过程。</strong><br />
在软件设计过程中，通过分析业务，将业务需求使用合适的模型表示出来，是建模的任务。模型可以作为业务分析的输出，并作为软件设计的重要理论基础。比如在分析一个电商应用的业务时，抽象出订单、商品等概念，进一步定义出模型，并用合适的图例表达，往往是UML来表达。</li>
      <li>模型驱动设计（Model-Driven Design）<br />
<strong>面向模型的设计方法，优先通过识别模型来简化业务设计。</strong><br />
设计过程中，以模型的为中心，始终维护模型，并基于此指导设计。</li>
      <li>软件设计（The Software Design）<br />
<strong>软件设计从需求出发，对软件系统的整体结构、模块做出划分和规划，以便于具体代码的编写。</strong><br />
由于软件具有非结构化、准确的定义，软件设计往往通过经验完成，无法通过某种特定的推理路线严格推导实现。</li>
      <li>战略设计（Strategic Design）<br />
<strong>战略设计也称为战略建模，是指对业务进行高层次的抽象和归类，主要手段包括理清上下文和进行子域的划分。</strong><br />
战略设计关注模型的分离，其解决的问题的大的模型如何划分为小模型以及相互之间如何关联。战略设计的产出可以用于指导团队协作，使得规模巨大的软件可以被合理拆分。<br />
战略设计的产出通常为上下文图，以及模块及微服务划分。</li>
      <li>战术设计（Tactical Design）<br />
<strong>战术设计也称为战术建模，是指对特定上下文下的模型进行详细设计。</strong><br />
战术设计的对象包括聚合、实体和值对象，其目标时明确它们是什么以及相互之间有何关系。战术设计的产出可以使用UML表达的类图，需要细化到具体的属性，同时确保在代码级别可实现。</li>
      <li>软件（Software）<br />
<strong>DDD讨论下的软件是指，用于解决具体业务问题的计算机程序，既可以是单体也可以是分布式系统。</strong><br />
软件设计是DDD的最终目的，使用DDD的各种工具可以指导软件设计，最终构建出健壮、容易维护的系统。</li>
      <li>原则（Principle）<br />
<strong>为了更好的践行DDD，需要遵守几个原则：通用语言、聚焦核心域、协作共创和持续建模。</strong><br />
这些原则是为了更好的服务业务，从业务驱动模型设计。</li>
      <li>通用语言（Ubiquitous Language）<br />
<strong>通用语言是指在软件设计中，业务人员和开发人员需要使用无歧义的统一语言来对话。</strong><br />
这些语言包括对概念的统一理解和定义，以及业务人员参与到软件建模中，否则业务的变化会造成软件巨大的变化。</li>
      <li>聚焦核心域（Focus）<br />
<strong>核心域是最关键的业务逻辑，聚焦核心域决定了软件的定位和投资重心。</strong></li>
      <li>协作共创（Collaboration）<br />
<strong>协作共创是指领域专家和业务专家共同建模。</strong></li>
      <li>持续建模（Continuous）<br />
<strong>持续建模是指模型需要随业务变化而被及时更新。</strong></li>
      <li>上下文（Context）<br />
<strong>上下文是指不同语境下的概念虽然有相同的用词，可能具有不同的含义。</strong><br />
在软件设计中，因为自然语言的原因，相同的用词导致实际是不同概念，会对建模和软件设计带来误导。同时，不同的上下文也是识别模型边界的手段。</li>
    </ol>
  </li>
  <li>领域分析类概念
    <ol>
      <li>问题空间（Problem Space）<br />
<strong>待解决的业务问题的集合。</strong><br />
在DDD实践中，应该明确区分问题空间和解空间，避免混为一谈。</li>
      <li>领域（Domain）<br />
<strong>领域是业务相关知识的集合。</strong><br />
通常来说，领域就是业务知识。业务有一些内在规则，存在专业性。计算机只是业务规则的自动化。</li>
      <li>子域（Sub Domain）<br />
<strong>一个子域是领域的一部分。</strong><br />
为了降低业务理解复杂度，DDD实践中通常将领域划分为子域，通过分而治之的方法分析问题。</li>
      <li>核心域（Core Domain）<br />
<strong>核心域是指领域中最核心的部分，通常对应企业的核心业务。</strong><br />
核心域需要我们投入最大精力，进行充分的分析。因为它是企业能运转的基础。</li>
      <li>支撑域（Support Domain）<br />
<strong>支撑域是一种特殊的子域，是指为了实现核心业务而不得不开发的业务所对应的相关知识的集合。</strong><br />
例如，活动平台业务属于电商的支撑域，因为该业务对电商企业并不是必需的，其存在的意义仅在于放大利润。</li>
      <li>通用域（General Domain）<br />
<strong>通用域是另一种特殊的子域，对应的是业界已经有成熟方案的业务。</strong><br />
通用域可以看做一种特殊的支撑域，可以使用标准部件来实现，短信通知、邮件等领域问题。</li>
    </ol>
  </li>
  <li>建模类概念
    <ol>
      <li>解空间（Solution Space）<br />
<strong>解空间是一个数学概念。是指满足问题的所有约束前提下，所有可行解的集合。在DDD的上下文中，指的是所有可能的解决方案的集合。</strong><br />
解空间是相对于问题空间存在的，认识到解空间存在的好处是解空间可以通过一些方法从问题空间导出，而不是通过猜测得出的。</li>
      <li>领域模型（Model）<br />
<strong>领域模型是业务概念在程序中的一种表达方式。</strong><br />
领域模型可以用来设计和理解整个软件结构。面向对象设计中的类概念是领域模型的一种表达方式。与此类似，UML的建模方法也可以应用于在对领域模型的表达上。在DDD实践中，领域模型应当尽量简洁，能反应业务概念即可。</li>
      <li>限界上下文（Bounded context）<br />
<strong>限界上下文是有明确边界的上下文。在DDD中领域模型会被限定在限界上下文中。</strong><br />
限界上下文强调概念的一致性。虽然传统的方法学已经在追求概念的一致性，但是忽略的系统的庞大性，不论系统多庞大，在系统任何位置同一概念通用。DDD不追求全局的一致性，而是将系统拆成多块，在相同的上下文中实现概念一致性。<br />
识别上下文可以从概念的二义性着手，比如商品的概念在物流、交易、支付含义完全不一样，但具有不同内涵和外延，实际上他们处在不同上下文。<br />
限界上下文可以用于微服务划分、避免模型的不正确复用带来的问题。</li>
      <li>实体（Entity）<br />
<strong>实体是在相同限界上下文中具有唯一标识的领域模型，可变，通过标识判断同一性。</strong></li>
      <li>值对象（Value Object）<br />
<strong>值对象是一种特殊的领域模型，不可变，通过值判断同一性。</strong><br />
实体中可以使用ID标识，但是值对象用属性标识，任何属性的变化都视为新的值对象。比如一个银行账户，可以由ID唯一标识，币种和余额可以被修改但是还是同一个账户；交易单中的金额由币种和数值组成，无论修改哪一个属性，金额都不再是原来的金额。</li>
      <li>聚合（Aggregate）<br />
<strong>聚合是一组生命周期强一致，修改规则强关联的实体和值对象的集合，表达统一的业务含义。</strong><br />
聚合的意义在于让业务统一一致，在面向对象中有非常重要的价值。比如，订单中有多个订单项，订单的总价是根据订单项计算而来的。如果没有经验的开发者直接对订单项做出修改，而不是由订单统一处理业务逻辑，会造成业务的一致性问题。<br />
聚合需要在相同的上下文中，不能跨上下文。</li>
      <li>聚合根（Aggregate Root）<br />
<strong>聚合根是聚合中最核心的实体，其他的实体和值对象都从属于这个实体</strong><br />
要管理聚合必须使用一个聚合根，然后使用聚合根来实现发现、持久化聚合的作用，完成统一的业务意义。一个聚合中有且只有一个聚合根，聚合也可以只会有一个单独的实体。</li>
    </ol>
  </li>
  <li>软件设计类概念
    <ol>
      <li>模块（Module）<br />
<strong>模块是一组类或对象组成的集合。</strong><br />
在DDD实践中推荐使用限界上下文和聚合来指导模块划分。同时，如果不是特别复杂的业务逻辑也可以不遵守该模式。</li>
      <li>仓储（Repository）<br />
<strong>仓储是以持久化领域模型为职责的类。</strong><br />
仓储的目的是屏蔽业务逻辑和持久化基础设施的差异。例如，对于同样的持久化业务需求，在采用关系型数据库和非关系型数据库作为存储基础设施时的实现细节是有所不同的。<br />
软件的设计往往是围绕着对数据的修改完成的。经验不多的开发者往往会认为，软件的开发过程就是对数据库的增删改查。但实际上基于该认知的软件设计让软件难以维护。<br />
对于采用关系数据库作为存储基础设置的项目，仓储层可以被ORM实现。若不使用ORM，则需要自己实现仓储。</li>
      <li>服务（Service）<br />
<strong>服务是领域模型的操作者，负责领域内的业务规则的实现。</strong><br />
在实践中如果使用主、客体的思维来进行设计，则服务为主体，领域模型为客体。使用拟人化的方式来对服务进行命名，可以让开发者更容易理解。比如一个维护客户数据的CRM应用中，客户数据被抽象为模型：Client，对应的服务可以设计为：ClientManager。</li>
      <li>工厂（Factory）<br />
<strong>工厂是以构建领域模型（实体或值对象）为职责的类或方法。</strong><br />
工厂可以利用不同的业务参数构建不同的领域模型。对于简单的业务逻辑实现可以不使用工厂。工厂的实现不一定是类的形式，也可以是具备工厂功能的方法。<br />
在面向对象程序设计中，工厂是一种设计模型。在广义的工厂模式中，工厂可以根据不同的规则的业务需求构造不同的对象。例如在Redis连接客户端的实现中，可以使用Redis单机、哨兵、集群等不同的方式来构建Redis连接客户端。</li>
      <li>策略（Strategy）<br />
<strong>策略是业务规则的实现方式。</strong><br />
例如通知业务，可以使用不同的渠道来实现，不同渠道的实现逻辑可以认为是不同的策略。在面向对象程序设计中，策略模式也是一种设计模式，是多态的一种实现模式。<br />
策略通常会搭配着接口来设计。如果说接口是一种契约，那策略就是契约的履约方式。</li>
      <li>规格（Specification）<br />
<strong>规格是一些特殊的业务规则。通常表现为用于校验、查询和搜索条件。</strong><br />
在实践中，规则可以被设计为灵活的查询或校验条件，也可以被抽象出来以便复用。<br />
例如，在JPA、MongoDB、ElasticSearch和一些具有查询能力的ORM都大量使用这种设计方式，同样的在应用程序中我们也可以参考这种设计模式，把业务规则提取处理。</li>
      <li>分层架构<br />
<strong>分层架构是指在软件设计过程中按照既定的原则将不同的功能实现拆分到不同的层级进行实现的一种设计方式。每个层级有独立的职责，多个层次协同以提供完整功能。按照DDD的分层模型，通常可以划分为：接入层、应用层、领域层、基础设施层。</strong><br />
分层架构在具体的软件中可以表现为不同的形式。例如，在分布式系统中，不同层级的软件实现，可以表现为独立部署的服务。而在单体系统中，分层可以用不同的模块或包来实现。<br />
分层架构的设计理念与计算机网络的层级结构类似，上层依赖下层的实现，而下层实现无需关心上层实现。例如,HTTP协议构建TCP协议之上，TCP协议只负责提供传输层的能力，而不需要知道具体的应用层协议。<br />
分层架构中层级的数量需要依照系统复杂度来定，并不需要死板地按照DDD推荐的四层来进行设计。在简单的系统中，可以通过减少分层来避免样板代码，减少冗余。例如在web系统中有时候只有一种接入方式，接入层和应用层能力高度重叠，可以考虑直接使用应用层替代接入层。<br />
软件框架的使用，通常会引入新的层级，从而影响系统整体的分层架构。例如，ORM框架本身就提供了对Repository的一层抽象。</li>
      <li>接入层（Interface）<br />
<strong>接入层负责的是系统的输入和输出。</strong><br />
接入层只关心沟通协议，不关心业务相关的数据校验。接入层的实现是与业务应用强相关的，不同的业务应用有不同的实现方式。例如，对于普通的Web应用，基于HTTP协议的API是一种接入层实现方式。<br />
接入层特点：</li>
    </ol>
    <ul>
      <li>接入层对应用数据透明，只关心数据格式而不关心数据的内容</li>
      <li>在大部分单体系统中接入层通常被框架实现。例如，在SpringBoot框架中，HTTP协议的API设计不需要关注HTTP协议本身。</li>
      <li>在分布式系统中接入层通常被网关实现。  <br />
    9. 应用层（Application）<br />
<strong>应用层，组织业务场景，编排业务，隔离场景对领域层的差异。</strong><br />
应用层遵循面向对象核心思想中的关注点分离概念。应用层的关注点在于业务场景的处理。例如：对于一个服务多种类型用户的应用，toC的网页界面和后台管理页面对应的是不同的业务场景。对于新用户注册这个业务来说，
通过ToC的网页注册和通过后台管理页面进行注册是不同的业了务场景。然而，用户注册在系统层面的基本逻辑是一样的。所以，用户注册的基本业务逻辑可以交由领域层来实现。而两种不同渠道进行用户注册所需要进行的身份验证等逻辑，
可以设计在应用层进行实现。这样便能达到关注点分离，复用核心业务逻辑的目的。<br />
应用层的特点：</li>
      <li>关心处理完一个完整的业务</li>
      <li>该层只负责业务编排，对象转换，而具体的业务逻辑由领域层实现</li>
      <li>虽然不关心请求从何处来，但关心谁来、做什么、有没有权限做</li>
      <li>利用不同的领域服务来解决问题</li>
      <li>对最终一致性有要求的业务和事务处理需要放到应用层来处理</li>
      <li>功能权限放到这层<br />
    10. 领域层（Domain）<br />
<strong>领域层，实现具体的业务逻辑、规则，为应用层提供无差别的服务能力。</strong><br />
实际处理业务的地方，领域层需要对应用层提供无差别的服务和能力。例如，对于用户注册的场景，用户既可以通过邮箱自己注册，也可以由管理员在后台进行添加。用户注册的核心逻辑可以由领域层完成，但是对于不同渠道进行用户注册的参数校验和权限验证等逻辑则由应用层实现。<br />
领域层的特点：</li>
      <li>不关心场景，关心模型完整性和业务规则</li>
      <li>不关心谁来，不关心场景完整的业务，关心当前上下文的业务完整</li>
      <li>强一致性事务放到此层，聚合的事务是理所当然的</li>
      <li>对应到分布式系统中的domain service、后台等概念</li>
      <li>领域层做业务规则验证</li>
      <li>数据权限放到这层（比如只允许删除自己创建的商品），因为数据权限涉及业务规则</li>
      <li>根据业务情况，参考反范式理论，跨上下文使用只对象做必要的数据冗余<br />
    11. 基础设施层（Infrastructure）<br />
<strong>基础设施层，提供具体的技术实现，比如存储，基础设施对业务保持透明。</strong><br />
对于基础设施层来说，基础设施层并不是指Mysql、Redis等外部组件，而是外部组件的适配器，Hibernate、Mybatis、Redis Template等，因此再DDD中适配器模式被多次提到，基础设施层往往不能单独存在，还是要依附于领域层。基础设施层的适配器还包括了外部系统的适配，互联网产品系统的外部系统非常多，常见的有活体检测、风控系统、税务发票等。<br />
基础设施层的特点：</li>
      <li>关心存储、通知、第三方系统等外部设施</li>
      <li>基础设施的权限由配置到应用的凭证控制，例如数据库、对象存储的凭证，基础设施层不涉及用户的权限<br />
    12. 部署架构<br />
<strong>部署架构是指具体的架构实现。</strong><br />
主要是在分布式系统、单体系统，甚至在客户端软件中体现。<br />
把逻辑架构和部署构架区分开可以很好的理解软件设计上和部署上的不同，对于应用架构来说，逻辑上的设计不一定对应部署架构。<br />
这样就很好理解DDD在不同场合中的使用方式，避免生搬硬套。当DDD的分层结构在单体应用中使用时，每层可能使用包、模块来表达，在微服务中使用时，每层可能由不同角色的微服务来完成。<br />
    13. 微服务（Micro Service）<br />
<strong>微服务是一种低耦合的分布式应用系统。</strong><br />
维基百科的定义是：一种软件开发技术-面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。这个定义没有问题，但是忽略了一个重要的信息，微服务是一种分布式架构，微服务必须面对分布式系统的各种问题。<br />
分布式系统是通过计算机网络连接、协同工作的IT系统，因此使用DDD时候，需要为这种系统做适配，而不是简单的做出切分。<br />
    14. 单体（Monomer）<br />
<strong>单体是主要业务实现和部署在单一服务器上的应用。</strong><br />
单体系统是相对于微服务来说的，其特点是主要的实现在单一的服务器中。<br />
    15. 分布式应用系统（Distributed）<br />
<strong>分布式应用系统是建立在计算机网络之上的应用软件系统，不同单元通过计算机网络集成。</strong></li>
    </ul>
  </li>
  <li>事件风暴类概念
    <ol>
      <li>事件风暴（Event Storming）<br />
<strong>事件风暴是一种以工作坊的形式，使用DDD建模的方式。</strong><br />
事件风暴是一种捕获行为需求的方法，类似传统软件的开发用例分析。所有人员（领域专家和技术专家）对业务行为进行一次发散，并最终收敛达到业务的统一。</li>
      <li>领域事件（Domain Event）<br />
<strong>事件是系统状态发生的某种客观现象，领域事件是和领域有关的事件。</strong><br />
领域事件是在业务上真实发生的客观事实，这些事实对系统会产生关键影响，是观察业务系统变化的关键点。领域事件一般是领域专家关心的。<br />
事件的评价方式是系统状态是否发生变化。系统状态变化意味着领域模型被业务规则操作，这是观察系统业务的好办法。<br />
识别领域事件的线索有：</li>
    </ol>
    <ul>
      <li>是否产生了某种数据</li>
      <li>系统状态是否发生改变，无论这种状态存放到数据库还是内存</li>
      <li>是否对外发送了某些消息<br />
    3. 业务规则（Policy）<br />
<strong>业务规则是指对业务逻辑的定义和约束。</strong><br />
不同的业务规则往往意味着不同的领域事件被触发，未来在技术实现时可能是一些分支条件，对应DDD实现中可能通过领域服务、规格、策略等方式实现。<br />
业务规则的识别是为了将数据和算法分开。<br />
    4. 命令（Command）<br />
<strong>命令时执行者发起的操作，构成要件是执行者和行为。</strong><br />
命令可以类比于UML分析中的业务用例，是某个场景中领域事件的触发动作。<br />
    5. 执行者（Actor）<br />
<strong>执行者是指使用系统的主体，是导致系统状态变化的触发源。</strong><br />
执行者有点像UML的涉众，不过区别是执行者不仅是用户，还包括外部系统和本系统。在事件风暴中，执行者可以是：用户、外部系统、本系统、定时器。<br />
    6. 用户（User）<br />
<strong>用户是执行者的一种，是指使用软件或服务的人。</strong><br />
用户可以有不同的角色，通常我们会把不同角色的相似行为作为不同的命令来处理，有可能得到同样的事件。<br />
    7. 外部系统（Out System）<br />
<strong>外部系统是执行者的一种，系统开放API的调用发起者。</strong><br />
有一些系统会提供对外的API给外部系统，这时候外部系统也会发出命令让系统产生事件，这里的外部系统特指作为执行者的外部系统。<br />
    8. 本系统（System）<br />
<strong>本系统是执行者的一种，指系统本身。</strong><br />
事件的触发可以由用户、外部系统、定时器触发，也可以由上一个事件触发，因此这里的触发者是系统本身。<br />
    9. 定时器（Timer）<br />
<strong>定时器是执行者的一种，通常是定时任务。</strong><br />
定时器可以作为执行者，不过需要区别于本系统这个触发源。定时器可以看待为外部一个时间信号源，类似于计算机中主机中的振荡器。<br />
    10. 参与人（Participants）<br />
<strong>作为工作坊的参与人员（应区别于执行者）</strong><br />
参与人只是一种角色，而非具体的一个人，可以多个自然人做群体参与，也可以一人一人分饰不同的角色。<br />
在开始工作坊之前，参与人需要满足一些条件：</li>
      <li>参与人需要对解决的问题和产出目标达成共识</li>
      <li>参与人需要DDD的基本知识或接受过基本培训</li>
      <li>领域专家、技术专家需要能全程参加<br />
    11. 领域专家（Domain Expert）<br />
<strong>领域专家是指熟悉业务规则的人，在工作坊中一般是能敲定业务规则的人。</strong><br />
在实际的事件风暴工作坊中，领域专家是一个比技术专家更难获得的人，一个合格的、能让工作坊进展下去的领域专家需要有几个要求：
    1. 了解现有业务情况
    2. 能对具体的业务方向做出结论性的输出
在做工作坊时，需要分清现状（As-IS）和目标（To-Be）业务，现状业务很多人能说出来，不过真正的领域专家能对目标业务做出描述的人。<br />
    12. 技术专家（Tech Expert）
<strong>技术专家是指熟悉技术方案和实现方式的人，能给出可行的技术方案和了解基础设计的限制条件。</strong><br />
技术专家需要能对现有的技术做出描述，而未来的技术选型可能是动态的，能有一定预见性最好。技术专家往往是当前团队中最熟悉架构和代码的人。<br />
    13. 主持人（Facilitator）<br />
<strong>主持人是工作坊流程的推动者，以及DDD方法论的守护者。</strong><br />
在一些工作坊中，主持人往往是外部的咨询师，他们有大量的实践经验，需要能对DDD的概念、方法有成体系的研究，并能推动工作坊进行。</li>
    </ul>
  </li>
</ul>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">DDD</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">Jan 2024</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">DDD</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000021" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>BitOperation</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-muhammet-cengiov-19017576.jpg" class="img-responsive img-centered" alt="BitOperation">

                            
                                <h3>位运算</h3>
                            
                            </div>

                            <p><h4 id="常见运算符">常见运算符</h4>
<ul>
  <li>按位与 &amp;<br />
  两个操作数相应的二进制位都为1，结果为1，反之为0。</li>
  <li>按位或 |<br />
  两个操作数相应的二进制位只要有一个为1，结果为1，反之为0。</li>
  <li>按位异或 ^<br />
  两个操作数相应的二进制位值只要相同，运算结果为0，反之为1。</li>
  <li>按位取反 ~<br />
  单目运算符，只有一个操作数，是将操作数相应的二进制位数取反。</li>
  <li>左移 «  
  将一个数的各二进制位左移若干位，移动的位数由右操作数指定。</li>
  <li>右移 »<br />
  与左移相反</li>
  <li>二进制数最低位1和后面所有0组成的 \(2^k\) lowbit<br />
  将x的二进制所有位全部取反，再加1，就可以得到 -x 的二进制编码。例如6的二进制编码是 110 ，全部取反后得到 001，加1得到010。<br />
  设原先x的二进制编码是 (…)10…00，全部取反后得到[…]01…11，加1后得到[…]10…00，也就是-x的二进制编码。这里x表示二进制中第一个1是x最低位的1。<br />
  (…)和[…]中省略号的每一位分别相反，所以 x&amp;-x = (…)10…00 &amp; […]10…00 = 10…00，得到的结果就是 lowbit。</li>
</ul>

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Sort</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">October 2023</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000020" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>MathemticalFormula</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-tim-mossholder-3308750.jpg" class="img-responsive img-centered" alt="Euclidean">

                            
                                <h3>数学公式</h3>
                            
                            </div>

                            <p><h3 id="数学公式">数学公式</h3>

<ul>
  <li>
    <h4 id="等差数列">等差数列</h4>

    <ul>
      <li>定义式
https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/1129192?fr=ge_ala</li>
    </ul>
  </li>
  <li>
    <h4 id="等比数列">等比数列</h4>
  </li>
  <li>
    <h4 id="排列组合">排列组合</h4>
  </li>
</ul>

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Sort</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">October 2023</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000019" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>Algorithm Tips</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-valentin-stenglein-18640944.jpg" class="img-responsive img-centered" alt="Euclidean">

                            
                                <h3>算法小技巧</h3>
                            
                            </div>

                            <p><h3 id="常用算法小技巧">常用算法小技巧</h3>

<ul>
  <li>
    <h4 id="向下取整">向下取整</h4>
    <p>  向下取整函数floor(val)的结果是小于或等于val的最大整数。<br />
  例如:求x除以3的向下取整数字，直接除以3即可</p>
  </li>
  <li>
    <h4 id="向上取整">向上取整</h4>
    <p>  向上取整函数ceil(val)的结果是大于或等于val的最小整数。将其转化为向下取整思路，先将x加上要除以的n-1，再除以n即可。<br />
  例如:求x除以3的向上取整数字，为避免浮点数运算，需要先将x加2再直接除以3，即ceil((x/3)=(x+2)/3</p>
  </li>
</ul>

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Sort</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">October 2023</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000001" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-hannah-luo-18540208.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>Mysql基本数据类型</h3>
                            
                            </div>

                            <p><h1 id="mysql基本数据类型">Mysql基本数据类型</h1>

<h2 id="数值类型">数值类型</h2>
<h3 id="整数类型">整数类型</h3>
<p>  数值型数据类型主要用来存储数字,Mysql提供了多种数值数据类型,不同的数据类型提供不同的取值范围,可以存储的值范围越大,其所需要的存储空间也会越大.<br />
  mysql主要提供的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT.整数类型的属性字段可以添加AUTO_INCREMENT自增约束条件.</p>

<ul>
  <li>数据范围</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Storage(Bytes)</th>
      <th>Minimum Value Signed</th>
      <th>Minimum Value Unsigned</th>
      <th>Maximum Value Signed</th>
      <th>Maximum Value Unsigned</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TINYINT</td>
      <td>1</td>
      <td>-128</td>
      <td>0</td>
      <td>127</td>
      <td>255</td>
    </tr>
    <tr>
      <td>SMALLINT</td>
      <td>2</td>
      <td>-32768</td>
      <td>0</td>
      <td>32767</td>
      <td>65535</td>
    </tr>
    <tr>
      <td>MEDIUMINT</td>
      <td>3</td>
      <td>-8388608</td>
      <td>0</td>
      <td>8388607</td>
      <td>16777215</td>
    </tr>
    <tr>
      <td>INT</td>
      <td>4</td>
      <td>-2147483648</td>
      <td>0</td>
      <td>2147483647</td>
      <td>4294967295</td>
    </tr>
    <tr>
      <td>BIGINT</td>
      <td>8</td>
      <td>\(-2^63\)</td>
      <td>0</td>
      <td>2^63 - 1</td>
      <td>2^64 - 1</td>
    </tr>
    <tr>
      <td>FLOAT</td>
      <td>4</td>
      <td>-3.402823466E+38</td>
      <td>1.175494351E-38</td>
      <td>-1.175494351E-38</td>
      <td>3.402823466E+38</td>
    </tr>
    <tr>
      <td>DOUBLE</td>
      <td>8</td>
      <td>-1.7976931348623157E+308</td>
      <td>2.2250738585072014E-308</td>
      <td>-2.2250738585072014E-308</td>
      <td>1.7976931348623157E+308</td>
    </tr>
  </tbody>
</table>

<p>示例:<br />
<code class="language-plaintext highlighter-rouge">int(4)</code><br />
该声明指明,该字段中的数据一般只显示4位数字.</p>

<p>注意点:</p>
<blockquote>
  <p>显示宽度和数据类型取值范围是无关的。显示宽度只是指明mysql最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充；如果掺入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且可以显示出来。 <br />
例如:向year字段插入一个数值12345，当使用select查询该列值的时候，mysql显示的将是完整的带有5位数字的12345，而不是4位数字的值。<br />
其他整数型数据类型也可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度。  <br />
显示宽度只用于显示，并不能限制取值范围和占用空间。</p>
</blockquote>

<p>不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应该根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。</p>

<h3 id="浮点数类型和定点数类型">浮点数类型和定点数类型</h3>
<p>mysql中使用浮点数和定点数表示小数。<br />
浮点数类型有两种:</p>
<ul>
  <li>单精度浮点类型(FLOAT)</li>
  <li>双精度浮点类型(DOUBLE)</li>
</ul>

<p>定点数类型只有一种:</p>
<ul>
  <li>DECIMAL</li>
</ul>

<p>浮点数类型和定点数类型都可以用(M, N)来表示。其中，用M称为精度，表示总共的位数；N称为标度，表示小数的位数。<br />
DECIMAL类型不同于FLOAT和DOUBLE，DECIMAL实际是以串存放的，可能的最大取值范围和DOUBLE一样，但是其有效的取值范围由M和D的值来决定。如果改变M而固定D，则取值范围将随着M的变大而变大。</p>

<p>注意点:</p>
<blockquote>
  <p>无论是定点数还是浮点数类型，如果用户指定的精度超出精度范围，则会四舍五入。<br />
FLOAT和DOUBLE在不指定精度操作时，默认会按照实际的精度(由计算机硬件和操作系统决定)，DECIMAL若不指定精度则默认为(10, 0);<br />
在mysql中，定点数以字符串形式存储，在对精度要求比较高的时候，使用DECIMAL的类型比较好，另外，两个浮点数进线减法和比较运算时，容易出现问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p>
</blockquote>

<p>参考链接:</p>
<blockquote>
  <p>https://dev.mysql.com/doc/refman/5.7/en/numeric-types.html<br />
https://zhuanlan.zhihu.com/p/543865001</p>
</blockquote>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">Sep 2023</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">mysql</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000020" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>Morris Traversing</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-thiago-matos-4037037.jpg" class="img-responsive img-centered" alt="Morris Traversing">

                            
                                <h3>莫里斯遍历</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />
<p>  对于二叉树的遍历我们常用的方法就是迭代和递归遍历，两种遍历方式使用压栈的方式，递归调用的是虚拟机的栈，迭代使用的是自定义的栈，两者的空间复杂度都为 <strong>O(n)</strong> 。<br />
  为了追求极致的效率,莫里斯遍历应运而生,它使用一种巧妙的方式将空间复杂度降为 <strong>O(1)</strong> .下面我们就一起来看看如何巧妙:</p>
<hr />

<h3 id="基本思路">基本思路</h3>
<hr />
<p>  遍历过程中用到的两个概念先说明一下,当前遍历的根节点用 <strong>node</strong> 来表示,当前根节点左子树中的最右节点 <strong>pre</strong> .<br />
从当前根节点 <strong>node</strong> 开始遍历:</p>
<ol>
  <li>若当前根节点 <strong>node</strong> 的左节点为空,将当前根节点的右节点指向当前根节点 <strong>node = node.right</strong> ,说明不存在左子树,即左子树遍历结束,开始遍历右子树(这里之所以遍历右子树,因为在第二步中已经将右子树和最近的一个根节点建立连接形成环)</li>
  <li>若当前根节点 <strong>node</strong> 的左节点不为空,将当前根节点的左节点指向最右节点 <strong>pre = node.left</strong> ,从当前根节点的左节点继续向右遍历一直到底,因为会通过步骤2.1形成环,所有这里的结束条件为右节点为空或右节点等于当前根节点,判断最右节点的右节点 <strong>pre.right</strong> 是否为空:
    <ul>
      <li>2.1 若最右节点的右节点 <strong>pre.right</strong> 为空,将最右节点的右节点指向根节点 <strong>pre.right = root</strong> ,继续遍历当前根节点的左子树 <strong>node = node.left</strong> ,说明此最右节点与当前根节点形成环,成环并继续从当前根节点向左遍历</li>
      <li>2.2 若最右节点的右节点 <strong>pre.right</strong> 不为空,将最右节点的右节点指向空 <strong>pre.right = null</strong> ,继续遍历当前根节点的右子树 <strong>node = node.right</strong> ,说明此时遇到步骤2.1生成的环了,将环断开并继续从当前根节点向右遍历</li>
    </ul>
  </li>
</ol>

<p>  可见的莫里斯遍历的核心思想就是将根节点与根节点左子树中的最右节点相连接形成环,这样在遍历的时候就可以重新回到根节点,无须借助其他数据结构降低空间复杂度.</p>
<hr />

<h3 id="遍历过程">遍历过程</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/莫里斯遍历.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="莫里斯遍历" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/莫里斯遍历.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">莫里斯遍历</div>
    </a>
</center>
<hr />

<h3 id="例题">例题</h3>
<hr />
<p>1.<a href="https://leetcode.cn/problems/recover-binary-search-tree/">恢复二叉搜索树</a></p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/恢复二叉搜索树.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="恢复二叉搜索树" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/恢复二叉搜索树.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">恢复二叉搜索树</div>
    </a>
</center>

<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">morris</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
    <span class="nc">TreeNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
        <span class="c1">//判断当前节点是否有左子树</span>
        <span class="c1">// 1.有则说明左子树未遍历完继续遍历左子树,再根据最右节点进行判断</span>
        <span class="c1">// 2.无则说明左子树遍历完,取当前节点值,并继续遍历右子树</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//pre意在找到当前节点左子树中的最右节点</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="c1">//若 pre存在右节点 &amp;&amp; pre的右节点不等于当前遍历的根节点 (因为在下一步若pre不存在右节点会将pre的右节点指向当前节点x形成一个环)</span>
            <span class="k">while</span><span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="n">root</span><span class="o">){</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//1.若pre最右节点不存在右节点(也可以理解为未指向其根节点形成环),则将pre的右节点指向根节点形成环,并继续遍历根节点的左子树</span>
            <span class="c1">//2.若pre最右节点存在右节点(可以理解为已经指向根节点形成环了),取当前root值并将pre最右节点置为null(即将环断开),继续遍历右子树 (若经过步骤1成环了,即变成从子节点回到根节点)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
<span class="c1">//                    //先序遍历</span>
<span class="c1">//                    res.add(root.val);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//中序遍历</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(n)<br />
空间复杂度为:O(1)</p>
</blockquote>

<h3 id="延伸-后序遍历">延伸-后序遍历</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/莫里斯后序遍历.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="莫里斯后序遍历" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/莫里斯后序遍历.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">莫里斯后序遍历</div>
    </a>
</center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>


<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">morrisPostOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//自定义头结点形成环</span>
    <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="nc">TreeNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">TreeNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="n">pre</span><span class="o">){</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">next</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">next</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="c1">//使用头插法在断开环时将右节点和根节点加入结果汇总</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">res</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">August 2022</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000019" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>Reservoir Sampling</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-emmanuel-hernndez-12217674.jpg" class="img-responsive img-centered" alt="ReservoirSampling">

                            
                                <h3>蓄水池采样算法</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />
<p>  给定一串很长的数据流,对该数据流中数据只能访问一次,使得数据流中所有数据被选中的概率相等.<br />
  解决这样的问题,就可以利用蓄水池算法(Reservoir Sampling).</p>
<hr />

<h3 id="基本思路">基本思路</h3>
<hr />
<p>  假设需要采样的数量为 <strong>k</strong> .</p>
<ol>
  <li>首先构建一个 <strong>k</strong> 个元素的数组,将序列前的 <strong>k</strong> 个元素放入数组中.</li>
  <li>对于从第 <strong>j</strong> 个元素 <strong>(j&gt;k)</strong> ,以 <strong>$\frac{k}{j}$</strong> 的概率来决定该元素是否被替换到数组中,数组中的 <strong>k</strong> 个元素被替换的概率是相同的.</li>
  <li>当遍历完所有元素之后,数组中剩下的元素即为采样样本.
    <hr />
  </li>
</ol>

<h3 id="证明过程">证明过程</h3>
<hr />
<ol>
  <li>对于第 <strong>i</strong> 个元素 <strong>(i&lt;k)</strong> .在 <strong>k</strong> 步之前,被选中的概率为1.
当走到第 <strong>k+1</strong> 步时,被 <strong>k+1</strong> 个元素替换的概率 = 第 <strong>k+1</strong> 个元素被选中的概率 <strong>$\times$</strong> <strong>i</strong> 被选中替换的概率,即 <strong>$\frac{k}{k+1} \times \frac{1}{k} = \frac{1}{k+1}$</strong> .<br />
那么,不被第 <strong>k+1</strong> 个元素替换的概率为 <strong>$1-\frac{1}{k+1} = \frac{k}{k+1}$</strong> .以此类推,不被 <strong>k+2</strong> 个元素替换的概率为 <strong>$1-\frac{k}{k+2} \times \frac{1}{k} = \frac{k+1}{k+2}$</strong> .<br />
当递推到第 <strong>n</strong> 个元素时,第 <strong>i</strong> 个元素被保留的概率 = 被选中的概率 <strong>$\times$</strong> 不被替换的概率,即 <strong>\[1 \times \frac{k}{k+1} \times \frac{k+1}{k+2} \times \frac{k+2}{k+3} … \times \frac{n-1}{n} = \frac{1}{n}\]</strong></li>
  <li>对于第 <strong>j</strong> 个元素 <strong>(j&gt;k)</strong> . 在第 <strong>j</strong> 步被选中的概率为 <strong>$\frac{k}{j}$</strong> ,不被 <strong>j+1</strong> 个元素替换的概率为 <strong>$1- \frac{k}{j+1} \times \frac{1}{k}$</strong> ,当递推到第 <strong>n</strong> 个元素时,被保留的概率 = 被选中的概率 * 不被替换的概率，即 <strong>\[\frac{k}{j} \times \frac{j}{j+1} \times \frac{j+1}{j+2} … \times \frac{n-1}{n} = \frac{k}{n}\]</strong> 因此对于每个元素,被保留的概率都是 <strong>$\frac{k}{n}$</strong>
    <hr />
  </li>
</ol>

<h3 id="理解过程">理解过程</h3>
<hr />
<p>  遍历长度等于 <strong>n</strong> 的数组.当第 <strong>i</strong> 次遇到 <strong>target</strong> 的元素时,随机选择区间 <strong>[0, i)</strong> 内的一个整数,如果其等于 <strong>0</strong> ,则将返回值置为该元素的下标,否则返回值不变.<br />
  设nums中有 <strong>k</strong> 个值为 <strong>target</strong> 的元素,该算法会保证这 <strong>k</strong> 个元素的下标最终返回值概率均为$\frac{1}{k}$,证明如下<br />
P(第i次遇到值为target的元素下标称为最终返回值) = P(第i次随机选择的值=0) <strong>$\times$</strong> P(第i+1次随机选择的值!=0) <strong>$\times…\times$</strong> P(第k次随机选择的值!=0)</p>

\[\frac{1}{i} \times (1-\frac{1}{i+1}) \times...\times(1-\frac{1}{k}) = \frac{1}{i} \times \frac{i}{i+1} \times...\times \frac{k-1}{k} = \frac{1}{k}\]

<hr />

<h3 id="例题">例题</h3>
<hr />
<p>1.<a href="https://leetcode.cn/problems/random-pick-index/">随机数索引-随机选一个数</a></p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/reservoirSampling/随机数索引.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="随机数索引" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/reservoirSampling/随机数索引.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">随机数索引</div>
    </a>
</center>

<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">num</span><span class="o">;</span>
    <span class="nc">Random</span> <span class="n">random</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
        <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pick</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(++</span><span class="n">count</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(n)<br />
空间复杂度为:O(1)</p>
</blockquote>

<ol>
  <li>随机选k个数
    <blockquote>
      <p>java</p>
    </blockquote>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">selectK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
    <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(++</span><span class="n">count</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">k</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">i</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>时间复杂度:O(n)<br />
空间复杂度度:O(1)</p>
</blockquote>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//随机选一个数</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">;</span>

<span class="nl">public:</span>
		<span class="n">Solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="o">:</span> <span class="n">nums</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="p">{}</span>

		<span class="kt">int</span> <span class="n">pick</span><span class="p">(</span><span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="o">++</span><span class="n">count</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">res</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">};</span>

<span class="c1">//随机选K个数</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">selectK</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="o">++</span><span class="n">count</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">res</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">//</span><span class="n">随机选一个数</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nums</span> <span class="o">=</span> <span class="n">nums</span>

    <span class="k">def</span> <span class="nf">pick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">randrange</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">ans</span>
        
<span class="o">//</span><span class="n">随机选K个数</span>        
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="nf">selectK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="o">++</span><span class="n">count</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//随机选一个数</span>
<span class="k">type</span> <span class="n">Solution</span> <span class="p">[]</span><span class="kt">int</span>

<span class="k">func</span> <span class="n">Constructor1</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="n">Solution</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">nums</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">nums</span> <span class="n">Solution</span><span class="p">)</span> <span class="n">Pick</span><span class="p">(</span><span class="n">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">res</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">count</span><span class="o">:=</span><span class="m">0</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span><span class="p">{</span>
		<span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
			<span class="n">count</span><span class="o">++</span>
			<span class="k">if</span> <span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">i</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c">//随机选K个数</span>
<span class="k">func</span> <span class="n">SelectK</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">res</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">{</span>
		<span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="n">count</span><span class="o">:=</span><span class="n">k</span>
	<span class="n">i</span><span class="o">:=</span><span class="n">k</span>
	<span class="k">for</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span>
		<span class="n">j</span> <span class="o">:=</span> <span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">{</span>
			<span class="n">res</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">June 2022</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000018" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>Euclidean Algorithm</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-alexey-demidov-11341064.jpg" class="img-responsive img-centered" alt="Euclidean">

                            
                                <h3>欧几里得算法</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />
<p>  欧几里得算法又称辗转相除法,是指用于计算两个非负整数a、b的最大公约数.</p>
<hr />

<h3 id="基本思路">基本思路</h3>
<hr />
<p>定理:<br />
  两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数.最大公约数(Greatest Common Divisor)缩写GCD.<br />
原理:<br />
  gcd(a, b) = gcd(b, a mod b)<br />
条件:<br />
  a&gt;b 且 a mod b 不为0</p>
<hr />

<h3 id="示例">示例</h3>
<hr />
<p>假如需要求1997和615两个正整数的最大公约数,用欧几里得算法进行:</p>
<ol>
  <li>1997/615 = 3 (余152)</li>
  <li>615/152 = 4 (余7)</li>
  <li>152/7 = 21 (余5)</li>
  <li>7/5 = 1 (余2)</li>
  <li>5/2 = 2 (余1)</li>
  <li>2/1 = 2 (余0)</li>
</ol>

<p>至此余数为0,取最后一个被除数b即为1,所以最大公约数为1.<br />
以除数和余数反复做除法运算,当余数为0时,取当前算式除数为最大公约数,所以1997和615的最大公约数为1.</p>
<hr />

<h3 id="代码">代码</h3>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="n">a</span> <span class="n">mod</span> <span class="n">b</span><span class="o">)</span>
 
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">gcd</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Sort</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">March 2022</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-100000017" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>HashTable</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-nuta-sorokina-10005736.jpg" class="img-responsive img-centered" alt="hashTable">

                            
                                <h3>散列表</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />

<p>  根据关键码值(Key Value)而直接进行访问的数据结构.也就是说,它通过把关键码值映射到表中一个位置来访问记录,以加快查找的速度.这个映射函数叫做散列函数,存放记录的数组叫做散列表.<br />
  使用散列的查找算法分为两步,第一步是用散列函数将被查找的键转化为数组的一个索引;第二步就是一个处理碰撞冲突的过程,接下来将介绍两种解决碰撞的方法:拉链法和线性探测法.</p>
<hr />

<h3 id="散列函数">散列函数</h3>
<hr />
<p>  如果我们有一个能够保存M个键值对的数组,那么我们就需要一个能够将任意键转化为该数组范围内的索引([0,M-1]范围内的整数)的散列函数.
我们要找的散列函数应该易于计算并且能够均匀分布所有的键,即对于任意键,0到M-1之间的每个整数都有相等的可能性与之对应.<br />
  散列函数和键的类型有关,严格地说,对于每种类型的键我们都需要一个与之对应的散列函数.<br />
  主要介绍一下几种类型:</p>
<ol>
  <li>正整数<br />
  将整数散列最常用的方法是除留余数法.我们选择大小为素数M的数组,对于任意正整数k,计算k除以M的余数.这个函数的计算非常容易(在Java中为k%M)并能够有效地将键散布在0到M-1的范围内.
如果M不是素数,我们可能无法利用键中包含的所有信息,这可能导致我们无法均匀的散列散列值.</li>
  <li>浮点数<br />
  如果键是0到1之间的实数,我们可以将它乘以M并四舍五入得到一个0至M-1之间的索引值.尽管这个方法很容易理解,但它是有缺陷的,因为这种情况下键的高位起的作用更大,最低位对散列的结果没有影响.修正这个问题的办法是将键表示为二进制数然后再使用除留余数法.</li>
  <li>字符串<br />
  除留余数法也可以处理较长的键,</li>
  <li>组合键<br />
  如果键的类型含有多个整型变量,我们可以和String类型一样将它们混合起来.
&amp;emps; 例如:假设被查找的键的类型是Date,其中含有几个整型的域:day(两个数字表示的日)、month(两个数字表示的月)和year(4个数字表示的年).我们可以这样计算它的散列值:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(((</span><span class="n">day</span><span class="o">*</span><span class="no">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">)%</span><span class="no">M</span><span class="o">)*</span><span class="no">R</span> <span class="o">+</span> <span class="n">year</span><span class="o">)%</span><span class="no">M</span>
</code></pre></div>    </div>
  </li>
</ol>

<ul>
  <li>Java的约定<br />
  每种数据类型都需要相应的散列函数,于是Java令所有数据类型都继承了一个能够返回一个32比特整数的hashCode().每一种数据结构的hashCode()方法都必须和equals()方法一致.
也就是说,如果a.equals(b)返回true,那么a.hashCode()的返回值必然和b.hashCode()的返回值相同.相反,如果两个对象的hashCode()方法的返回值不同,那么我们就知道这两个对象是不同的.
但是如果两个对象的hashCode()方法的返回值相同,这两个对象也有可能不同,我们还需要使用equals()方法进行判断.请注意,这说明你要为自定义的数据类型定义散列函数,你需要同时重写hashCode()和equals()两个方法.</li>
  <li>将hashCode()的返回值转化为一个数组索引<br />
  因为我们需要的是数组的索引而不是一个32位的整数,我们在实现中会将默认的hashCode()方法和除留余数法结合起来产生一个0到M-1的整数,方法如下:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="nc">Key</span> <span class="n">x</span><span class="o">){</span>
  <span class="k">return</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  这段代码会将符号位屏蔽(将一个32位整数变为一个31位非负整数),然后用除留余数法计算它除以M的余数.在使用这样的代码时我们一般会将数组的大小M取为素数以充分利用原散列值的所有位.</p>
  </li>
  <li>自定义的hashCode()方法<br />
  散列表的用例希望hashCode()方法能够将键平均地散布为所有可能的32位整数.也就是说,对于任意对象x,你可以调用x.hashCode()并认为有均等的机会得到2^32个不同整数中的任意一个32位整数值.
对于自定义的数据类型,必须试着自己实现这一点,示例如下:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Transaction</span><span class="o">{</span>
  <span class="o">...</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">who</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Date</span> <span class="n">when</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">amount</span><span class="o">;</span>
    
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(){</span>
      <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">17</span><span class="o">;</span>
      <span class="n">hash</span> <span class="o">=</span> <span class="mi">31</span><span class="o">*</span><span class="n">hash</span> <span class="o">+</span> <span class="n">who</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
      <span class="n">hash</span> <span class="o">=</span> <span class="mi">31</span><span class="o">*</span><span class="n">hash</span> <span class="o">+</span> <span class="n">when</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
      <span class="n">hash</span> <span class="o">=</span> <span class="mi">31</span><span class="o">*</span><span class="n">hash</span> <span class="o">+</span> <span class="o">((</span><span class="nc">Double</span><span class="o">)</span> <span class="n">amount</span><span class="o">).</span><span class="na">hashCode</span><span class="o">();</span>
      <span class="k">return</span> <span class="n">hash</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  在Java中,所有的数据类型都继承了hashCode()方法,因此还有一个更简单的做法:将对象中的每个变量的hashCode()返回值转化为32位整数并计算得到散列值,如上示例所示.
对于原始类型的对象,可以将其转化为对于的数据类型然后再调用hashCode()方法.</p>
  </li>
  <li>软缓存<br />
  如果散列值的计算很耗时,那么我们或许可以将每个键的散列值缓存起来,即在每个键中使用一个hash变量来保存它的hashCode()的返回值.
第一次调用hashCode()方法时,我们需要计算对象的散列值,但之后对hashCode()方法的调用会直接返回hash变量的值.
  总的来说,要为一个数据类型实现一个优秀的散列方法需要使用满足三个条件:
    <ul>
      <li>一致性:等价的键必然产生相等的散列值</li>
      <li>高效性:计算简便</li>
      <li>均匀性:均匀地散列所有的键</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="基于拉链法的散列表">基于拉链法的散列表</h3>
<hr />
<p>  一个散列函数能够将键转化为数组索引.散列算法的第二步是碰撞处理,也就是处理两个或多个键的散列值相同的情况.一种直接的办法是将大小为M的数组中的每个元素指向一条链表,
链表中的每个节点都存储了散列值为该元素的索引的键值对.这种方法被称为拉链法,因为发生冲突的元素都被存储在链表中.这个方法的基本思想就是选择足够大的M,使得所有链表都尽可能短以保证高效的查找.
查找分两步:首先根据散列值找到对应的链表,然后沿着链表顺序查找相应的键.<br />
  拉链法的一种实现方法是使用原始的链表数据类型类扩展SequentialSearchST.另一种更简单的方法是采用一般性的策略,为M个元素分别构建符号表来保存散列到这里的键,这样也可以重用之前的代码.<br />
  因为我们要用M条链表保存N个键,无论键在各个链表中的分布如何,链表的平均长度肯定是N/M.在标准索引用例中使用基于拉链法的散列表如下图所示:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/hashTable/标准索引用例使用基于拉链法的散列表.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="标准索引用例使用基于拉链法的散列表" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/hashTable/标准索引用例使用基于拉链法的散列表.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">标准索引用例使用基于拉链法的散列表</div>
    </a>
</center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SeparateChainingHashST</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">,</span> <span class="nc">Value</span><span class="o">&gt;</span>
<span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span> <span class="c1">// 键值对总数</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="no">M</span><span class="o">;</span> <span class="c1">// 散列表的大小</span>
  <span class="kd">private</span> <span class="nc">SequentialSearchST</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">,</span> <span class="nc">Value</span><span class="o">&gt;[]</span> <span class="n">st</span><span class="o">;</span> <span class="c1">// 存放链表对象的数组</span>
  <span class="kd">public</span> <span class="nf">SeparateChainingHashST</span><span class="o">()</span>
  <span class="o">{</span> <span class="k">this</span><span class="o">(</span><span class="mi">997</span><span class="o">);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="nf">SeparateChainingHashST</span><span class="o">(</span><span class="kt">int</span> <span class="no">M</span><span class="o">)</span>
  <span class="o">{</span> <span class="c1">// 创建M条链表</span>
    <span class="k">this</span><span class="o">.</span><span class="na">M</span> <span class="o">=</span> <span class="no">M</span><span class="o">;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SequentialSearchST</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">,</span> <span class="nc">Value</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">SequentialSearchST</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">st</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SequentialSearchST</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span>
  <span class="o">{</span> <span class="k">return</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="nc">Value</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span>
  <span class="o">{</span> <span class="k">return</span> <span class="o">(</span><span class="nc">Value</span><span class="o">)</span> <span class="n">st</span><span class="o">[</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">)].</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">)</span>
  <span class="o">{</span> <span class="n">st</span><span class="o">[</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">)].</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">()</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  这段简单的符号表实现维护这一条链表的数组,用散列函数来为每个键选择一条链表.</p>

<ul>
  <li>散列表的大小<br />
  在实现基于拉链法的散列表时,目标是选择适当的数组大小M,既不会因为空链表而浪费大量内存,也不会因为链表太长而在查找上浪费太多时间.</li>
  <li>删除操作<br />
  要删除一个键值对,先用散列值找到含有该键的SequencetialSearchST对象,然后再调用该对象的delete()方法.</li>
  <li>有序性相关操作<br />
  散列最主要的目的在于均匀地将键散布开来,因此在计算散列后键的顺序信息就会丢失了.所以散列不适合有序操作.</li>
</ul>

<hr />

<h3 id="基于线性探测的散列表">基于线性探测的散列表</h3>
<hr />
<p>  实现散列表的另一种方式就是用大小为M的数组保存N个键值对,其中M&gt;N.我们需要依靠数组中的空位解决碰撞冲突.基于这种策略的所有方法被统称为开放地址散列表.<br />
  开放地址散列表中最简单的方法叫做线性探测法:当碰撞发生时(当一个键的散列值已经被另一个不同的键占用),我们直接检查散列表中的下一个位置(将索引值加1).这样的线性探测可能会产生三种结果:</p>
<ul>
  <li>命中,该位置的键和被查找的键相同</li>
  <li>未命中,键为空(该位置没有键)</li>
  <li>继续查找,该位置的键和被查找的键不同</li>
</ul>

<p>  我们用散列函数找到键在数组中的索引,检查其中的键和被查找的键是否相同.如果不同则继续查找(将索引增大,到达数组结尾时折回数组的开头),直到找到该键或者遇到一个空元素,我们习惯将检查一个数组位置是否含有被查找的键的操作称作探测.<br />
  开放地址类的散列表的核心思想是与其将内存用作链表,不如将它们作为在散列表的空元素.这些空元素可以作为查找结束的标志.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/hashTable/标准索引用例使用的基于线性探测的符号表的轨迹.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="标准索引用例使用的基于线性探测的符号表的轨迹" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/hashTable/标准索引用例使用的基于线性探测的符号表的轨迹.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">标准索引用例使用的基于线性探测的符号表的轨迹</div>
    </a>
</center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinearProbingHashST</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">,</span> <span class="nc">Value</span><span class="o">&gt;</span>
<span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span> <span class="c1">// 符号表中键值对的总数</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span> <span class="c1">// 线性探测表的大小</span>
  <span class="kd">private</span> <span class="nc">Key</span><span class="o">[]</span> <span class="n">keys</span><span class="o">;</span> <span class="c1">// 键</span>
  <span class="kd">private</span> <span class="nc">Value</span><span class="o">[]</span> <span class="n">vals</span><span class="o">;</span> <span class="c1">// 值</span>
  <span class="kd">public</span> <span class="nf">LinearProbingHashST</span><span class="o">()</span>
  <span class="o">{</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Key</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Value</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span>
  <span class="o">{</span> <span class="k">return</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span> <span class="o">}</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">resize</span><span class="o">()</span> <span class="c1">// 请见3.4.4节</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">N</span> <span class="o">&gt;=</span> <span class="no">M</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span> <span class="n">resize</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="no">M</span><span class="o">);</span> <span class="c1">// 将M加倍（请见正文）</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span> <span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span>
    <span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="no">N</span><span class="o">++;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="nc">Value</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
    <span class="k">return</span> <span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  这段符号表的实现将键和值分别保存在两个数组中,使用空来表示一簇键的结束.如果一个新键的散列值是一个空元素,那么就将它保存在那里;如果不是,
我们就顺序查找一个空元素来保存它.要查找一个键,我们从它的散列值开始顺序查找,如果找到则是命中,如果遇到空元素则未命中.</p>

<ul>
  <li>删除操作</li>
</ul>

<p>  如何从基于线性探测的散列表中删除一个键?仔细想想,直接将该键所在的位置设为null是不行的,因为这会使得此位置之后的元素无法被查找.因此我们需要将簇中被删除键的右侧的所有键重新插入散列表.这个过程比想象的复杂.删除代码如下所示:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">contains</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="k">return</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span>
  <span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="nc">Key</span> <span class="n">keyToRedo</span> <span class="o">=</span> <span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="nc">Value</span> <span class="n">valToRedo</span> <span class="o">=</span> <span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="no">N</span><span class="o">--;</span>
    <span class="n">put</span><span class="o">(</span><span class="n">keyToRedo</span><span class="o">,</span> <span class="n">valToRedo</span><span class="o">);</span>
    <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="no">N</span><span class="o">--;</span>
  <span class="k">if</span> <span class="o">(</span><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="no">N</span> <span class="o">==</span> <span class="no">M</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span> <span class="n">resize</span><span class="o">(</span><span class="no">M</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>键簇</li>
</ul>

<p>  线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目,也叫做键簇.如下图所示:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/hashTable/线性探测法中的键簇.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="线性探测法中的键簇" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/hashTable/线性探测法中的键簇.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">线性探测法中的键簇</div>
    </a>
</center>

<hr />

<h3 id="调整数组大小">调整数组大小</h3>
<hr />
<p>  首先,我们的LinearProbingHashST需要一个新的构造函数,它接受一个固定的容量作为参数.然后,我们需要右边给出的resize()方法.它会创建出一个新的给定大小的LinearProbingHashST,保存原表中的keys和values变量,
然后将原表中所有的键重新散列并插入到新表中.这使我们可以将数组的长度加倍.put()方法中的第一条语句会调用resize()来保证散列表最多为半满状态.这段代码构造的散列表比原来大一倍.因此α的值就会减半.
和其他需要调整数组大小的应用场景一样,我们也需要在delete()方法的最后加上 <strong>if (N &gt; 0 &amp;&amp; N &lt;= M/8) resize(M/2);</strong> 以保证所使用的内存量和表中的键值对数量的比例总在一定范围之内.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">resize</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span>
<span class="o">{</span>
  <span class="nc">LinearProbingHashST</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">,</span> <span class="nc">Value</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">;</span>
  <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinearProbingHashST</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">,</span> <span class="nc">Value</span><span class="o">&gt;(</span><span class="n">cap</span><span class="o">);</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
  <span class="n">t</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
  <span class="n">keys</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">keys</span><span class="o">;</span>
  <span class="n">vals</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">vals</span><span class="o">;</span>
  <span class="no">M</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">M</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="拉链法">拉链法</h3>
<p>  我们可以用相同的方法在拉链法中保持较短的链表(平均长度在2到8之间):当N&gt;=8<em>M时调用resize(2</em>M),并在delete()中(在N&gt;0&amp;&amp;N&lt;=2*M时)调用resize(M/2).</p>

<hr />
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">HashTable</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">November 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000016" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>状态压缩</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-eugene-golovesov-5097165.jpg" class="img-responsive img-centered" alt="stateCompression">

                            
                                <h3>状态压缩</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />
<p>状态压缩的主要思想就是利用二进制和位运算代替繁琐的操作。</p>
<hr />

<h3 id="常见二进制变换操作">常见二进制变换操作</h3>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    功能             |         示例             |       位运算     
去掉最后一位          |  (101101 -&gt; 10110)       |       x&gt;&gt;1
在最后加一个0         |  (101101 -&gt; 1011010)     |       x&lt;&lt;1
在最后加一个1         |  (101101 -&gt; 1011011)     |       x&lt;&lt;1+1
把最后一位变成1       |  (101100 -&gt; 101101)      |       x|1
把最后一位变成0       |  (101101 -&gt; 101100)      |       x|1-1
最后一位取反          |  (101101 -&gt; 101100)      |       x^1
把右数第k位变成1      |  (101001 -&gt; 101101,k=3)  |       x|(1&lt;&lt;(k-1))
把右数第k位变成0      |  (101101 -&gt; 101001,k=3)  |       x&amp;~(1&lt;&lt;(k-1))
右数第k位取反         |  (101001 -&gt; 101101,k=3)  |       x^(1&lt;&lt;(k-1))
取末三位             |  (1101101 -&gt; 101)        |       x&amp;7
取末k位              |  (1101101 -&gt; 1101.k=5)   |       x&amp;(1&lt;&lt;k-1)
取右数第k位          |  (1101101 -&gt; 1.k=4)      |        x&gt;&gt;(k-1)&amp;1
把末k位变成1         |  (101001 -&gt; 101111,k=4)  |        x|(1&lt;&lt;k-1)
末k位取反            |  (101001 -&gt; 100110,k=4)  |        x^(1&lt;&lt;k-1)
把右边连续的1变成0    |  (100101111 -&gt; 100100000)|        x&amp;(x+1)
把右起第一个0变为1    |  (100101111 -&gt; 100111111)|        x|(x+1)
把右起连续的0变成1    |  (11011000 -&gt; 11011111)  |        x|(x-1)
取右边连续的1        |  (100101111 -&gt; 1111)     |        (x^(x+1))&gt;&gt;1
去掉右起第一个1的左边 |  (100101000 -&gt; 1000)     |        x&amp;(x^(x-1))
</code></pre></div></div>

<hr />
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Binary</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">November 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000015" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>TopoSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-michael-kessel-9668543.jpg" class="img-responsive img-centered" alt="topoSort">

                            
                                <h3>拓扑排序</h3>
                            
                            </div>

                            <p><h3 id="百度百科定义">百度百科定义</h3>
<hr />
<p>  对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序,是将G中所有顶点排成一个线性序列,
使得图中任意一对顶点u和v,若&lt;u,v&gt;∈E(G),则u在线性序列中出现在v之前.通常,这样的线性序列称为满足拓扑次序(Topological Order)的序列,简称拓扑序列.<br />
  简单的说,由某个集合上的一个偏序得到该集合上的一个全序,这个操作称之为拓扑排序.</p>
<hr />

<h3 id="kahn算法">Kahn算法</h3>
<hr />
<p>  拓扑排序是对DAG(有向无环图)上的节点进行排序,使得对于每一条有向边 u-&gt;v ,u都出现在v之前.
简单的来说,是在不破坏节点先后顺序的前提下,把DAG拉成一条链.</p>

<p>  拓扑排序最经典的算法是Kahn算法.<br />
  首先,先拿出所有入度为0的点排在前面,并在原图中将它们删除:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/步骤1.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="步骤1" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/步骤1.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">步骤1</div>
    </a>
</center>
<p>  这时有些点的入度减少了,于是再拿出当前所有入度为0的点放在已经排序的序列后面,然后删除:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/步骤2.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="步骤2" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/步骤2.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">步骤2</div>
    </a>
</center>
<p>  因为是有向无环图,而且删除操作不会产生环,所以每时每刻都一定存在入度为0的点,一定可以不断进行下去,直到所有点被删除.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/步骤3.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="步骤3" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/步骤3.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">步骤3</div>
    </a>
</center>
<p>  以下是一个O(n+m)的实现(n,m分别表示点数和边数),利用了队列:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// deg是入度，在存图的时候需要录入数据</span>
<span class="c1">// A是排序后的数组</span>
<span class="kt">int</span> <span class="n">deg</span><span class="o">[</span><span class="no">MAXN</span><span class="o">],</span> <span class="no">A</span><span class="o">[</span><span class="no">MAXN</span><span class="o">];</span>
<span class="n">bool</span> <span class="nf">toposort</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">deg</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">q</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">front</span><span class="o">();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="no">A</span><span class="o">[</span><span class="n">cnt</span><span class="o">++]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">auto</span> <span class="n">to</span> <span class="o">:</span> <span class="n">edges</span><span class="o">[</span><span class="n">t</span><span class="o">])</span>
        <span class="o">{</span>
            <span class="n">deg</span><span class="o">[</span><span class="n">to</span><span class="o">]--;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">deg</span><span class="o">[</span><span class="n">to</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// 出现了新的入度为0的点</span>
                <span class="n">q</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">n</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  防止是否成功进行拓扑排序,也即是否存在环.也就是说拓扑排序是可以用来简单的判断环的.
有时会要求输出字典序最小的方案,这时把queue改成priority_queue即可,复杂度会多一个log.</p>
<hr />

<h3 id="翻转后序遍历">翻转后序遍历</h3>
<hr />
<p>  先抛出结论,将后序遍历的结果进行反转,就是拓扑排序的结果.<br />
  直接看题目:<a href="https://leetcode-cn.com/problems/course-schedule-ii/">课程表 II</a></p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/课程表II.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="课程表II" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/课程表II.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">课程表II</div>
    </a>
</center>
<p>  本题是<a href="https://leetcode-cn.com/problems/course-schedule/">课程表</a>的进阶版,本题需要求出所学的课程顺序.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/拓扑排序.jpeg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="拓扑排序" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/topoSort/拓扑排序.jpeg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">拓扑排序</div>
    </a>
</center>
<p>  直观地说就是,让你把一幅图拉平,而且这个拉平的图里面,所有箭头方向都是一致的,比如上图所有箭头都是朝右的.
很显然,如果一幅有向图中存在环,是无法进行拓扑排序的,因为肯定做不到所有箭头方向一致;反过来,如果一幅图是有向无环图,那么一定可以进行拓扑排序.<br />
  那这道题和拓扑排序有什么关系呢？<br />
  其实也不难看出来,如果把课程抽象成节点,课程之间的依赖关系抽象成有向边,那么这幅图的拓扑排序结果就是上课顺序.<br />
  首先,我们先判断输入的课程是否成环,成环是的无法进行拓扑排序的</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findOrder</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">canFinish</span><span class="o">(</span><span class="n">numCourses</span><span class="o">,</span> <span class="n">prerequisites</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// 不可能完成所有课程</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>

<span class="c1">// 记录一次 traverse 递归经过的节点</span>
<span class="kt">boolean</span><span class="o">[]</span> <span class="n">onPath</span><span class="o">;</span>
<span class="c1">// 记录遍历过的节点，防止走回头路</span>
<span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
<span class="c1">// 记录图中是否有环</span>
<span class="kt">boolean</span> <span class="n">hasCycle</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

<span class="kt">boolean</span> <span class="nf">canFinish</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="o">(</span><span class="n">numCourses</span><span class="o">,</span> <span class="n">prerequisites</span><span class="o">);</span>

    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="n">onPath</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 遍历图中的所有节点</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 只要没有循环依赖可以完成所有课程</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">hasCycle</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="o">{</span>
        <span class="c1">// 出现环</span>
        <span class="n">hasCycle</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">||</span> <span class="n">hasCycle</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果已经找到了环，也不用再遍历了</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 前序遍历代码位置</span>
    <span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 后序遍历代码位置</span>
    <span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>


<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="nf">buildGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 图中共有 numCourses 个节点</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// 修完课程 from 才能修课程 to</span>
        <span class="c1">// 在图中添加一条从 from 指向 to 的有向边</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">from</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">graph</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  那么关键来了.如何进行拓扑排序,就是将后序遍历的结果进行反转,就是拓扑排序的结果.直接看代码:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
<span class="c1">// 记录后序遍历结果</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">postorder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="kt">int</span><span class="o">[]</span> <span class="nf">findOrder</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 先保证图中无环</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">canFinish</span><span class="o">(</span><span class="n">numCourses</span><span class="o">,</span> <span class="n">prerequisites</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
    <span class="o">}</span>
    <span class="c1">// 建图</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="o">(</span><span class="n">numCourses</span><span class="o">,</span> <span class="n">prerequisites</span><span class="o">);</span>
    <span class="c1">// 进行 DFS 遍历</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 将后序遍历结果反转，转化成 int[] 类型</span>
    <span class="nc">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">postorder</span><span class="o">);</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">postorder</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 后序遍历位置</span>
    <span class="n">postorder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 参考上一题的解法</span>
<span class="kt">boolean</span> <span class="nf">canFinish</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">);</span>

<span class="c1">// 参考前文代码</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="nf">buildGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">);</span>
</code></pre></div></div>
<p>  逻辑还是比较清晰的,只要图中无环,那么我们就调用traverse函数对图进行DFS遍历,记录后序遍历结果,最后把后序遍历结果反转,作为最终的答案.</p>

<ul>
  <li>为什么后序遍历的反转结果就是拓扑排序呢?<br />
  首先我们先回想一下后序遍历的顺序,左子树-&gt;右子树-&gt;根节点.换句话说,当左右子树的节点都被装到结果列表里面了,根节点才会被装进去.<br />
  后序遍历的这一特点很重要,之所以拓扑排序的基础是后序遍历,是因为一个任务必须在等到所有的依赖的任务都完成之后才能开始执行.
把每个任务理解成二叉树里面的节点,这个任务所依赖的任务理解成子节点,那么我们就应该先把所有子节点处理完再处理父节点,也就是后序遍历.</li>
</ul>

<blockquote>
  <p>注意:拓扑排序就是后序遍历反转之后的结果,且拓扑排序只能针对有向无环图,进行拓扑排序之前要进行环检测.</p>
</blockquote>

<hr />

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Sort</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">November 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000014" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>QuickPower</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-regina-pivetta-9945338.jpg" class="img-responsive img-centered" alt="快速幂">

                            
                                <h3>快速幂</h3>
                            
                            </div>

                            <p><h3 id="快速幂定义">快速幂定义</h3>
<hr />
<p>  快速幂就是快速算底数的n次幂.其时间复杂度为O(logN),与O(N)相比效率有了极大的提高.</p>
<hr />

<h3 id="原理">原理</h3>
<hr />
<p>  快速幂的核心思想就是每一步都把指数分成两半,而相应的底数做平方运算.
这样不仅能把非常大的指数给不断变小,所需要执行的循环次数也变小,而最后表示的结果却一直不会变.
  举个简单的例子,比如我们要求3的10次方</p>
<ol>
  <li>若我们使用通常的方法则是每次乘3直到乘了9次,即3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3</li>
  <li>若我们先算3的五次方,然后在算它的平方,只需要乘五次即可,即(3 * 3 * 3 * 3 * 3)^2</li>
  <li>若我们先算3 * 3,则3的五次方为9 * 9 *3,再算它的平方,共进行了4次乘法
模仿这样的过程,我们得到一个在O(logN)时间内计算出幂的算法,也就是快速幂.
    <hr />
  </li>
</ol>

<h3 id="递归快速幂">递归快速幂</h3>
<hr />
<p>以上的递归方程如下:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/递归方程.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="递归方程" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/递归方程.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">递归方程</div>
    </a>
</center>
<p>  计算a的n次方,有三种情况:</p>
<ul>
  <li>如果n为偶数(不为0),那么就先计算a的n/2次方,然后平方</li>
  <li>如果n是奇数,那么就先计算a的n-1次方</li>
  <li>递归出口就是a的0次方,为1</li>
</ul>

<p>  递归快速幂的思路比较清晰:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//递归快速幂</span>
<span class="kt">int</span> <span class="nf">qpow</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">1</span><span class="o">){</span>
        <span class="k">return</span> <span class="nf">qpow</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)*</span><span class="n">a</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">qpow</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">*</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  注意这个temp变量是必须的,如果不发a^(n/2)记录下来,直接写成qpow(a, n/2)*qpow(a, n/2),那会计算两次 a^(n/2),整个算法就退化为O(n).<br />
  在实际问题中,题目常常会要求一个大素数取模,这是因为计算结果可能会非常巨大,但是在这考察高精度又没有必要.
这时我们的快速幂也应当进行取模,此时应当注意,原则是步步取模,如果MOD较大,还应当注意是否会超过int的大小,使用long.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//递归快速莫 (对大素数取模)</span>
<span class="kt">int</span> <span class="no">MOD</span> <span class="mi">1000000007</span>
<span class="kt">long</span> <span class="nf">qpow</span><span class="o">(</span><span class="kt">long</span> <span class="n">a</span><span class="o">,</span> <span class="kt">long</span> <span class="n">n</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">1</span><span class="o">){</span>
        <span class="k">return</span> <span class="nf">qpow</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)*</span><span class="n">a</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="kt">long</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">qpow</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">*</span><span class="n">temp</span><span class="o">%</span><span class="no">MOD</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  递归虽然简洁,但会产生额外的空间开销.可以把递归改写为循环,来避免对栈空间的大量占用,也就是非递归快速幂.</p>

<hr />

<h3 id="非递归快速幂">非递归快速幂</h3>
<hr />
<p>  换一个角度来引入非递归的快速幂,例如7的10次方,把10写成二进制的形式(1010).<br />
  要计算7^(1010),我们可以把它们拆分为 <strong>7^(1000) * 7^(10)</strong> .实际上,对于任意的整数,我们都可以把它拆成若干个7^(100..)的形式相乘.
而这些7^(100..)恰好就是 <strong>7^1、7^2、7^4…</strong> ,我们只需不断把底数平方即可算出它们.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//非递归快速幂</span>
<span class="kt">int</span> <span class="nf">qpow</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">n</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">){</span>    <span class="c1">//如果n的当前末尾为1</span>
            <span class="n">ans</span><span class="o">*=</span><span class="n">a</span><span class="o">;</span> <span class="c1">//ans乘上当前的a</span>
        <span class="o">}</span>
        <span class="n">a</span><span class="o">*=</span><span class="n">a</span><span class="o">;</span>       <span class="c1">//a自乘</span>
        <span class="n">n</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="o">;</span>      <span class="c1">//n往右移一位</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  运算过程如下:<br />
  最初ans为1,然后我们一位一位算:<br />
  1010的最后一位是0,所以a^1这一位不要.然后1010变为101,a变为a^2<br />
  101的最后一位是0,所以a^2这一位是需要的,乘入ans.101变为10,a再自乘变为a^4<br />
  10的最后一位是0,跳过,右移10变为1,a再自乘变为a^8<br />
  最后1的最后一位是1,ans再乘上a^8.循环结束,返回结果</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/非递归快速幂.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="非递归快速幂" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/非递归快速幂.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">非递归快速幂</div>
    </a>
</center>
<p>  这里的位运算符 » 是右移,表示把二进制数往右移动一位,相当于/2;&amp;是按位与,&amp;1可以理解为取出二进制数的最后一位,相当于%2==1.</p>
<hr />

<h3 id="矩阵快速幂">矩阵快速幂</h3>
<hr />
<p>  矩阵快速幂用于求解一般性问题:给定大小为n*n的矩阵M,求答案矩阵M^k,并对答案矩阵中的每位元素对P取模.
对于类似斐波那契此类的数列递推问题,我们可以使用矩阵快速幂来进行加速.使用矩阵快速幂,我们只需要O(logn)的复杂度.</p>

<ul>
  <li>泰波那契序列
泰波那契序列 Tn 定义如下:<br />
T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2<br />
给你整数n,请返回第n个泰波那契数Tn的值.</li>
</ul>

<p>根据题目的递推关系(i&gt;=3):</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/递推关系.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="递推关系" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/递推关系.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">递推关系</div>
    </a>
</center>
<p>我们发现求解 f(i) 其依赖的是 f(i-1)、f(i-2)和f(i-3).
我们可以将其存成一个列向量:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/列向量.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="列向量" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/列向量.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">列向量</div>
    </a>
</center>
<p>利用题目给定的依赖关系,对目标矩阵元素进行展开:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/矩阵展开.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="矩阵展开" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/矩阵展开.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">矩阵展开</div>
    </a>
</center>
<p>那么根据矩阵乘法,即有:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/公式.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="公式" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/公式.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">公式</div>
    </a>
</center>
<p>我们令:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/因子.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="因子" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/因子.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">因子</div>
    </a>
</center>
<p>然后发现利用Mat也能实现数列递推:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/数列递推.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="数列递推" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/数列递推.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">数列递推</div>
    </a>
</center>
<p>再根据矩阵运算的结合律,最终有:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/最终公式.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="最终公式" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/最终公式.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">最终公式</div>
    </a>
</center>
<p>从而将问题转化为求解Mat^(n-2),这时候可以套用矩阵快速幂解决.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="nf">mul</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="mi">2</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">tribonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
            <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
            <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">mat</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
            <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span>
            <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span>
        <span class="o">};</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">mul</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">mat</span><span class="o">);</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">mul</span><span class="o">(</span><span class="n">mat</span><span class="o">,</span> <span class="n">mat</span><span class="o">);</span>
            <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">ans</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>时间复杂度:O(logN)<br />
空间复杂度:O(1)</p>
</blockquote>

<ul>
  <li>斐波那契数列</li>
</ul>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/斐波那契数列.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="斐波那契数列" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/斐波那契数列.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">斐波那契数列</div>
    </a>
</center>
<p>推算方法如下:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/斐波那契数列推算.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="斐波那契数列推算" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/fastPower/斐波那契数列推算.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">斐波那契数列推算</div>
    </a>
</center>
<p>这样,我们把原来较为复杂的问题转化成了求某个矩阵的幂的问题,可以应用快速幂求解.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">cstdio</span><span class="o">&gt;</span>
<span class="err">#</span><span class="n">define</span> <span class="no">MOD</span> <span class="mi">1000000007</span>
<span class="n">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="o">;</span>

<span class="n">struct</span> <span class="n">matrix</span>
<span class="o">{</span>
    <span class="n">ll</span> <span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">,</span> <span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">;</span>
    <span class="n">matrix</span><span class="o">(</span><span class="n">ll</span> <span class="n">a1</span><span class="o">,</span> <span class="n">ll</span> <span class="n">a2</span><span class="o">,</span> <span class="n">ll</span> <span class="n">b1</span><span class="o">,</span> <span class="n">ll</span> <span class="n">b2</span><span class="o">)</span> <span class="o">:</span> <span class="n">a1</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="n">a2</span><span class="o">(</span><span class="n">a2</span><span class="o">),</span> <span class="n">b1</span><span class="o">(</span><span class="n">b1</span><span class="o">),</span> <span class="n">b2</span><span class="o">(</span><span class="n">b2</span><span class="o">)</span> <span class="o">{}</span>
    <span class="n">matrix</span> <span class="n">operator</span><span class="o">*(</span><span class="kd">const</span> <span class="n">matrix</span> <span class="o">&amp;</span><span class="n">y</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="n">matrix</span> <span class="nf">ans</span><span class="o">((</span><span class="n">a1</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="na">a1</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="na">b1</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">,</span>
                   <span class="o">(</span><span class="n">a1</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="na">a2</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="na">b2</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">,</span>
                   <span class="o">(</span><span class="n">b1</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="na">a1</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="na">b1</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">,</span>
                   <span class="o">(</span><span class="n">b1</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="na">a2</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="na">b2</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="n">matrix</span> <span class="nf">qpow</span><span class="o">(</span><span class="n">matrix</span> <span class="n">a</span><span class="o">,</span> <span class="n">ll</span> <span class="n">n</span><span class="o">)</span>
<span class="o">{</span>
    <span class="n">matrix</span> <span class="nf">ans</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">//单位矩阵</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">*</span> <span class="n">a</span><span class="o">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="o">()</span>
<span class="o">{</span>
    <span class="n">ll</span> <span class="n">x</span><span class="o">;</span>
    <span class="n">matrix</span> <span class="nf">M</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">scanf</span><span class="o">(</span><span class="s">"%lld"</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">);</span>
    <span class="n">matrix</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">qpow</span><span class="o">(</span><span class="no">M</span><span class="o">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">printf</span><span class="o">(</span><span class="s">"%lld\n"</span><span class="o">,</span> <span class="o">(</span><span class="n">ans</span><span class="o">.</span><span class="na">a1</span> <span class="o">+</span> <span class="n">ans</span><span class="o">.</span><span class="na">a2</span><span class="o">)</span> <span class="o">%</span> <span class="no">MOD</span><span class="o">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Power</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">November 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000013" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>MajorityVote</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-vladislav-filippov-9001724.jpg" class="img-responsive img-centered" alt="摩尔投票">

                            
                                <h3>摩尔投票</h3>
                            
                            </div>

                            <p><h3 id="摩尔投票">摩尔投票</h3>
<hr />
<p><a href="https://www.cs.ou.edu/~rlpage/dmtools/mjrty.pdf">摩尔投票论文地址</a></p>
<ol>
  <li>抛出问题<br />
给定一个数组求出该数组中出现次数大于数组一半长度的数,要求时间复杂度为O(n),空间复杂度为O(1)</li>
  <li>解决方案
    <ul>
      <li>若没有空间复杂度的要求,我们直接使用Map一次遍历记录没有数出现的次数,最后找到出现次数大于一半的即可</li>
      <li>但是加上空间复杂度的要求上面的方法就行不通了,由此引申出摩尔投票</li>
    </ul>
  </li>
  <li>定义<br />
摩尔投票的本质就是冲突抵消.因为要求的数在数组中出现超过数组一半长度,那么这个数肯定就只能有一个.
每次从数组中取出两个不相同的数进行抵消,最后剩下的一个数字或者几个数字可能就是我们要求的数.
这里为什么要说可能呢,因为有可能会出现以下情况:</li>
</ol>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/majorityVote/摩尔投票示意图.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="摩尔投票示意图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/majorityVote/摩尔投票示意图.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">摩尔投票示意图</div>
    </a>
</center>
<p>  正常情况如上图左侧,抵消之后的剩余的数就是要求的数;若是非异常情况,如上图右侧,抵消之后的数并不是要求的数.<br />
  所以最后剩余的数不一定是我们要求的结果,还需要我们再进行一次遍历统计该数的出现次数是否满足要求.</p>
<hr />

<h3 id="力扣原题">力扣原题</h3>
<hr />
<p><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a><br />
  首先我们先来看下简单题:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/majorityVote/主要元素.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="主要元素" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/majorityVote/主要元素.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">主要元素</div>
    </a>
</center>
<p>根据摩尔投票的原理:</p>
<ol>
  <li>定义候选值 candidate 和 出现次数 count</li>
  <li>遍历数组nums</li>
  <li>如果count为0 将num赋值给candidate</li>
  <li>如果当前num 等于 候选值 candidate 则将count++ 否则 count–</li>
  <li>最后剩下的candidate可能是结果</li>
  <li>还需要遍历nums数组求出candidate的出现次数是否符合要求</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">majorityElement1</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">candidate</span> <span class="o">==</span> <span class="n">num</span><span class="o">){</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">count</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">candidate</span><span class="o">){</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">?</span> <span class="nl">candidate:</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>时间复杂度:O(n)<br />
空间复杂度:O(1)</p>
</blockquote>

<p><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a><br />
  下面加深点难度:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/majorityVote/求众数II.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="求众数II" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/majorityVote/求众数II.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">求众数II</div>
    </a>
</center>
<p>  因为题目要求出超过 ⌊n/3⌋ 次的元素,其实这里有个隐藏条件,即这样的数最多只有两个,因为如果有三个,每个都超过⌊n/3⌋,那么最终的次数肯定超过数组大小.<br />
  本题我们同样应该使用摩尔投票,只不过稍微改造一下,使用三个数进行抵消,最后剩下来的两个数继续遍历统计个数是否大于⌊n/3⌋.</p>
<ol>
  <li>定义element1、vote1、element2、vote2分别表示第一个元素的值及出现次数和第二个元素的值和出现次数</li>
  <li>多种情况讨论
    <ul>
      <li>若已有element1的投票即vote1大于0,且当前元素等于element1的话,则vote1++</li>
      <li>若已有element2的投票即vote2大于0,且当前元素等于element2的话,则vote2++</li>
      <li>若没有element1的投票即vote1等于0的话,将num赋值给element1且vote1++</li>
      <li>若没有element2的投票即vote2等于0的话,将num赋值给element2且vote2++</li>
      <li>最后若都不满足即三个数不相同,直接抵消,即vote1–,vote2–</li>
    </ul>
  </li>
  <li>经过步骤2之后已经确定可能的结果element1、element2需要满足vote1和vote2大于0,再次遍历数组,统计两个元素的出现次数count1、count2</li>
  <li>最后判断count1、count2是否满足大于n/3,满足则加入结果列表返回</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span>  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">num1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">vote1</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">vote2</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">vote1</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="o">==</span><span class="n">num1</span><span class="o">){</span>
            <span class="n">vote1</span><span class="o">++;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">vote2</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="o">==</span><span class="n">num2</span><span class="o">){</span>
            <span class="n">vote2</span><span class="o">++;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">vote1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">num1</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="n">vote1</span><span class="o">++;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">vote2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">num2</span><span class="o">=</span><span class="n">num</span><span class="o">;</span>
            <span class="n">vote2</span><span class="o">++;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">vote1</span><span class="o">--;</span>
            <span class="n">vote2</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="n">count1</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count2</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">vote1</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num1</span><span class="o">==</span><span class="n">num</span><span class="o">){</span>
            <span class="n">count1</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">vote2</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num2</span><span class="o">==</span><span class="n">num</span><span class="o">){</span>
            <span class="n">count2</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">vote1</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count1</span><span class="o">&gt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">3</span><span class="o">){</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">vote2</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count2</span><span class="o">&gt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">3</span><span class="o">){</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>时间复杂度:O(n)<br />
空间复杂度:O(1)</p>
</blockquote>

<hr />
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Tree</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">October 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000008" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SpringBoot启动源码解析(八)</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-joaqu-9677214.jpg" class="img-responsive img-centered" alt="SpringBoot">

                            
                                <h3>SpringBootApplication getBean方法解析:org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String, java.lang.Class<T>)</h3>
                            
                            </div>

                            <p><h3 id="创建bean流程图">创建bean流程图</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/GetBean流程图.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="GetBean流程图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/GetBean流程图.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">GetBean流程图</div>
    </a>
</center>
<hr />

<h3 id="源码分析">源码分析</h3>
<hr />
<p>  getBean()的底层实现是doGetBean(),直接上源码:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Return an instance, which may be shared or independent, of the specified bean.
 * 返回一个指定bean的实例,这个实例可能是共享的也可能是独立的
 * @param name the name of the bean to retrieve
 *             要检索的bean名称
 * @param requiredType the required type of the bean to retrieve
 *                     要检索的bean类型
 * @param args arguments to use when creating a bean instance using explicit arguments
 * (only applied when creating a new instance as opposed to retrieving an existing one)
 *             当创建bean实例时使用显示参数(只应用于创建新实例而不是检索现有实例的应用)
 * @param typeCheckOnly whether the instance is obtained for a type check,
 * not for actual use
 *                      获取实例是否是为了类型检查,而不是实际 使用
 * @return an instance of the bean
 * @throws BeansException if the bean could not be created
 */</span>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">protected</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">doGetBean</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="kd">final</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">requiredType</span><span class="o">,</span>
        <span class="nd">@Nullable</span> <span class="kd">final</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">typeCheckOnly</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
    <span class="c1">//1. 获取bean的名称 工厂bean需要去除前缀 &amp;</span>
    <span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="n">transformedBeanName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="nc">Object</span> <span class="n">bean</span><span class="o">;</span>

    <span class="c1">// Eagerly check singleton cache for manually registered singletons.</span>
    <span class="c1">//急切的检查单例缓存是够有手动注册的单例</span>
    <span class="c1">//2. 尝试从三级缓存中获取</span>
    <span class="nc">Object</span> <span class="n">sharedInstance</span> <span class="o">=</span> <span class="n">getSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
    <span class="c1">//3. 如果获取到实例 且 参数为null 则尝试获取bean</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sharedInstance</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">args</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isSingletonCurrentlyInCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Returning eagerly cached instance of singleton bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span>
                        <span class="s">"' that is not fully initialized yet - a consequence of a circular reference"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Returning cached instance of singleton bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//返回bean实例本身或从bean工厂中获取</span>
        <span class="n">bean</span> <span class="o">=</span> <span class="n">getObjectForBeanInstance</span><span class="o">(</span><span class="n">sharedInstance</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">//4. 如果获取不到实例 则进行常见</span>
        <span class="c1">// Fail if we're already creating this bean instance:</span>
        <span class="c1">// We're assumably within a circular reference.</span>
        <span class="c1">//5. 如果我们已经在创建这个bean实例将失败:大概率在循环引用中</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isPrototypeCurrentlyInCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCurrentlyInCreationException</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Check if bean definition exists in this factory.</span>
        <span class="c1">//6. 检查bean定义是否存在工厂中</span>
        <span class="nc">BeanFactory</span> <span class="n">parentBeanFactory</span> <span class="o">=</span> <span class="n">getParentBeanFactory</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">parentBeanFactory</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">containsBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// Not found -&gt; check parent.</span>
            <span class="c1">//如果在父bean工厂中没有找到当前bean 则检查父工厂</span>
            <span class="nc">String</span> <span class="n">nameToLookup</span> <span class="o">=</span> <span class="n">originalBeanName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">parentBeanFactory</span> <span class="k">instanceof</span> <span class="nc">AbstractBeanFactory</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">((</span><span class="nc">AbstractBeanFactory</span><span class="o">)</span> <span class="n">parentBeanFactory</span><span class="o">).</span><span class="na">doGetBean</span><span class="o">(</span>
                        <span class="n">nameToLookup</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">typeCheckOnly</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">args</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Delegation to parent with explicit args.</span>
                <span class="c1">//如果参数不为null,使用显示参数委托给父工厂</span>
                <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">parentBeanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">nameToLookup</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">requiredType</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// No args -&gt; delegate to standard getBean method.</span>
                <span class="c1">//没有参数 则 委托给标准的getBean方法</span>
                <span class="k">return</span> <span class="n">parentBeanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">nameToLookup</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">parentBeanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">nameToLookup</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//7. 如果只是类型检查  需要把bean标记为已创建(或将被创建) 即将beanName添加到alreadyCreated中</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">typeCheckOnly</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">markBeanAsCreated</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//8. 再次获取合并的bean定义</span>
            <span class="kd">final</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span> <span class="o">=</span> <span class="n">getMergedLocalBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="n">checkMergedBeanDefinition</span><span class="o">(</span><span class="n">mbd</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>

            <span class="c1">// Guarantee initialization of beans that the current bean depends on.</span>
            <span class="c1">//9. 保证当前bean所依赖的bean的初始化</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">dependsOn</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getDependsOn</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dependsOn</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">dep</span> <span class="o">:</span> <span class="n">dependsOn</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">isDependent</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">dep</span><span class="o">))</span> <span class="o">{</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span>
                                <span class="s">"Circular depends-on relationship between '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"' and '"</span> <span class="o">+</span> <span class="n">dep</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="n">registerDependentBean</span><span class="o">(</span><span class="n">dep</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">getBean</span><span class="o">(</span><span class="n">dep</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">catch</span> <span class="o">(</span><span class="nc">NoSuchBeanDefinitionException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span>
                                <span class="s">"'"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"' depends on missing bean '"</span> <span class="o">+</span> <span class="n">dep</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Create bean instance.</span>
            <span class="c1">//10. 根据bean类型创建bean实例</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sharedInstance</span> <span class="o">=</span> <span class="n">getSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="nf">createBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">catch</span> <span class="o">(</span><span class="nc">BeansException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// Explicitly remove instance from singleton cache: It might have been put there</span>
                        <span class="c1">// eagerly by the creation process, to allow for circular reference resolution.</span>
                        <span class="c1">// Also remove any beans that received a temporary reference to the bean.</span>
                        <span class="n">destroySingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                        <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">});</span>
                <span class="n">bean</span> <span class="o">=</span> <span class="n">getObjectForBeanInstance</span><span class="o">(</span><span class="n">sharedInstance</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isPrototype</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// It's a prototype -&gt; create a new instance.</span>
                <span class="c1">//如果是原型 -》 创建一个新实例</span>
                <span class="nc">Object</span> <span class="n">prototypeInstance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">beforePrototypeCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                    <span class="n">prototypeInstance</span> <span class="o">=</span> <span class="n">createBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">afterPrototypeCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">bean</span> <span class="o">=</span> <span class="n">getObjectForBeanInstance</span><span class="o">(</span><span class="n">prototypeInstance</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">scopeName</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getScope</span><span class="o">();</span>
                <span class="kd">final</span> <span class="nc">Scope</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">scopes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">scopeName</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">scope</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"No Scope registered for scope name '"</span> <span class="o">+</span> <span class="n">scopeName</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Object</span> <span class="n">scopedInstance</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                        <span class="n">beforePrototypeCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="k">return</span> <span class="nf">createBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="k">finally</span> <span class="o">{</span>
                            <span class="n">afterPrototypeCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                        <span class="o">}</span>
                    <span class="o">});</span>
                    <span class="n">bean</span> <span class="o">=</span> <span class="n">getObjectForBeanInstance</span><span class="o">(</span><span class="n">scopedInstance</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">catch</span> <span class="o">(</span><span class="nc">IllegalStateException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span>
                            <span class="s">"Scope '"</span> <span class="o">+</span> <span class="n">scopeName</span> <span class="o">+</span> <span class="s">"' is not active for the current thread; consider "</span> <span class="o">+</span>
                            <span class="s">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span><span class="o">,</span>
                            <span class="n">ex</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">BeansException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cleanupAfterBeanCreationFailure</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Check if required type matches the type of the actual bean instance.</span>
    <span class="c1">//11. 检查需要的类型是否匹配真正bean实例的类型</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">requiredType</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">requiredType</span><span class="o">.</span><span class="na">isInstance</span><span class="o">(</span><span class="n">bean</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="no">T</span> <span class="n">convertedBean</span> <span class="o">=</span> <span class="n">getTypeConverter</span><span class="o">().</span><span class="na">convertIfNecessary</span><span class="o">(</span><span class="n">bean</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">convertedBean</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanNotOfRequiredTypeException</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">bean</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">convertedBean</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">TypeMismatchException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Failed to convert bean '"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"' to required type '"</span> <span class="o">+</span>
                        <span class="nc">ClassUtils</span><span class="o">.</span><span class="na">getQualifiedName</span><span class="o">(</span><span class="n">requiredType</span><span class="o">)</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanNotOfRequiredTypeException</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">bean</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//12. 返回创建的bean </span>
    <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">bean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<ol>
  <li>获取真正的bean名称,去除工厂bean的前缀&amp;</li>
  <li>首先尝试从三级缓存中获取</li>
  <li>如果可以获取到实例则继续尝试从bean实例本身或者工厂bean中获取</li>
  <li>如果取不到实例则执行创建bean逻辑</li>
  <li>首先检查该bean是否正在创建中</li>
  <li>检查是否存在父bean工厂,若存在且该bean未创建过,则尝试从父bean工厂中获取</li>
  <li>若不止类型检查,则标记该bean为已创建</li>
  <li>尝试再次获取合并的bean定义并检查其定义</li>
  <li>获取该bean依赖属性,存在则先注册这些依赖属性</li>
  <li>这是最重要的一步,根据bean的类型创建bean实例,我们重点关注一下单例的创建,这就是bean创建的声明下面我们会详细介绍</li>
  <li>bean创建完后根据需要的类型进行类型转化</li>
  <li>最后返回创建完成的bean</li>
</ol>

<p>  可见大约可以分为12步,具体的流程图可以参见上面的.<br />
  接下来我们就来一步步看看这个doGetBean具体做了什么:</p>

<p>1.第一步获取真正bean的名称</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Return the bean name, stripping out the factory dereference prefix if necessary,
 * and resolving aliases to canonical names.
 *返回bean名称，如果需要的话去除工厂引用的前缀 并将别名解析为规范名称
 */</span>
<span class="kd">protected</span> <span class="nc">String</span> <span class="nf">transformedBeanName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">canonicalName</span><span class="o">(</span><span class="nc">BeanFactoryUtils</span><span class="o">.</span><span class="na">transformedBeanName</span><span class="o">(</span><span class="n">name</span><span class="o">));</span>
<span class="o">}</span>

<span class="nc">String</span> <span class="no">FACTORY_BEAN_PREFIX</span> <span class="o">=</span> <span class="s">"&amp;"</span><span class="o">;</span>

<span class="cm">/**
 * Return the actual bean name, stripping out the factory dereference
 * prefix (if any, also stripping repeated factory prefixes if found).
 * 返回实际的bean名称，去除工厂引用的前缀  (如果存在的话,也去除重复的工厂前缀 )
 * @param name the name of the bean
 * @return the transformed name
 * @see BeanFactory#FACTORY_BEAN_PREFIX
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">transformedBeanName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="s">"'name' must not be null"</span><span class="o">);</span>
    <span class="c1">//判断当前bean名称是否以 工厂标志 &amp; 开头, 不是则直接返回</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">BeanFactory</span><span class="o">.</span><span class="na">FACTORY_BEAN_PREFIX</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//否则通过递归去除bean前面的 &amp; 标识</span>
    <span class="k">return</span> <span class="n">transformedBeanNameCache</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">beanName</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="n">beanName</span> <span class="o">=</span> <span class="n">beanName</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="nc">BeanFactory</span><span class="o">.</span><span class="na">FACTORY_BEAN_PREFIX</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">beanName</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">BeanFactory</span><span class="o">.</span><span class="na">FACTORY_BEAN_PREFIX</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">beanName</span><span class="o">;</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="cm">/**
 * Determine the raw name, resolving aliases to canonical names.
 * 确定原始名称,将别名解析为规范名称
 * @param name the user-specified name
 * @return the transformed name
 */</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">canonicalName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">canonicalName</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// Handle aliasing...</span>
    <span class="nc">String</span> <span class="n">resolvedName</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="n">resolvedName</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">aliasMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">canonicalName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">resolvedName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">canonicalName</span> <span class="o">=</span> <span class="n">resolvedName</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">resolvedName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">canonicalName</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见transformedBeanName方法由canonicalName和transformedBeanName两个方法组成,transformedBeanName的作用就是判断bean名称是否包含&amp;前缀,不包含直接返回,包含则进行截取.
而canonicalName的作用就是根据截取过的名称确定原始名称.<br />
2.首先尝试从三级缓存中获取bean</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Return the (raw) singleton object registered under the given name.
 * 返回通过给定的名称创建的原始单例对象
 * &lt;p&gt;Checks already instantiated singletons and also allows for an early
 * reference to a currently created singleton (resolving a circular reference).
 * 检查已经初始化的单例 并允许提前引用当前创建的单例 (解决循环引用)
 * @param beanName the name of the bean to look for
 * @param allowEarlyReference whether early references should be created or not
 *                            是否应该创建早期引用
 * @return the registered singleton object, or {@code null} if none found
 */</span>
<span class="nd">@Nullable</span>
<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">getSingleton</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">allowEarlyReference</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//从缓存单例的map查找指定单例</span>
    <span class="nc">Object</span> <span class="n">singletonObject</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
    <span class="c1">//如果当前beanName的实例对象存在则直接返回</span>
    <span class="c1">//如果不存在还要确定当前beanName是否正在创建中  即singletonsCurrentlyInCreation存在该beanName</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">singletonObject</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">isSingletonCurrentlyInCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">//锁住存放单例的map</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//看二级缓存中是否存在早期创建的单例</span>
            <span class="n">singletonObject</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">earlySingletonObjects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="c1">//不存在且允许早期创建单例引用</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">singletonObject</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">allowEarlyReference</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//查看三级缓存中是否存在当前beanName单例工厂</span>
                <span class="nc">ObjectFactory</span><span class="o">&lt;?&gt;</span> <span class="n">singletonFactory</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">singletonFactories</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                <span class="c1">//存在单例工厂则直接获取该单例对象并放入二级缓存singletonsCurrentlyInCreation中 同时将三级缓存中的工厂对象删除</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">singletonFactory</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">singletonObject</span> <span class="o">=</span> <span class="n">singletonFactory</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">earlySingletonObjects</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">singletonObject</span><span class="o">);</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">singletonFactories</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">singletonObject</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见,首先先尝试从一级缓存 <strong>singletonObjects</strong> 中获取,如果存在bean实例则直接返回.
若不存在且当前bean正在创建中,则继续尝试从二级缓存 <strong>earlySingletonObjects</strong> 获取早期创建的bean,存在则直接返回.
若不存在且允许创建早期引用,则继续尝试从三级缓存 <strong>singletonFactories</strong> 中获取单例工厂,存在工厂则创建早期bean引用,并将该早期引用添加到二级缓存 <strong>earlySingletonObjects</strong> 中并将三级缓存 <strong>singletonFactories</strong> 中单例工厂移除.<br />
3.若第二步获取到实例引用,则尝试从bean实例本身或bean工厂中获取</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Get the object for the given bean instance, either the bean
 * instance itself or its created object in case of a FactoryBean.
 * 从给定的bean实例中获取对象,bean实例本身或在FactoryBean的情况下创建bean
 * @param beanInstance the shared bean instance
 * @param name name that may include factory dereference prefix
 * @param beanName the canonical bean name
 * @param mbd the merged bean definition
 * @return the object to expose for the bean
 */</span>
<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">getObjectForBeanInstance</span><span class="o">(</span>
        <span class="nc">Object</span> <span class="n">beanInstance</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span>
    <span class="c1">//如果bean不是工厂，不要让调用代码尝试取消对工厂的引用</span>
    <span class="c1">//1. 如果bean名称是工厂类型,则设置bean定义为工厂bean并返回</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">BeanFactoryUtils</span><span class="o">.</span><span class="na">isFactoryDereference</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">beanInstance</span> <span class="k">instanceof</span> <span class="nc">NullBean</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">beanInstance</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">beanInstance</span> <span class="k">instanceof</span> <span class="nc">FactoryBean</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanIsNotAFactoryException</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">beanInstance</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mbd</span><span class="o">.</span><span class="na">isFactoryBean</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">beanInstance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span>
    <span class="c1">// If it's a FactoryBean, we use it to create a bean instance, unless the</span>
    <span class="c1">// caller actually wants a reference to the factory.</span>
    <span class="c1">//现在我们有bean实例,可能是正常的bean或一个工厂bean.</span>
    <span class="c1">//如果他是一个工厂bean,我们使用它来创建一个bean实例,除非调用者实际上想要对一个对工厂的引用</span>
    <span class="c1">//2. 如果该bean实例不是工厂bean则直接返回</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">beanInstance</span> <span class="k">instanceof</span> <span class="nc">FactoryBean</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">beanInstance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//3. 若该bean名称不包含工厂前缀&amp; 且是FactoryBean 则尝试从缓存中获取 缓存中没有则尝试从工厂中获取</span>
    <span class="nc">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mbd</span><span class="o">.</span><span class="na">isFactoryBean</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="n">object</span> <span class="o">=</span> <span class="n">getCachedObjectForFactoryBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//如果缓存中没有 尝试从工厂中获取</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">object</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Return bean instance from factory.</span>
        <span class="c1">//从工厂中返回bean实例</span>
        <span class="nc">FactoryBean</span><span class="o">&lt;?&gt;</span> <span class="n">factory</span> <span class="o">=</span> <span class="o">(</span><span class="nc">FactoryBean</span><span class="o">&lt;?&gt;)</span> <span class="n">beanInstance</span><span class="o">;</span>
        <span class="c1">// Caches object obtained from FactoryBean if it is a singleton.</span>
        <span class="c1">//如果他是单例的话从工厂bean中获取缓存对象</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">containsBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">mbd</span> <span class="o">=</span> <span class="n">getMergedLocalBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">boolean</span> <span class="n">synthetic</span> <span class="o">=</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">mbd</span><span class="o">.</span><span class="na">isSynthetic</span><span class="o">());</span>
        <span class="n">object</span> <span class="o">=</span> <span class="n">getObjectFromFactoryBean</span><span class="o">(</span><span class="n">factory</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="o">!</span><span class="n">synthetic</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">object</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见这里大约可以分为三步.<br />
  3.1 如果bean名称是工厂类型,则设置bean定义为工厂bean并返回<br />
  3.2 如果该bean实例不是工厂bean则直接返回<br />
  3.3 若该bean名称不包含工厂前缀&amp; 且是FactoryBean 则尝试从缓存中获取 缓存中没有则尝试从工厂中获取<br />
4.若从三级缓存中没有找到实例,那么就直接执行创建bean的逻辑,就下来就好好看下创建bean的逻辑<br />
5.首先检查该bean是否正在创建中,在创建中大概率是遇到循环引用了</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Return whether the specified prototype bean is currently in creation
 * (within the current thread).
 * 返回指定原型的bean是否正在创建中(在当前线程中)
 * @param beanName the name of the bean
 */</span>
<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isPrototypeCurrentlyInCreation</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">curVal</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">prototypesCurrentlyInCreation</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">curVal</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
            <span class="o">(</span><span class="n">curVal</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">beanName</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">curVal</span> <span class="k">instanceof</span> <span class="nc">Set</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="nc">Set</span><span class="o">&lt;?&gt;)</span> <span class="n">curVal</span><span class="o">).</span><span class="na">contains</span><span class="o">(</span><span class="n">beanName</span><span class="o">))));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>6.检查是否存在父bean工厂,若存在且该bean未创建过,则尝试从父bean工厂中获取</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Check if bean definition exists in this factory.</span>
<span class="c1">//检查bean定义是否存在工厂中</span>
<span class="nc">BeanFactory</span> <span class="n">parentBeanFactory</span> <span class="o">=</span> <span class="n">getParentBeanFactory</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="n">parentBeanFactory</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">containsBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// Not found -&gt; check parent.</span>
    <span class="c1">//如果在父bean工厂中没有找到当前bean 则检查父工厂</span>
    <span class="nc">String</span> <span class="n">nameToLookup</span> <span class="o">=</span> <span class="n">originalBeanName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parentBeanFactory</span> <span class="k">instanceof</span> <span class="nc">AbstractBeanFactory</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">((</span><span class="nc">AbstractBeanFactory</span><span class="o">)</span> <span class="n">parentBeanFactory</span><span class="o">).</span><span class="na">doGetBean</span><span class="o">(</span>
                <span class="n">nameToLookup</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">typeCheckOnly</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">args</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Delegation to parent with explicit args.</span>
        <span class="c1">//如果参数不为null,使用显示参数委托给父工厂</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">parentBeanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">nameToLookup</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">requiredType</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// No args -&gt; delegate to standard getBean method.</span>
        <span class="c1">//没有参数 则 委托给标准的getBean方法</span>
        <span class="k">return</span> <span class="n">parentBeanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">nameToLookup</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">parentBeanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">nameToLookup</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  这里就好理解多了,首先查看是否存在父bean工厂,存在且内存中不包含该bean,则尝试从父bean工厂中获取bean<br />
7.若不止类型检查,则标记该bean为已创建</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//如果只是类型检查  需要把bean标记为已创建(或将被创建) 即将beanName添加到alreadyCreated中</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">typeCheckOnly</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">markBeanAsCreated</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Mark the specified bean as already created (or about to be created).
 * 标记指定的bean已经创建(或将被创建)
 * &lt;p&gt;This allows the bean factory to optimize its caching for repeated
 * creation of the specified bean.
 * 这允许bean工厂优化他的缓存以重复创建指定bean
 * @param beanName the name of the bean
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">markBeanAsCreated</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//双重检查,防止在检查的过程中当前bean被添加到alreadyCreated中</span>
    <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">alreadyCreated</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mergedBeanDefinitions</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">alreadyCreated</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// Let the bean definition get re-merged now that we're actually creating</span>
                <span class="c1">// the bean... just in case some of its metadata changed in the meantime.</span>
                <span class="c1">//我们实际上正在创建bean,让bean定义重新合并...以防万一一些元数据在此期间发生了变化</span>
                <span class="c1">//</span>
                <span class="n">clearMergedBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                <span class="k">this</span><span class="o">.</span><span class="na">alreadyCreated</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  此步就是将bean名称添加到alreadyCreated集合中,表明该bean已经创建过了.<br />
8.再次尝试获取合并bean定义,并检查其定义</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//再次获取合并的bean定义</span>
<span class="kd">final</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span> <span class="o">=</span> <span class="n">getMergedLocalBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
<span class="n">checkMergedBeanDefinition</span><span class="o">(</span><span class="n">mbd</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>

<span class="cm">/**
 * Return a merged RootBeanDefinition, traversing the parent bean definition
 * if the specified bean corresponds to a child bean definition.
 * 返回合并的RootBeanDefinition,如果指定的bean对应于子bean定义,则遍历父bean定义
 * @param beanName the name of the bean to retrieve the merged definition for
 *                 要检索合并定义的bean名称
 * @return a (potentially merged) RootBeanDefinition for the given bean
 * 			给定的bean可能合并的RootBeanDefinition
 * @throws NoSuchBeanDefinitionException if there is no bean with the given name
 * @throws BeanDefinitionStoreException in case of an invalid bean definition
 */</span>
<span class="kd">protected</span> <span class="nc">RootBeanDefinition</span> <span class="nf">getMergedLocalBeanDefinition</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
    <span class="c1">// Quick check on the concurrent map first, with minimal locking.</span>
    <span class="c1">// 首先快速检查并发map,使用最小粒度的锁</span>
    <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mergedBeanDefinitions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
    <span class="c1">//如果map中存在该合并定义 且不需要重新合并定义 则直接返回</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">stale</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">mbd</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nf">getMergedBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">getBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">));</span>
<span class="o">}</span>

<span class="cm">/**
 * Check the given merged bean definition,
 * potentially throwing validation exceptions.
 * 检查给定的合并bean定义,潜在的抛出检查异常
 * @param mbd the merged bean definition to check
 * @param beanName the name of the bean
 * @param args the arguments for bean creation, if any
 * @throws BeanDefinitionStoreException in case of validation failure
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">checkMergedBeanDefinition</span><span class="o">(</span><span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">BeanDefinitionStoreException</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isAbstract</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanIsAbstractException</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  获取合并bean定义的方法前面介绍过了,主要就是根据是否存在合并bean定义,不存在或存在且需要重新合成会重新获取,否则直接返回.
检查就更简单了,检查该bean定义是否是抽象的.<br />
9.获取该bean依赖属性,存在则先注册这些依赖属性</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Guarantee initialization of beans that the current bean depends on.</span>
<span class="c1">//保证当前bean所依赖的bean的初始化</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">dependsOn</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getDependsOn</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="n">dependsOn</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">dep</span> <span class="o">:</span> <span class="n">dependsOn</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isDependent</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">dep</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span>
                    <span class="s">"Circular depends-on relationship between '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"' and '"</span> <span class="o">+</span> <span class="n">dep</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">registerDependentBean</span><span class="o">(</span><span class="n">dep</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">getBean</span><span class="o">(</span><span class="n">dep</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">NoSuchBeanDefinitionException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span>
                    <span class="s">"'"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"' depends on missing bean '"</span> <span class="o">+</span> <span class="n">dep</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Register a dependent bean for the given bean,
 * to be destroyed before the given bean is destroyed.
 * 为给定的bean注册一个依赖的bean,在给定的bean被销毁之前被销毁
 * @param beanName the name of the bean
 * @param dependentBeanName the name of the dependent bean
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerDependentBean</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">dependentBeanName</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">canonicalName</span> <span class="o">=</span> <span class="n">canonicalName</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>

    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">dependentBeanMap</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dependentBeans</span> <span class="o">=</span>
                <span class="k">this</span><span class="o">.</span><span class="na">dependentBeanMap</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">canonicalName</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="mi">8</span><span class="o">));</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">dependentBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">dependentBeanName</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">dependenciesForBeanMap</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dependenciesForBean</span> <span class="o">=</span>
                <span class="k">this</span><span class="o">.</span><span class="na">dependenciesForBeanMap</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">dependentBeanName</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="mi">8</span><span class="o">));</span>
        <span class="n">dependenciesForBean</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">canonicalName</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  若该bean存在其依赖属性,则先注册其依赖属性,注册则是将其对应关系存入dependentBeanMap和dependenciesForBeanMap中.<br />
10.这是最重要的一步,根据bean的类型创建bean实例,我们重点关注一下单例的创建</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create bean instance.</span>
<span class="c1">//创建bean实例</span>
<span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">sharedInstance</span> <span class="o">=</span> <span class="n">getSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">createBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">BeansException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Explicitly remove instance from singleton cache: It might have been put there</span>
            <span class="c1">// eagerly by the creation process, to allow for circular reference resolution.</span>
            <span class="c1">// Also remove any beans that received a temporary reference to the bean.</span>
            <span class="n">destroySingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="n">bean</span> <span class="o">=</span> <span class="n">getObjectForBeanInstance</span><span class="o">(</span><span class="n">sharedInstance</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  如果是单例bean的话,通过getSingleton方法获取单例bean,可以看到getSingleton的入参是一个函数式接口传入的bean工厂用于创建bean,最后获取到bean继续尝试从bean实例本身获取bean工厂中获取bean.<br />
  我们接下来先看看getSingleton做了什么:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Return the (raw) singleton object registered under the given name,
 * creating and registering a new one if none registered yet.
 * 返回通过给定名称注册的原始单例对象,如果没有注册的话创建并注册一个新的
 * @param beanName the name of the bean
 * @param singletonFactory the ObjectFactory to lazily create the singleton
 * with, if necessary
 * @return the registered singleton object
 */</span>
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getSingleton</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">ObjectFactory</span><span class="o">&lt;?&gt;</span> <span class="n">singletonFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="s">"Bean name must not be null"</span><span class="o">);</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//1. 判断给定名称是否已经创建过bean对象,存在则直接返回 不存在则创建一个新的</span>
        <span class="nc">Object</span> <span class="n">singletonObject</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">singletonObject</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//2.前置检查</span>
            <span class="c1">//是否处于单例销毁阶段</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">singletonsCurrentlyInDestruction</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationNotAllowedException</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span>
                        <span class="s">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> <span class="o">+</span>
                        <span class="s">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Creating shared instance of singleton bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//判断给定bean名称是否在创建中</span>
            <span class="n">beforeSingletonCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="kt">boolean</span> <span class="n">newSingleton</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">recordSuppressedExceptions</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">suppressedExceptions</span> <span class="o">==</span> <span class="kc">null</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">recordSuppressedExceptions</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">suppressedExceptions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
            <span class="o">}</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">//3. 通过工厂创建bean</span>
                <span class="c1">//调用org.springframework.beans.factory.support.AbstractBeanFactory.createBean方法</span>
                <span class="n">singletonObject</span> <span class="o">=</span> <span class="n">singletonFactory</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
                <span class="c1">//表明是新创建的单例</span>
                <span class="n">newSingleton</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">catch</span> <span class="o">(</span><span class="nc">IllegalStateException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Has the singleton object implicitly appeared in the meantime -&gt;</span>
                <span class="c1">// if yes, proceed with it since the exception indicates that state.</span>
                <span class="c1">// 在此间是否隐式出现了单例对象 -&gt;如果是,则继续处理它,因为异常指示该状态</span>
                <span class="n">singletonObject</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">singletonObject</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">catch</span> <span class="o">(</span><span class="nc">BeanCreationException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">recordSuppressedExceptions</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">for</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">suppressedException</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">suppressedExceptions</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ex</span><span class="o">.</span><span class="na">addRelatedCause</span><span class="o">(</span><span class="n">suppressedException</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">finally</span> <span class="o">{</span>
                <span class="c1">//4. 后置检查</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">recordSuppressedExceptions</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">suppressedExceptions</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">afterSingletonCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//新单例的标志 如果是  则添加到singletonObjects中 并从其他二级缓存中删除</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">newSingleton</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">addSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">singletonObject</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">singletonObject</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>  可见getSingleton可以大约分为四步:</p>
<ol>
  <li>首先锁住一级缓存singletonObjects并尝试从一级缓存中获取该bean,存在则直接返回,不存在则继续创建</li>
  <li>进行前置检查,判断当前bean是否处于销毁中之后再检查该bean是否正在创建中</li>
  <li>检查结束后就是通过传入的bean工厂进行创建bean,具体逻辑下面分析,创建完bean后设置newSingleton为true,表明是新创建的bean</li>
  <li>最后就是后置检查,将bean从singletonsCurrentlyInCreation中移除,并根据newSingleton状态将bean加入一级缓存singletonObjects和registeredSingletons中并从二三级缓存中移除</li>
</ol>

<p>  我们最后再来看看这个createBean的逻辑,它就是真正创建bean的地方:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Central method of this class: creates a bean instance,
 * populates the bean instance, applies post-processors, etc.
 * 该类的中心方法:创建一个bean实例,填充bean实例,应用后置处理器
 * @see #doCreateBean
 */</span>
<span class="nd">@Override</span>
<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">createBean</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">BeanCreationException</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Creating instance of bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">RootBeanDefinition</span> <span class="n">mbdToUse</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">;</span>

    <span class="c1">// Make sure bean class is actually resolved at this point, and</span>
    <span class="c1">// clone the bean definition in case of a dynamically resolved Class</span>
    <span class="c1">// which cannot be stored in the shared merged bean definition.</span>
    <span class="c1">//确保此时真正解析了bean类,并在动态解析类无法存储在共享的合并bean定义中的情况下克隆bean定义</span>
    <span class="c1">//1.解析bean类并将其设置到bean定义</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">resolvedClass</span> <span class="o">=</span> <span class="n">resolveBeanClass</span><span class="o">(</span><span class="n">mbd</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">resolvedClass</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">hasBeanClass</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mbdToUse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RootBeanDefinition</span><span class="o">(</span><span class="n">mbd</span><span class="o">);</span>
        <span class="n">mbdToUse</span><span class="o">.</span><span class="na">setBeanClass</span><span class="o">(</span><span class="n">resolvedClass</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Prepare method overrides.</span>
    <span class="c1">//2. 准备重写的方法</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">mbdToUse</span><span class="o">.</span><span class="na">prepareMethodOverrides</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">BeanDefinitionValidationException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanDefinitionStoreException</span><span class="o">(</span><span class="n">mbdToUse</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span>
                <span class="n">beanName</span><span class="o">,</span> <span class="s">"Validation of method overrides failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span>
        <span class="c1">//3. 给后置处理器一个机会 返回一个代理而不是目标bean实例</span>
        <span class="c1">//执行所有实现InstantiationAwareBeanPostProcessor的后置处理器的初始化前后方法  存在则直接返回bean</span>
        <span class="nc">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">resolveBeforeInstantiation</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbdToUse</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">bean</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">mbdToUse</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span>
                <span class="s">"BeanPostProcessor before instantiation of bean failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//4.真正获取bean的地方</span>
        <span class="nc">Object</span> <span class="n">beanInstance</span> <span class="o">=</span> <span class="n">doCreateBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbdToUse</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Finished creating instance of bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">beanInstance</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">BeanCreationException</span> <span class="o">|</span> <span class="nc">ImplicitlyAppearedSingletonException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// A previously detected exception with proper bean creation context already,</span>
        <span class="c1">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span>
        <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span>
                <span class="n">mbdToUse</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span> <span class="s">"Unexpected exception during bean creation"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见createBean中的核心逻辑还是在doCreateBean,这里才是真正创建bean的地方,这里主要做了一些前置准备和检查.大约可以分为以下四步:</p>
<ol>
  <li>解析bean类并将其设置到bean定义中</li>
  <li>准备所有重写的方法,存在则设置overloaded标记为false</li>
  <li>检查是否存在实现InstantiationAwareBeanPostProcessor的后置处理器,存在则尝试执行其初始化前和初始化后方法,若存在返回的bean则直接返回</li>
  <li>前面都检查过了,最后就是真正创建bean的地方</li>
</ol>

<p>  我们继续看看这个doCreateBean是如何创建bean:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Actually create the specified bean. Pre-creation processing has already happened
 * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.
 * 真正创建一个指定bean.预创建处理在此时已经发生了.例如检查postProcessBeforeInstantiation回调
 * &lt;p&gt;Differentiates between default bean instantiation, use of a
 * factory method, and autowiring a constructor.
 * 区分默认bean实例化,工厂方法的使用和自动装配构造函数
 * @param beanName the name of the bean
 * @param mbd the merged bean definition for the bean
 * @param args explicit arguments to use for constructor or factory method invocation
 * @return a new instance of the bean
 * @throws BeanCreationException if the bean could not be created
 * @see #instantiateBean
 * @see #instantiateUsingFactoryMethod
 * @see #autowireConstructor
 */</span>
<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">doCreateBean</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="kd">final</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">BeanCreationException</span> <span class="o">{</span>

    <span class="c1">// Instantiate the bean.</span>
    <span class="c1">//1.实例化bean包裹类</span>
    <span class="nc">BeanWrapper</span> <span class="n">instanceWrapper</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">//如果当前合bean定义是单例的,移除未完成的bean包裹缓存并返回</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">instanceWrapper</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">factoryBeanInstanceCache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//如果包裹类为空的话 创建bean实例</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instanceWrapper</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">instanceWrapper</span> <span class="o">=</span> <span class="n">createBeanInstance</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">final</span> <span class="nc">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">instanceWrapper</span><span class="o">.</span><span class="na">getWrappedInstance</span><span class="o">();</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanType</span> <span class="o">=</span> <span class="n">instanceWrapper</span><span class="o">.</span><span class="na">getWrappedClass</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanType</span> <span class="o">!=</span> <span class="nc">NullBean</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mbd</span><span class="o">.</span><span class="na">resolvedTargetType</span> <span class="o">=</span> <span class="n">beanType</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Allow post-processors to modify the merged bean definition.</span>
    <span class="c1">//允许后置处理来修改合并的bean定义</span>
    <span class="c1">//2. 执行MergedBeanDefinitionPostProcessor后置处理器逻辑</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">postProcessingLock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">mbd</span><span class="o">.</span><span class="na">postProcessed</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">//执行MergedBeanDefinitionPostProcessors的后置处理</span>
                <span class="n">applyMergedBeanDefinitionPostProcessors</span><span class="o">(</span><span class="n">mbd</span><span class="o">,</span> <span class="n">beanType</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span>
                        <span class="s">"Post-processing of merged bean definition failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//设置处理状态为true</span>
            <span class="n">mbd</span><span class="o">.</span><span class="na">postProcessed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Eagerly cache singletons to be able to resolve circular references</span>
    <span class="c1">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>
    <span class="c1">//急切的缓存单例,以便即使在由BeanFactoryAware等生命周期接口触发时也可以解决循环引用</span>
    <span class="c1">//3. 判断是否需要早期单例暴露,需要则将bean工厂加入三级缓存singletonFactories中</span>
    <span class="c1">//mbd.isSingleton()  当前bean定义是否为单例</span>
    <span class="c1">//this.allowCircularReferences  是否允许循环引用  默认为true</span>
    <span class="c1">//isSingletonCurrentlyInCreation(beanName) 当前单例bean是否在创建中</span>
    <span class="kt">boolean</span> <span class="n">earlySingletonExposure</span> <span class="o">=</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">allowCircularReferences</span> <span class="o">&amp;&amp;</span>
            <span class="n">isSingletonCurrentlyInCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">));</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">earlySingletonExposure</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Eagerly caching bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span>
                    <span class="s">"' to allow for resolving potential circular references"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//如果允许暴露早期单例  将该bean的bean工厂添加到三级缓存 singletonFactories中</span>
        <span class="n">addSingletonFactory</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">getEarlyBeanReference</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">bean</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// Initialize the bean instance.</span>
    <span class="c1">//初始化bean实例</span>
    <span class="nc">Object</span> <span class="n">exposedObject</span> <span class="o">=</span> <span class="n">bean</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//4. 填充属性值</span>
        <span class="n">populateBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">instanceWrapper</span><span class="o">);</span>
        <span class="c1">//5. 初始化bean 调用后置处理器的前置和处置处理方法 和 实现initializingBean的方法以及自定义初始化方法</span>
        <span class="n">exposedObject</span> <span class="o">=</span> <span class="n">initializeBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">exposedObject</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ex</span> <span class="k">instanceof</span> <span class="nc">BeanCreationException</span> <span class="o">&amp;&amp;</span> <span class="n">beanName</span><span class="o">.</span><span class="na">equals</span><span class="o">(((</span><span class="nc">BeanCreationException</span><span class="o">)</span> <span class="n">ex</span><span class="o">).</span><span class="na">getBeanName</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="o">(</span><span class="nc">BeanCreationException</span><span class="o">)</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span>
                    <span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span> <span class="s">"Initialization of bean failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//6. 是否允许暴露早期引用</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">earlySingletonExposure</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">earlySingletonReference</span> <span class="o">=</span> <span class="n">getSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">earlySingletonReference</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">exposedObject</span> <span class="o">==</span> <span class="n">bean</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">exposedObject</span> <span class="o">=</span> <span class="n">earlySingletonReference</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">allowRawInjectionDespiteWrapping</span> <span class="o">&amp;&amp;</span> <span class="n">hasDependentBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">String</span><span class="o">[]</span> <span class="n">dependentBeans</span> <span class="o">=</span> <span class="n">getDependentBeans</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">actualDependentBeans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="n">dependentBeans</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">dependentBean</span> <span class="o">:</span> <span class="n">dependentBeans</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">removeSingletonIfCreatedForTypeCheckOnly</span><span class="o">(</span><span class="n">dependentBean</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">actualDependentBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">dependentBean</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">actualDependentBeans</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCurrentlyInCreationException</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span>
                            <span class="s">"Bean with name '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"' has been injected into other beans ["</span> <span class="o">+</span>
                            <span class="nc">StringUtils</span><span class="o">.</span><span class="na">collectionToCommaDelimitedString</span><span class="o">(</span><span class="n">actualDependentBeans</span><span class="o">)</span> <span class="o">+</span>
                            <span class="s">"] in its raw version as part of a circular reference, but has eventually been "</span> <span class="o">+</span>
                            <span class="s">"wrapped. This means that said other beans do not use the final version of the "</span> <span class="o">+</span>
                            <span class="s">"bean. This is often the result of over-eager type matching - consider using "</span> <span class="o">+</span>
                            <span class="s">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Register bean as disposable.</span>
    <span class="c1">//7. 将bean注册为一次性</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">registerDisposableBeanIfNecessary</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">bean</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">BeanDefinitionValidationException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span>
                <span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span> <span class="s">"Invalid destruction signature"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">exposedObject</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  我们一步一步来看下doCreateBean:<br />
1.首先获取bean包装类,内存中有则直接获取没有则直接创建</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">doCreateBean</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="kd">final</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">BeanCreationException</span> <span class="o">{</span>

    <span class="c1">// Instantiate the bean.</span>
    <span class="c1">//1.实例化bean包裹类</span>
    <span class="nc">BeanWrapper</span> <span class="n">instanceWrapper</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">//如果当前合bean定义是单例的,移除未完成的bean包裹缓存并返回</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">instanceWrapper</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">factoryBeanInstanceCache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//如果包裹类为空的话 创建bean实例</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instanceWrapper</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">instanceWrapper</span> <span class="o">=</span> <span class="n">createBeanInstance</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">final</span> <span class="nc">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">instanceWrapper</span><span class="o">.</span><span class="na">getWrappedInstance</span><span class="o">();</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanType</span> <span class="o">=</span> <span class="n">instanceWrapper</span><span class="o">.</span><span class="na">getWrappedClass</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanType</span> <span class="o">!=</span> <span class="nc">NullBean</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mbd</span><span class="o">.</span><span class="na">resolvedTargetType</span> <span class="o">=</span> <span class="n">beanType</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见首先先尝试从缓存factoryBeanInstanceCache中获取,如果还是null的话则尝试通过createBeanInstance方法创建,最后设置bean定义的resolvedTargetType.<br />
  我们继续看下创建bean包裹类的逻辑:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Create a new instance for the specified bean, using an appropriate instantiation strategy:
 * factory method, constructor autowiring, or simple instantiation.
 * 为指定的bean创建一个新实例, 使用一个适当的实例化策略:工厂方法、构造装配或简单的实例化
 * @param beanName the name of the bean
 * @param mbd the bean definition for the bean
 * @param args explicit arguments to use for constructor or factory method invocation
 * @return a BeanWrapper for the new instance
 * @see #obtainFromSupplier
 * @see #instantiateUsingFactoryMethod
 * @see #autowireConstructor
 * @see #instantiateBean
 */</span>
<span class="kd">protected</span> <span class="nc">BeanWrapper</span> <span class="nf">createBeanInstance</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Make sure bean class is actually resolved at this point.</span>
    <span class="c1">//1. 保证此刻bean类已经真正解析过</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanClass</span> <span class="o">=</span> <span class="n">resolveBeanClass</span><span class="o">(</span><span class="n">mbd</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">beanClass</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">Modifier</span><span class="o">.</span><span class="na">isPublic</span><span class="o">(</span><span class="n">beanClass</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isNonPublicAccessAllowed</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span>
                <span class="s">"Bean class isn't public, and non-public access not allowed: "</span> <span class="o">+</span> <span class="n">beanClass</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="c1">//2. 如果存在创建这个bean实例回调,从回调中获得beanWrapper</span>
    <span class="nc">Supplier</span><span class="o">&lt;?&gt;</span> <span class="n">instanceSupplier</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getInstanceSupplier</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instanceSupplier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">obtainFromSupplier</span><span class="o">(</span><span class="n">instanceSupplier</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//3.如果bean定义存在工厂方法名,尝试使用工厂方法实例化</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getFactoryMethodName</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">instantiateUsingFactoryMethod</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Shortcut when re-creating the same bean...</span>
    <span class="c1">//重新创建一个bean时的快捷方式</span>
    <span class="c1">//4. 检查bean是否是工厂或者构造创建 是则继续判断是通过自动装配构造还是默认构造实例化</span>
    <span class="kt">boolean</span> <span class="n">resolved</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">autowireNecessary</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">constructorArgumentLock</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">resolvedConstructorOrFactoryMethod</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">resolved</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">autowireNecessary</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">constructorArgumentsResolved</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">resolved</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">autowireNecessary</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">autowireConstructor</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">instantiateBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Candidate constructors for autowiring?</span>
    <span class="c1">//自动装配的候选参数</span>
    <span class="c1">//5. 检查后置处理器中是否有自动装配构造函数,有则尝试从自动装配构造创建bean包裹类</span>
    <span class="nc">Constructor</span><span class="o">&lt;?&gt;[]</span> <span class="n">ctors</span> <span class="o">=</span> <span class="n">determineConstructorsFromBeanPostProcessors</span><span class="o">(</span><span class="n">beanClass</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ctors</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getResolvedAutowireMode</span><span class="o">()</span> <span class="o">==</span> <span class="no">AUTOWIRE_CONSTRUCTOR</span> <span class="o">||</span>
            <span class="n">mbd</span><span class="o">.</span><span class="na">hasConstructorArgumentValues</span><span class="o">()</span> <span class="o">||</span> <span class="o">!</span><span class="nc">ObjectUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="n">args</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">autowireConstructor</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">ctors</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Preferred constructors for default construction?</span>
    <span class="c1">//6. 是否存在默认构造的首选构造函数,是则尝试从自动装配构造函数创建</span>
    <span class="n">ctors</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getPreferredConstructors</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ctors</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">autowireConstructor</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">ctors</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// No special handling: simply use no-arg constructor.</span>
    <span class="c1">//7. 没有特殊处理:简单使用无参构造  通常是走这里</span>
    <span class="k">return</span> <span class="nf">instantiateBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见此步就是根据bean指定的构造方式创建bean包裹类.具体逻辑如下:<br />
  1.1 前置检查保证此刻bean类已经真正解析过<br />
  1.2 如果存在创建这个bean实例回调,从回调中获得beanWrapper<br />
  1.3 如果bean定义存在工厂方法名,尝试使用工厂方法实例化<br />
  1.4 检查bean是否是工厂或者构造创建 是则继续判断是通过自动装配构造还是默认构造实例化<br />
  1.5 检查后置处理器中是否有自动装配构造函数,有则尝试从自动装配构造创建bean包裹类<br />
  1.6 是否存在默认构造的首选构造函数,是则尝试从自动装配构造函数创建<br />
  1.7 没有特殊处理:简单使用无参构造  通常是走这里<br />
2.第二步检查postProcessed标记,需要则执行实现MergedBeanDefinitionPostProcessor的后置处理器的postProcessMergedBeanDefinition方法</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Allow post-processors to modify the merged bean definition.</span>
<span class="c1">//允许后置处理来修改合并的bean定义</span>
<span class="kd">synchronized</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">postProcessingLock</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">mbd</span><span class="o">.</span><span class="na">postProcessed</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//执行MergedBeanDefinitionPostProcessors的后置处理</span>
            <span class="n">applyMergedBeanDefinitionPostProcessors</span><span class="o">(</span><span class="n">mbd</span><span class="o">,</span> <span class="n">beanType</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span>
                    <span class="s">"Post-processing of merged bean definition failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//设置处理状态为true</span>
        <span class="n">mbd</span><span class="o">.</span><span class="na">postProcessed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Apply MergedBeanDefinitionPostProcessors to the specified bean definition,
 * invoking their {@code postProcessMergedBeanDefinition} methods.
 * 将MergedBeanDefinitionPostProcessors应用到指定的bean定义,调用他们的postProcessMergedBeanDefinition方法
 * @param mbd the merged bean definition for the bean
 * @param beanType the actual type of the managed bean instance
 * @param beanName the name of the bean
 * @see MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">applyMergedBeanDefinitionPostProcessors</span><span class="o">(</span><span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanType</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//找到所有实现了MergedBeanDefinitionPostProcessor的后置处理器 执行 postProcessMergedBeanDefinition</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">BeanPostProcessor</span> <span class="n">bp</span> <span class="o">:</span> <span class="n">getBeanPostProcessors</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bp</span> <span class="k">instanceof</span> <span class="nc">MergedBeanDefinitionPostProcessor</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">MergedBeanDefinitionPostProcessor</span> <span class="n">bdp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MergedBeanDefinitionPostProcessor</span><span class="o">)</span> <span class="n">bp</span><span class="o">;</span>
            <span class="n">bdp</span><span class="o">.</span><span class="na">postProcessMergedBeanDefinition</span><span class="o">(</span><span class="n">mbd</span><span class="o">,</span> <span class="n">beanType</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见就是检查postProcessed是否为false,是则遍历所有实现MergedBeanDefinitionPostProcessor接口的后置处理器,执行postProcessMergedBeanDefinition逻辑,最后再设置postProcessed状态为true,表明已处理过了.<br />
3.防止bean循环引用的前置检查,将bean工厂添加到三级缓存中</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Eagerly cache singletons to be able to resolve circular references</span>
<span class="c1">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>
<span class="c1">//急切的缓存单例,以便即使在由BeanFactoryAware等生命周期接口触发时也可以解决循环引用</span>
<span class="c1">//早期单例暴露标志</span>
<span class="c1">//mbd.isSingleton()  当前bean定义是否为单例</span>
<span class="c1">//this.allowCircularReferences  是否允许循环引用  默认为true</span>
<span class="c1">//isSingletonCurrentlyInCreation(beanName) 当前单例bean是否在创建中</span>
<span class="kt">boolean</span> <span class="n">earlySingletonExposure</span> <span class="o">=</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">allowCircularReferences</span> <span class="o">&amp;&amp;</span>
        <span class="n">isSingletonCurrentlyInCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">));</span>
<span class="k">if</span> <span class="o">(</span><span class="n">earlySingletonExposure</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Eagerly caching bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span>
                <span class="s">"' to allow for resolving potential circular references"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//如果允许暴露早期单例  将该bean的bean工厂添加到三级缓存 singletonFactories中</span>
    <span class="n">addSingletonFactory</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">getEarlyBeanReference</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">bean</span><span class="o">));</span>
<span class="o">}</span>

<span class="cm">/**
 * Add the given singleton factory for building the specified singleton
 * if necessary.
 * 如果需要的话 为创建指定单例添加一个给定的单例工厂
 * &lt;p&gt;To be called for eager registration of singletons, e.g. to be able to
 * resolve circular references.
 * @param beanName the name of the bean
 * @param singletonFactory the factory for the singleton object
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">addSingletonFactory</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">ObjectFactory</span><span class="o">&lt;?&gt;</span> <span class="n">singletonFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">singletonFactory</span><span class="o">,</span> <span class="s">"Singleton factory must not be null"</span><span class="o">);</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">singletonFactories</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">singletonFactory</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">earlySingletonObjects</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">registeredSingletons</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  检查当前bean是否是单例且允许循环引用且当前bean正在创建中,如果允许暴露早期引用的话,则将创建bean引用的工厂添加到三级缓存singletonFactories中<br />
4.填充属性值,这也是非常重要的一步,填充属性和后置处理器的逻辑也在这里</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Populate the bean instance in the given BeanWrapper with the property values
 * from the bean definition.
 * 使用bean定义中的属性值填充给定BeanWrapper中的bean实例
 * @param beanName the name of the bean
 * @param mbd the bean definition for the bean
 * @param bw the BeanWrapper with bean instance
 */</span>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"deprecation"</span><span class="o">)</span>  <span class="c1">// for postProcessPropertyValues</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">populateBean</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">BeanWrapper</span> <span class="n">bw</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//1.前置检查bean包裹类</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bw</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">hasPropertyValues</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span>
                    <span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">,</span> <span class="s">"Cannot apply property values to null instance"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// Skip property population phase for null instance.</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span>
    <span class="c1">// state of the bean before properties are set. This can be used, for example,</span>
    <span class="c1">// to support styles of field injection.</span>
    <span class="c1">//在设置属性前让任何InstantiationAwareBeanPostProcessors有机会修改bean的状态,.</span>
    <span class="c1">//例如这可用于支持字段注入样式</span>
    <span class="kt">boolean</span> <span class="n">continueWithPropertyPopulation</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="c1">//找到所有实现了InstantiationAwareBeanPostProcessor的后置处理器  执行postProcessAfterInstantiation方法</span>
    <span class="c1">//2. 检查bean定义是否不是合成的 且含有实现了InstantiationAwareBeanPostProcessor的后置处理器 有则执行其postProcessAfterInstantiation 根据其返回结果判定是否需要继续填充属性 不需要直接返回</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSynthetic</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">hasInstantiationAwareBeanPostProcessors</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">BeanPostProcessor</span> <span class="n">bp</span> <span class="o">:</span> <span class="n">getBeanPostProcessors</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bp</span> <span class="k">instanceof</span> <span class="nc">InstantiationAwareBeanPostProcessor</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">InstantiationAwareBeanPostProcessor</span> <span class="n">ibp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InstantiationAwareBeanPostProcessor</span><span class="o">)</span> <span class="n">bp</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">ibp</span><span class="o">.</span><span class="na">postProcessAfterInstantiation</span><span class="o">(</span><span class="n">bw</span><span class="o">.</span><span class="na">getWrappedInstance</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">continueWithPropertyPopulation</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(!</span><span class="n">continueWithPropertyPopulation</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//3. 根据bean的属性值和自动装配码 来装配属性</span>
    <span class="c1">//获取当前bean定义的属性值</span>
    <span class="nc">PropertyValues</span> <span class="n">pvs</span> <span class="o">=</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">hasPropertyValues</span><span class="o">()</span> <span class="o">?</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">);</span>

    <span class="c1">//获取解析过的自动装配码  根据类型和名称进行装配</span>
    <span class="kt">int</span> <span class="n">resolvedAutowireMode</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getResolvedAutowireMode</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">resolvedAutowireMode</span> <span class="o">==</span> <span class="no">AUTOWIRE_BY_NAME</span> <span class="o">||</span> <span class="n">resolvedAutowireMode</span> <span class="o">==</span> <span class="no">AUTOWIRE_BY_TYPE</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MutablePropertyValues</span> <span class="n">newPvs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutablePropertyValues</span><span class="o">(</span><span class="n">pvs</span><span class="o">);</span>
        <span class="c1">// Add property values based on autowire by name if applicable.</span>
        <span class="c1">//如果适用通过名称自动装配新增属性值</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">resolvedAutowireMode</span> <span class="o">==</span> <span class="no">AUTOWIRE_BY_NAME</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">autowireByName</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">bw</span><span class="o">,</span> <span class="n">newPvs</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Add property values based on autowire by type if applicable.</span>
        <span class="c1">//如果适用通过类型自动装配新增属性值</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">resolvedAutowireMode</span> <span class="o">==</span> <span class="no">AUTOWIRE_BY_TYPE</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">autowireByType</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">bw</span><span class="o">,</span> <span class="n">newPvs</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">pvs</span> <span class="o">=</span> <span class="n">newPvs</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//4.检查是否含有InstantiationAwareBeanPostProcessor后置处理器和是否需要检查依赖属性 需要则调用后置处理器和执行依赖属性检查</span>
    <span class="c1">//是否含有InstantiationAwareBeanPostProcessor后置处理器</span>
    <span class="kt">boolean</span> <span class="n">hasInstAwareBpps</span> <span class="o">=</span> <span class="n">hasInstantiationAwareBeanPostProcessors</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="n">needsDepCheck</span> <span class="o">=</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getDependencyCheck</span><span class="o">()</span> <span class="o">!=</span> <span class="nc">AbstractBeanDefinition</span><span class="o">.</span><span class="na">DEPENDENCY_CHECK_NONE</span><span class="o">);</span>

    <span class="nc">PropertyDescriptor</span><span class="o">[]</span> <span class="n">filteredPds</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hasInstAwareBpps</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pvs</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pvs</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//遍历所有实现InstantiationAwareBeanPostProcessor的后置处理器 通过postProcessProperties</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">BeanPostProcessor</span> <span class="n">bp</span> <span class="o">:</span> <span class="n">getBeanPostProcessors</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bp</span> <span class="k">instanceof</span> <span class="nc">InstantiationAwareBeanPostProcessor</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">InstantiationAwareBeanPostProcessor</span> <span class="n">ibp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InstantiationAwareBeanPostProcessor</span><span class="o">)</span> <span class="n">bp</span><span class="o">;</span>
                <span class="nc">PropertyValues</span> <span class="n">pvsToUse</span> <span class="o">=</span> <span class="n">ibp</span><span class="o">.</span><span class="na">postProcessProperties</span><span class="o">(</span><span class="n">pvs</span><span class="o">,</span> <span class="n">bw</span><span class="o">.</span><span class="na">getWrappedInstance</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">pvsToUse</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">filteredPds</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">filteredPds</span> <span class="o">=</span> <span class="n">filterPropertyDescriptorsForDependencyCheck</span><span class="o">(</span><span class="n">bw</span><span class="o">,</span> <span class="n">mbd</span><span class="o">.</span><span class="na">allowCaching</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="n">pvsToUse</span> <span class="o">=</span> <span class="n">ibp</span><span class="o">.</span><span class="na">postProcessPropertyValues</span><span class="o">(</span><span class="n">pvs</span><span class="o">,</span> <span class="n">filteredPds</span><span class="o">,</span> <span class="n">bw</span><span class="o">.</span><span class="na">getWrappedInstance</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">pvsToUse</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">pvs</span> <span class="o">=</span> <span class="n">pvsToUse</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">needsDepCheck</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">filteredPds</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">filteredPds</span> <span class="o">=</span> <span class="n">filterPropertyDescriptorsForDependencyCheck</span><span class="o">(</span><span class="n">bw</span><span class="o">,</span> <span class="n">mbd</span><span class="o">.</span><span class="na">allowCaching</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">checkDependencies</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">filteredPds</span><span class="o">,</span> <span class="n">pvs</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//5. 若属性不为空,则将属性应用到bean包裹类中</span>
    <span class="c1">//如果存在属性值 则解析相关属性 通常是类中的属性 通过getBean创建相关bean 定义</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pvs</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">applyPropertyValues</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">bw</span><span class="o">,</span> <span class="n">pvs</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见填充属性大约可以分为5步,我们仔细分析下:<br />
  4.1 首先前置检查bean包裹类没什么好说的<br />
  4.2 然后检查bean定义是否不是合成的且是否含有实现了InstantiationAwareBeanPostProcessor的后置处理器,值有则执行其postProcessAfterInstantiation,根据其返回结果判定是否需要继续填充属性,不需要则设置continueWithPropertyPopulation为false,下面直接返回<br />
  4.3 根据bean的属性值和自动装配码,自动装配要么根据类型要么根据名称进行装配<br />
  4.4 检查是否含有InstantiationAwareBeanPostProcessor后置处理器和是否需要检查依赖属性,需要则调用后置处理器和执行依赖属性检查.找到所有实现了InstantiationAwareBeanPostProcessor的后置处理器执行postProcessProperties逻辑,若返回值pvsToUse为空则执行填充属性值postProcessPropertyValues和过滤依赖检查的属性filterPropertyDescriptorsForDependencyCheck<br />
  4.5 若填充后的属性pvs不为空,则将这些属性应用到bean包裹类中<br />
5.bean填充过属性后,就是初始化bean,主要是调用后置处理器的前置和处置处理方法和实现initializingBean的方法以及自定义初始化方法</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Initialize the given bean instance, applying factory callbacks
 * as well as init methods and bean post processors.
 * 初始化给定的bean实例,应用工厂回调以及init方法和bean后置处理器
 * &lt;p&gt;Called from {@link #createBean} for traditionally defined beans,
 * and from {@link #initializeBean} for existing bean instances.
 * 从createBean调用传统意义上的bean,从initializeBean调用现有bean实例。
 * @param beanName the bean name in the factory (for debugging purposes)
 * @param bean the new bean instance we may need to initialize
 * @param mbd the bean definition that the bean was created with
 * (can also be {@code null}, if given an existing bean instance)
 * @return the initialized bean instance (potentially wrapped)
 * @see BeanNameAware
 * @see BeanClassLoaderAware
 * @see BeanFactoryAware
 * @see #applyBeanPostProcessorsBeforeInitialization
 * @see #invokeInitMethods
 * @see #applyBeanPostProcessorsAfterInitialization
 */</span>
<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">initializeBean</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">((</span><span class="nc">PrivilegedAction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">invokeAwareMethods</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">},</span> <span class="n">getAccessControlContext</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">//1. 调用相关Aware的接口</span>
        <span class="n">invokeAwareMethods</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//2. 若bean定义为null或bean定义不是合成的 则执行后置处理的前置初始化postProcessBeforeInitialization</span>
    <span class="nc">Object</span> <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">bean</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSynthetic</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">//调用后置处理器中的初始化之前的方法  postProcessBeforeInitialization</span>
        <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">applyBeanPostProcessorsBeforeInitialization</span><span class="o">(</span><span class="n">wrappedBean</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//3. 调用初始化方法  先是实现了InitializingBean接口的方法 再上类自定义的初始化方法</span>
        <span class="n">invokeInitMethods</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">wrappedBean</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span>
                <span class="o">(</span><span class="n">mbd</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">),</span>
                <span class="n">beanName</span><span class="o">,</span> <span class="s">"Invocation of init method failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//4. 若bean定义为null或bean定义不是合成的 则执行后置处理的后置初始化postProcessAfterInitialization</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSynthetic</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">//调用后置处理器初始化之后的方法	postProcessAfterInitialization</span>
        <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">applyBeanPostProcessorsAfterInitialization</span><span class="o">(</span><span class="n">wrappedBean</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">wrappedBean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见第五步就是执行bean相关的初始化接口,主要有4处:<br />
  5.1首先调用bean实现的相关aware接口</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//调用实现相关Aware接口</span>
<span class="c1">//如果实现了BeanNameAware接口  则调用setBeanName将bean名称设置进去</span>
<span class="c1">//如果实现了BeanClassLoaderAware接口 则调用setBeanClassLoader将类加载器设置进去</span>
<span class="c1">//如果实现了BeanFactoryAware接口 则调用setBeanFactory将bean工厂设置进去</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">invokeAwareMethods</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">bean</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">Aware</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">BeanNameAware</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">((</span><span class="nc">BeanNameAware</span><span class="o">)</span> <span class="n">bean</span><span class="o">).</span><span class="na">setBeanName</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">BeanClassLoaderAware</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ClassLoader</span> <span class="n">bcl</span> <span class="o">=</span> <span class="n">getBeanClassLoader</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bcl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">((</span><span class="nc">BeanClassLoaderAware</span><span class="o">)</span> <span class="n">bean</span><span class="o">).</span><span class="na">setBeanClassLoader</span><span class="o">(</span><span class="n">bcl</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">BeanFactoryAware</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">((</span><span class="nc">BeanFactoryAware</span><span class="o">)</span> <span class="n">bean</span><span class="o">).</span><span class="na">setBeanFactory</span><span class="o">(</span><span class="nc">AbstractAutowireCapableBeanFactory</span><span class="o">.</span><span class="na">this</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  看到代码就很清楚了,就是根据不同的aware接口设置不同的属性到bean中<br />
  5.2若bean定义为null或bean定义不是合成的 则执行后置处理的前置初始化postProcessBeforeInitialization</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">applyBeanPostProcessorsBeforeInitialization</span><span class="o">(</span><span class="nc">Object</span> <span class="n">existingBean</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>

    <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">existingBean</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">BeanPostProcessor</span> <span class="n">processor</span> <span class="o">:</span> <span class="n">getBeanPostProcessors</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">current</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="na">postProcessBeforeInitialization</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  第二步就是执行所有后置处理器的前置逻辑postProcessBeforeInitialization处理所有bean<br />
  5.3调用初始化方法,先是实现了InitializingBean接口的方法 再上类自定义的初始化方法</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Give a bean a chance to react now all its properties are set,
 * and a chance to know about its owning bean factory (this object).
 * 现在给bean一个反应机会,他的所有属性都已经设置,并有机会了解其拥有的bean工厂
 * This means checking whether the bean implements InitializingBean or defines
 * a custom init method, and invoking the necessary callback(s) if it does.
 * 这意味的检查bean是否实现了InitializingBean或定义一个自定义的初始化方法,且 如果有必要的话调用必要的回调
 * @param beanName the bean name in the factory (for debugging purposes)
 * @param bean the new bean instance we may need to initialize
 * @param mbd the merged bean definition that the bean was created with
 * (can also be {@code null}, if given an existing bean instance)
 * @throws Throwable if thrown by init methods or by the invocation process
 * @see #invokeCustomInitMethod
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">invokeInitMethods</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>

    <span class="c1">//当前bean是否实现了InitializingBean接口 实现了则调用afterPropertiesSet方法</span>
    <span class="kt">boolean</span> <span class="n">isInitializingBean</span> <span class="o">=</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">InitializingBean</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isInitializingBean</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isExternallyManagedInitMethod</span><span class="o">(</span><span class="s">"afterPropertiesSet"</span><span class="o">)))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Invoking afterPropertiesSet() on bean with name '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">((</span><span class="nc">PrivilegedExceptionAction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="o">((</span><span class="nc">InitializingBean</span><span class="o">)</span> <span class="n">bean</span><span class="o">).</span><span class="na">afterPropertiesSet</span><span class="o">();</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">},</span> <span class="n">getAccessControlContext</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">catch</span> <span class="o">(</span><span class="nc">PrivilegedActionException</span> <span class="n">pae</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="n">pae</span><span class="o">.</span><span class="na">getException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="o">((</span><span class="nc">InitializingBean</span><span class="o">)</span> <span class="n">bean</span><span class="o">).</span><span class="na">afterPropertiesSet</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//调用自定义初始化方法</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">bean</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="nc">NullBean</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">initMethodName</span> <span class="o">=</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getInitMethodName</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasLength</span><span class="o">(</span><span class="n">initMethodName</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                <span class="o">!(</span><span class="n">isInitializingBean</span> <span class="o">&amp;&amp;</span> <span class="s">"afterPropertiesSet"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">initMethodName</span><span class="o">))</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isExternallyManagedInitMethod</span><span class="o">(</span><span class="n">initMethodName</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">invokeCustomInitMethod</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">bean</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  第三步先判断bean是否实现了InitializingBean,实现了则执行afterPropertiesSet方法.然后判断bean是否有自定义的init方法,有则执行<br />
  5.4 然后就是后置逻辑,若bean定义为null或bean定义不是合成的则执行后置处理的后置初始化postProcessAfterInitialization<br />
  5.5 最后bean就初始化完成返回此bean<br />
6.检查是否允许暴露早期引用,允许则尝试创建早期引用</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//是否允许暴露早期引用</span>
<span class="k">if</span> <span class="o">(</span><span class="n">earlySingletonExposure</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">earlySingletonReference</span> <span class="o">=</span> <span class="n">getSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">earlySingletonReference</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">exposedObject</span> <span class="o">==</span> <span class="n">bean</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">exposedObject</span> <span class="o">=</span> <span class="n">earlySingletonReference</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">allowRawInjectionDespiteWrapping</span> <span class="o">&amp;&amp;</span> <span class="n">hasDependentBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">dependentBeans</span> <span class="o">=</span> <span class="n">getDependentBeans</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">actualDependentBeans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="n">dependentBeans</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">dependentBean</span> <span class="o">:</span> <span class="n">dependentBeans</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">removeSingletonIfCreatedForTypeCheckOnly</span><span class="o">(</span><span class="n">dependentBean</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">actualDependentBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">dependentBean</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">actualDependentBeans</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCurrentlyInCreationException</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span>
                        <span class="s">"Bean with name '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"' has been injected into other beans ["</span> <span class="o">+</span>
                        <span class="nc">StringUtils</span><span class="o">.</span><span class="na">collectionToCommaDelimitedString</span><span class="o">(</span><span class="n">actualDependentBeans</span><span class="o">)</span> <span class="o">+</span>
                        <span class="s">"] in its raw version as part of a circular reference, but has eventually been "</span> <span class="o">+</span>
                        <span class="s">"wrapped. This means that said other beans do not use the final version of the "</span> <span class="o">+</span>
                        <span class="s">"bean. This is often the result of over-eager type matching - consider using "</span> <span class="o">+</span>
                        <span class="s">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  若允许暴露早期引用的话,则尝试从三级缓存中获取早期引用,获取到则直接返回;没获取到则继续检查依赖的bean.<br />
7.最后将bean注册为一次性并返回创建的bean</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Add the given bean to the list of disposable beans in this factory,
 * registering its DisposableBean interface and/or the given destroy method
 * to be called on factory shutdown (if applicable). Only applies to singletons.
 * 将给定的bean添加到此工厂的一次性bean列表中,注册disposableBean的接口或在工厂关闭时调用给定销毁方法.只应用于单例
 * @param beanName the name of the bean
 * @param bean the bean instance
 * @param mbd the bean definition for the bean
 * @see RootBeanDefinition#isSingleton
 * @see RootBeanDefinition#getDependsOn
 * @see #registerDisposableBean
 * @see #registerDependentBean
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">registerDisposableBeanIfNecessary</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">AccessControlContext</span> <span class="n">acc</span> <span class="o">=</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">getAccessControlContext</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isPrototype</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">requiresDestruction</span><span class="o">(</span><span class="n">bean</span><span class="o">,</span> <span class="n">mbd</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Register a DisposableBean implementation that performs all destruction</span>
            <span class="c1">// work for the given bean: DestructionAwareBeanPostProcessors,</span>
            <span class="c1">// DisposableBean interface, custom destroy method.</span>
            <span class="n">registerDisposableBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span>
                    <span class="k">new</span> <span class="nf">DisposableBeanAdapter</span><span class="o">(</span><span class="n">bean</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">getBeanPostProcessors</span><span class="o">(),</span> <span class="n">acc</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// A bean with a custom scope...</span>
            <span class="nc">Scope</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">scopes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">getScope</span><span class="o">());</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">scope</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"No Scope registered for scope name '"</span> <span class="o">+</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getScope</span><span class="o">()</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">scope</span><span class="o">.</span><span class="na">registerDestructionCallback</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span>
                    <span class="k">new</span> <span class="nf">DisposableBeanAdapter</span><span class="o">(</span><span class="n">bean</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">getBeanPostProcessors</span><span class="o">(),</span> <span class="n">acc</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  若bean不是原型且需要关闭时销毁继续判断bean是否为单例,为单例直接将bean添加到disposableBeans中,不是单例则则注册销毁回调</p>

<p>11.检查需要的类型是否匹配真正bean实例的类型</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Check if required type matches the type of the actual bean instance.</span>
<span class="c1">//11. 检查需要的类型是否匹配真正bean实例的类型</span>
<span class="k">if</span> <span class="o">(</span><span class="n">requiredType</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">requiredType</span><span class="o">.</span><span class="na">isInstance</span><span class="o">(</span><span class="n">bean</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="no">T</span> <span class="n">convertedBean</span> <span class="o">=</span> <span class="n">getTypeConverter</span><span class="o">().</span><span class="na">convertIfNecessary</span><span class="o">(</span><span class="n">bean</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">convertedBean</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanNotOfRequiredTypeException</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">bean</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">convertedBean</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">TypeMismatchException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Failed to convert bean '"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"' to required type '"</span> <span class="o">+</span>
                    <span class="nc">ClassUtils</span><span class="o">.</span><span class="na">getQualifiedName</span><span class="o">(</span><span class="n">requiredType</span><span class="o">)</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanNotOfRequiredTypeException</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">bean</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见这里根据入参传的requiredType判断是否需要将bean装换为requiredType需要的bean类型,并将转换后的类型返回<br />
12.最后返回创建的bean</p>
<hr />

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">October 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000007" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SpringBoot启动源码解析(七)</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-maverick-coltman-3214311.jpg" class="img-responsive img-centered" alt="SpringBoot">

                            
                                <h3>SpringBootApplication Refresh方法解析:processConfigBeanDefinitions</h3>
                            
                            </div>

                            <p><h3 id="流程图">流程图</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry流程图.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry流程图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry流程图.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry流程图</div>
    </a>
</center>
<hr />
<h3 id="方法入口">方法入口</h3>
<hr />
<p>调用路径:<br />
refresh() -&gt;<br />
invokeBeanFactoryPostProcessors(beanFactory) -&gt;<br />
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors,registry) -&gt; <br />
ConfigurationClassPostProcessor.processConfigBeanDefinitions()</p>

<p>源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Build and validate a configuration model based on the registry of
 * {@link Configuration} classes.
 * 基于Configuration类的注册表构建和验证配置模型
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processConfigBeanDefinitions</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//1.获取注册表中已注册的bean定义,并挑选出配置类候选(使用@Configuration注解的类)并加入到configCandidates中</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">configCandidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinitionNames</span><span class="o">();</span>

    <span class="c1">//从前面加载的候选者中找到被@Configuration修饰的类并把该类封装为BeanDefinitionHolder</span>
    <span class="c1">//主要是处理主函数类</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">candidateNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BeanDefinition</span> <span class="n">beanDef</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">beanDef</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">CONFIGURATION_CLASS_ATTRIBUTE</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Bean definition has already been processed as a configuration class: "</span> <span class="o">+</span> <span class="n">beanDef</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">checkConfigurationClassCandidate</span><span class="o">(</span><span class="n">beanDef</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">//将匹配的bean添加到配置候选者中</span>
            <span class="n">configCandidates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanDefinitionHolder</span><span class="o">(</span><span class="n">beanDef</span><span class="o">,</span> <span class="n">beanName</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Return immediately if no @Configuration classes were found</span>
    <span class="c1">//如果没有发现@Configuration配置的类直接返回</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">configCandidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">//2. 解析前置操作:根据@Order排序候选者、设置bean名称生成策略、设置Environment、最重要的就是创建ConfigurationClassParser解析器</span>
    <span class="c1">// Sort by previously determined @Order value, if applicable</span>
    <span class="c1">//如果适用的话,根据先前确定的@Order的值排序  order值越小优先级越高</span>
    <span class="n">configCandidates</span><span class="o">.</span><span class="na">sort</span><span class="o">((</span><span class="n">bd1</span><span class="o">,</span> <span class="n">bd2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">getOrder</span><span class="o">(</span><span class="n">bd1</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">());</span>
        <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">getOrder</span><span class="o">(</span><span class="n">bd2</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">());</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">i1</span><span class="o">,</span> <span class="n">i2</span><span class="o">);</span>
    <span class="o">});</span>

    <span class="c1">// Detect any custom bean name generation strategy supplied through the enclosing application context</span>
    <span class="c1">//检测 通过封闭应用上下文提供的任何自定义bean名称生成策略</span>
    <span class="nc">SingletonBeanRegistry</span> <span class="n">sbr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">registry</span> <span class="k">instanceof</span> <span class="nc">SingletonBeanRegistry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sbr</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SingletonBeanRegistry</span><span class="o">)</span> <span class="n">registry</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">localBeanNameGeneratorSet</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">BeanNameGenerator</span> <span class="n">generator</span> <span class="o">=</span> <span class="o">(</span><span class="nc">BeanNameGenerator</span><span class="o">)</span> <span class="n">sbr</span><span class="o">.</span><span class="na">getSingleton</span><span class="o">(</span>
                    <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">CONFIGURATION_BEAN_NAME_GENERATOR</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">generator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">componentScanBeanNameGenerator</span> <span class="o">=</span> <span class="n">generator</span><span class="o">;</span>
                <span class="k">this</span><span class="o">.</span><span class="na">importBeanNameGenerator</span> <span class="o">=</span> <span class="n">generator</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StandardEnvironment</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Parse each @Configuration class</span>
    <span class="c1">//解析每一个@Configuration修饰的类</span>
    <span class="nc">ConfigurationClassParser</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConfigurationClassParser</span><span class="o">(</span>
            <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">problemReporter</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span>
            <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">componentScanBeanNameGenerator</span><span class="o">,</span> <span class="n">registry</span><span class="o">);</span>
    
    <span class="c1">//3. 通过ConfigurationClassParser的parse方法解析候选类 也就是主函数</span>
    <span class="c1">//3.1 首先通过parse方法进行解析主函数,这里就将所有的注解都解析的干干净净 具体逻辑稍后分析</span>
    <span class="c1">//3.1 解析完后进行验证,主要验证解析后配置类及其中的属性是否合法</span>
    <span class="c1">//3.3 此时已经将所有的配置类都解析好了,但是还有通过@Import或@Bean或@ImportedResources或ImportBeanDefinitionRegister的bean未注册,这步就是注册这些类的</span>
    <span class="c1">//3.4 最后就是筛选出所有已经真正解析过的配置类 若存在未解析的加入到candidates中继续进行解析</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="n">configCandidates</span><span class="o">);</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ConfigurationClass</span><span class="o">&gt;</span> <span class="n">alreadyParsed</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">configCandidates</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="c1">//使用ConfigurationClassParser解析每一个配置候选者</span>
        <span class="c1">//即解析主函数 主要作用是 解析每个注解</span>
        <span class="c1">//1.@PropertySource</span>
        <span class="c1">//2.@ComponentScan 根据注解的路径扫描所有需要加载的配置类  默认是扫描主类下的所有文件</span>
        <span class="c1">//3.@Import 根据@Import注解加载所有的导入类  最重要的是通过SpringBoot中的AutoConfigurationImportSelector来加载所有自动配置的类</span>
        <span class="c1">//4.@ImportResource</span>
        <span class="c1">//5.@Bean</span>
        <span class="c1">//6.default methods on interfaces</span>
        <span class="c1">//7.Process superclass</span>
        <span class="n">parser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">candidates</span><span class="o">);</span>
        <span class="n">parser</span><span class="o">.</span><span class="na">validate</span><span class="o">();</span>

        <span class="c1">//4. 通过reader.loadBeanDefinitions方法注册导入的配置类自身、相关@Bean方法导入的类、@ImportResource导入的类和@Import导入的类的定义</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ConfigurationClass</span><span class="o">&gt;</span> <span class="n">configClasses</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="n">parser</span><span class="o">.</span><span class="na">getConfigurationClasses</span><span class="o">());</span>
        <span class="n">configClasses</span><span class="o">.</span><span class="na">removeAll</span><span class="o">(</span><span class="n">alreadyParsed</span><span class="o">);</span>

        <span class="c1">// Read the model and create bean definitions based on its content</span>
        <span class="c1">//读取模型并根据其内容创建bean定义</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">reader</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConfigurationClassBeanDefinitionReader</span><span class="o">(</span>
                    <span class="n">registry</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">sourceExtractor</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">importBeanNameGenerator</span><span class="o">,</span> <span class="n">parser</span><span class="o">.</span><span class="na">getImportRegistry</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">//将解析过的配置类中的一些属性注册为bean定义</span>
        <span class="k">this</span><span class="o">.</span><span class="na">reader</span><span class="o">.</span><span class="na">loadBeanDefinitions</span><span class="o">(</span><span class="n">configClasses</span><span class="o">);</span>
        <span class="c1">//alreadyParsed存放所有实例化过的配置类</span>
        <span class="n">alreadyParsed</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">configClasses</span><span class="o">);</span>

        <span class="n">candidates</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        
        <span class="c1">//5.最后检测后扫描到的配置类中是否有未扫描到的,存在则加入到candidates中继续解析</span>
        <span class="c1">//如果注册表中的bean定义数量 大于 之前 加载的候选类数量</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinitionCount</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//最新的候选配置类数组</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">newCandidateNames</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinitionNames</span><span class="o">();</span>
            <span class="c1">//旧的候选配置类集合</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">oldCandidateNames</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">candidateNames</span><span class="o">));</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">alreadyParsedClasses</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
            <span class="c1">//添加到alreadyParsedClasses中</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configurationClass</span> <span class="o">:</span> <span class="n">alreadyParsed</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">alreadyParsedClasses</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">configurationClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="c1">//比较新旧候选类  只有不存在于旧的候选者集合 且 属于配置候选者 才添加到candidates</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">candidateName</span> <span class="o">:</span> <span class="n">newCandidateNames</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">oldCandidateNames</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">candidateName</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">BeanDefinition</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">candidateName</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">checkConfigurationClassCandidate</span><span class="o">(</span><span class="n">bd</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">!</span><span class="n">alreadyParsedClasses</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">bd</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">()))</span> <span class="o">{</span>
                        <span class="n">candidates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanDefinitionHolder</span><span class="o">(</span><span class="n">bd</span><span class="o">,</span> <span class="n">candidateName</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">newCandidateNames</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">candidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">());</span>

    <span class="c1">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span>
    <span class="c1">//将ImportRegistry注册为一个bean 为了支持ImportAware的配置类</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sbr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sbr</span><span class="o">.</span><span class="na">containsSingleton</span><span class="o">(</span><span class="no">IMPORT_REGISTRY_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">sbr</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="no">IMPORT_REGISTRY_BEAN_NAME</span><span class="o">,</span> <span class="n">parser</span><span class="o">.</span><span class="na">getImportRegistry</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span> <span class="k">instanceof</span> <span class="nc">CachingMetadataReaderFactory</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span>
        <span class="c1">// for a shared cache since it'll be cleared by the ApplicationContext.</span>
        <span class="c1">//清除外部提供的MetadataReaderFactory中的缓存; 这是共享缓存的空操作,因为它将被ApplicationContext清除</span>
        <span class="o">((</span><span class="nc">CachingMetadataReaderFactory</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">).</span><span class="na">clearCache</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>由此可见 <strong>processConfigBeanDefinitions</strong> 主要分为五步:</p>
<ol>
  <li>获取注册表中已注册的bean定义,并挑选出配置类候选(使用@Configuration注解的类)并加入到configCandidates中</li>
  <li>解析前置操作:根据@Order排序候选者、设置bean名称生成策略、设置Environment、最重要的就是创建ConfigurationClassParser解析器</li>
  <li>通过ConfigurationClassParser的parse方法解析候选类 也就是主函数(核心逻辑),总结来说就是解析配置类上的所有注解属性并将这些bean添加到bean工厂中</li>
  <li>通过reader.loadBeanDefinitions方法加载所有的配置类,其中注册导入的配置类自身、相关@Bean方法导入的类、@ImportResource导入的类和@Import导入的类的定义</li>
  <li>最后检测后扫描到的配置类中是否有未扫描到的,存在则加入到candidates中继续解析</li>
</ol>

<hr />

<h3 id="processconfigbeandefinitions源码解析">processConfigBeanDefinitions源码解析</h3>
<hr />

<ol>
  <li>既然是要解析配置类,肯定要先找到符合条件的配置类,相关源码如下:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Build and validate a configuration model based on the registry of
 * {@link Configuration} classes.
 * 基于Configuration类的注册表构建和验证配置模型
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processConfigBeanDefinitions</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">//1.获取注册表中已注册的bean定义,并挑选出配置类候选(使用@Configuration注解的类)并加入到configCandidates中</span>
 <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">configCandidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
 <span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinitionNames</span><span class="o">();</span>

 <span class="c1">//从前面加载的候选者中找到被@Configuration修饰的类并把该类封装为BeanDefinitionHolder</span>
 <span class="c1">//主要是处理主函数类</span>
 <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">candidateNames</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">BeanDefinition</span> <span class="n">beanDef</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">beanDef</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">CONFIGURATION_CLASS_ATTRIBUTE</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
             <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Bean definition has already been processed as a configuration class: "</span> <span class="o">+</span> <span class="n">beanDef</span><span class="o">);</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">checkConfigurationClassCandidate</span><span class="o">(</span><span class="n">beanDef</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">))</span> <span class="o">{</span>
         <span class="c1">//将匹配的bean添加到配置候选者中</span>
         <span class="n">configCandidates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanDefinitionHolder</span><span class="o">(</span><span class="n">beanDef</span><span class="o">,</span> <span class="n">beanName</span><span class="o">));</span>
     <span class="o">}</span>
 <span class="o">}</span>

 <span class="c1">// Return immediately if no @Configuration classes were found</span>
 <span class="c1">//如果没有发现@Configuration配置的类直接返回</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">configCandidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
     <span class="k">return</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="o">...</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  遍历注册表中所有的bean定义,再通过 <strong>ConfigurationClassUtils.checkConfigurationClassCandidate</strong> 方法判断是否满足配置类条件.满足条件则加入到configCandidates中.最后若configCandidates为空则直接返回.<br />
  我们继续往看看这个检查配置类的方法做了什么:</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
        * Check whether the given bean definition is a candidate for a configuration class
        * (or a nested component class declared within a configuration/component class,
        * to be auto-registered as well), and mark it accordingly.
        * 检查给定的bean定义是否是配置类的候选者(或在配置/组件类中声明的嵌套组件类,也可以自动注册),并且相应的标记他
        * @param beanDef the bean definition to check
        * @param metadataReaderFactory the current factory in use by the caller
        * @return whether the candidate qualifies as (any kind of) configuration class
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkConfigurationClassCandidate</span><span class="o">(</span>
     <span class="nc">BeanDefinition</span> <span class="n">beanDef</span><span class="o">,</span> <span class="nc">MetadataReaderFactory</span> <span class="n">metadataReaderFactory</span><span class="o">)</span> <span class="o">{</span>

 <span class="nc">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">beanDef</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">();</span>
 <span class="c1">//1.当前bean定义无类名 一般是内部类类名为null 不存在返回false</span>
 <span class="c1">//2.当前bean定义存在工厂方法名 存在则返回false</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">className</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">beanDef</span><span class="o">.</span><span class="na">getFactoryMethodName</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="c1">//根据bean定义获取注解元数据</span>
 <span class="nc">AnnotationMetadata</span> <span class="n">metadata</span><span class="o">;</span>
 <span class="c1">//当前bean定义是否属于注解相关的bean定义</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">beanDef</span> <span class="k">instanceof</span> <span class="nc">AnnotatedBeanDefinition</span> <span class="o">&amp;&amp;</span>
         <span class="c1">//当前bean定义的类名是否与AnnotationMetadata的类名一致</span>
         <span class="n">className</span><span class="o">.</span><span class="na">equals</span><span class="o">(((</span><span class="nc">AnnotatedBeanDefinition</span><span class="o">)</span> <span class="n">beanDef</span><span class="o">).</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">()))</span> <span class="o">{</span>
     <span class="c1">// Can reuse the pre-parsed metadata from the given BeanDefinition...</span>
     <span class="c1">// 可以重复使用来自给定bean定义的预解析元数据   主要获取启动类的元数据</span>
     <span class="n">metadata</span> <span class="o">=</span> <span class="o">((</span><span class="nc">AnnotatedBeanDefinition</span><span class="o">)</span> <span class="n">beanDef</span><span class="o">).</span><span class="na">getMetadata</span><span class="o">();</span>
 <span class="o">}</span>
 <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">beanDef</span> <span class="k">instanceof</span> <span class="nc">AbstractBeanDefinition</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="nc">AbstractBeanDefinition</span><span class="o">)</span> <span class="n">beanDef</span><span class="o">).</span><span class="na">hasBeanClass</span><span class="o">())</span> <span class="o">{</span>
     <span class="c1">// Check already loaded Class if present...</span>
     <span class="c1">//检查已加载的类 如果存在的话</span>
     <span class="c1">// since we possibly can't even load the class file for this Class.</span>
     <span class="c1">//因为我们甚至可能无法加载此类的类文件</span>
     <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanClass</span> <span class="o">=</span> <span class="o">((</span><span class="nc">AbstractBeanDefinition</span><span class="o">)</span> <span class="n">beanDef</span><span class="o">).</span><span class="na">getBeanClass</span><span class="o">();</span>
     <span class="k">if</span> <span class="o">(</span><span class="nc">BeanFactoryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">beanClass</span><span class="o">)</span> <span class="o">||</span>
             <span class="nc">BeanPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">beanClass</span><span class="o">)</span> <span class="o">||</span>
             <span class="nc">AopInfrastructureBean</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">beanClass</span><span class="o">)</span> <span class="o">||</span>
             <span class="nc">EventListenerFactory</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">beanClass</span><span class="o">))</span> <span class="o">{</span>
         <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="n">metadata</span> <span class="o">=</span> <span class="nc">AnnotationMetadata</span><span class="o">.</span><span class="na">introspect</span><span class="o">(</span><span class="n">beanClass</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="k">else</span> <span class="o">{</span>
     <span class="k">try</span> <span class="o">{</span>
         <span class="nc">MetadataReader</span> <span class="n">metadataReader</span> <span class="o">=</span> <span class="n">metadataReaderFactory</span><span class="o">.</span><span class="na">getMetadataReader</span><span class="o">(</span><span class="n">className</span><span class="o">);</span>
         <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadataReader</span><span class="o">.</span><span class="na">getAnnotationMetadata</span><span class="o">();</span>
     <span class="o">}</span>
     <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
             <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Could not find class file for introspecting configuration annotations: "</span> <span class="o">+</span>
                     <span class="n">className</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
         <span class="o">}</span>
         <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
     <span class="o">}</span>
 <span class="o">}</span>

 <span class="c1">//从元数据中获取Configuration注解的属性</span>
 <span class="c1">//若bean定义被@Configuration修饰 且 proxyBeanMethods不为false 则设置configurationClass属性为full</span>
 <span class="c1">//若bean定义被@Component、@ComponentScan、@Import、@ImportResource和@Bean修饰 则设置configurationClass属性为lite</span>
 <span class="c1">//否则表明没有被@Configuration修饰  直接返回false</span>
 <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">config</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="na">getAnnotationAttributes</span><span class="o">(</span><span class="nc">Configuration</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">config</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">Boolean</span><span class="o">.</span><span class="na">FALSE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"proxyBeanMethods"</span><span class="o">)))</span> <span class="o">{</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="no">CONFIGURATION_CLASS_ATTRIBUTE</span><span class="o">,</span> <span class="no">CONFIGURATION_CLASS_FULL</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">config</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">isConfigurationCandidate</span><span class="o">(</span><span class="n">metadata</span><span class="o">))</span> <span class="o">{</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="no">CONFIGURATION_CLASS_ATTRIBUTE</span><span class="o">,</span> <span class="no">CONFIGURATION_CLASS_LITE</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="k">else</span> <span class="o">{</span>
     <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="c1">// It's a full or lite configuration candidate... Let's determine the order value, if any.</span>
 <span class="c1">//他是完整或精简的配置候选  确认他的优先级值,如果有的话</span>
 <span class="nc">Integer</span> <span class="n">order</span> <span class="o">=</span> <span class="n">getOrder</span><span class="o">(</span><span class="n">metadata</span><span class="o">);</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">order</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="no">ORDER_ATTRIBUTE</span><span class="o">,</span> <span class="n">order</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="c1">//最后返回true  已经解析过配置 表明是被@Configuration修饰的类</span>
 <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  第一步就是找到满足候选者添加的bean,首先保证该bean不存在bean名称且它的工厂方法名必须为空,即表明它是一个真正的类且不是工厂方法.<br />
  然后获取该bean定义的注解元数据,用处肯定就是获取 <strong>@Configuration</strong> 的配置了,在根据配置的 <strong>proxyBeanMethods</strong> 属性设置bean定义的 <strong>configurationClass</strong> 属性.若bean定义是被 <strong>@Configration</strong> 修饰的则该属性为 <strong>full</strong> ;若该属性是被 <strong>@Component、@ComponentScan、@Import、@ImportResource</strong> 修饰的则该属性为 <strong>lite</strong>.<br />
  若存在 <strong>@Order</strong> 属性则设置它的优先级,处理到此时说明该bean已经是候选配置类了,直接返回true.</p>
    <blockquote>
      <p>第一步的主要作用就是根据@Configuration的属性检查使用被@Configuration修饰,并设置相应的属性到bean定义中,满足条件则加入到configCandidates中.</p>
    </blockquote>
  </li>
  <li>第一步已经找到符合条件的配置类了,那么第二步就是为解析做准备:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Build and validate a configuration model based on the registry of
 * {@link Configuration} classes.
 * 基于Configuration类的注册表构建和验证配置模型
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processConfigBeanDefinitions</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
 <span class="o">...</span>
    
 <span class="c1">//2. 解析前置操作:根据@Order排序候选者、设置bean名称生成策略、设置Environment、最重要的就是创建ConfigurationClassParser解析器</span>
 <span class="c1">// Sort by previously determined @Order value, if applicable</span>
 <span class="c1">//如果适用的话,根据先前确定的@Order的值排序  order值越小优先级越高</span>
 <span class="n">configCandidates</span><span class="o">.</span><span class="na">sort</span><span class="o">((</span><span class="n">bd1</span><span class="o">,</span> <span class="n">bd2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
     <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">getOrder</span><span class="o">(</span><span class="n">bd1</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">());</span>
     <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">getOrder</span><span class="o">(</span><span class="n">bd2</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">());</span>
     <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">i1</span><span class="o">,</span> <span class="n">i2</span><span class="o">);</span>
 <span class="o">});</span>

 <span class="c1">// Detect any custom bean name generation strategy supplied through the enclosing application context</span>
 <span class="c1">//检测 通过封闭应用上下文提供的任何自定义bean名称生成策略</span>
 <span class="nc">SingletonBeanRegistry</span> <span class="n">sbr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">registry</span> <span class="k">instanceof</span> <span class="nc">SingletonBeanRegistry</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">sbr</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SingletonBeanRegistry</span><span class="o">)</span> <span class="n">registry</span><span class="o">;</span>
     <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">localBeanNameGeneratorSet</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">BeanNameGenerator</span> <span class="n">generator</span> <span class="o">=</span> <span class="o">(</span><span class="nc">BeanNameGenerator</span><span class="o">)</span> <span class="n">sbr</span><span class="o">.</span><span class="na">getSingleton</span><span class="o">(</span>
                 <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">CONFIGURATION_BEAN_NAME_GENERATOR</span><span class="o">);</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">generator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">this</span><span class="o">.</span><span class="na">componentScanBeanNameGenerator</span> <span class="o">=</span> <span class="n">generator</span><span class="o">;</span>
             <span class="k">this</span><span class="o">.</span><span class="na">importBeanNameGenerator</span> <span class="o">=</span> <span class="n">generator</span><span class="o">;</span>
         <span class="o">}</span>
     <span class="o">}</span>
 <span class="o">}</span>

 <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StandardEnvironment</span><span class="o">();</span>
 <span class="o">}</span>

 <span class="c1">// Parse each @Configuration class</span>
 <span class="c1">//解析每一个@Configuration修饰的类</span>
 <span class="nc">ConfigurationClassParser</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConfigurationClassParser</span><span class="o">(</span>
         <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">problemReporter</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span>
         <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">componentScanBeanNameGenerator</span><span class="o">,</span> <span class="n">registry</span><span class="o">);</span>
    
 <span class="o">...</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  由上可见,首先将configCandidates中的配置类根据 <strong>@Order</strong> 的值排序,然后设置bean名称生成器和环境,最后也是最重要的生成 <strong>ConfigurationClassParser</strong> 配置类解析器.</p>
    <blockquote>
      <p>第二步的主要作用就是在准备ConfigurationClassParser配置类解析器.</p>
    </blockquote>
  </li>
  <li>第三步就是最最重要的一步了,解析配置类:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Build and validate a configuration model based on the registry of
 * {@link Configuration} classes.
 * 基于Configuration类的注册表构建和验证配置模型
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processConfigBeanDefinitions</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
 <span class="o">...</span>
    
 <span class="c1">//3. 通过ConfigurationClassParser的parse方法解析候选类 也就是主函数</span>
 <span class="c1">//3.1 首先通过parse方法进行解析主函数,这里就将所有的注解都解析的干干净净 具体逻辑稍后分析</span>
 <span class="c1">//3.1 解析完后进行验证,主要验证解析后配置类及其中的属性是否合法</span>
 <span class="c1">//3.3 此时已经将所有的配置类都解析好了,但是还有通过@Import或@Bean或@ImportedResources或ImportBeanDefinitionRegister的bean未注册,这步就是注册这些类的</span>
 <span class="c1">//3.4 最后就是筛选出所有已经真正解析过的配置类 若存在未解析的加入到candidates中继续进行解析</span>
 <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="n">configCandidates</span><span class="o">);</span>
 <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ConfigurationClass</span><span class="o">&gt;</span> <span class="n">alreadyParsed</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">configCandidates</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
 <span class="k">do</span> <span class="o">{</span>
     <span class="c1">//使用ConfigurationClassParser解析每一个配置候选者</span>
     <span class="c1">//即解析主函数 主要作用是 解析每个注解</span>
     <span class="c1">//1.@PropertySource</span>
     <span class="c1">//2.@ComponentScan 根据注解的路径扫描所有需要加载的配置类  默认是扫描主类下的所有文件</span>
     <span class="c1">//3.@Import 根据@Import注解加载所有的导入类  最重要的是通过SpringBoot中的AutoConfigurationImportSelector来加载所有自动配置的类</span>
     <span class="c1">//4.@ImportResource</span>
     <span class="c1">//5.@Bean</span>
     <span class="c1">//6.default methods on interfaces</span>
     <span class="c1">//7.Process superclass</span>
     <span class="n">parser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">candidates</span><span class="o">);</span>
     <span class="n">parser</span><span class="o">.</span><span class="na">validate</span><span class="o">();</span>

     <span class="o">...</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>全部的解析动作都在 <strong>parser.parse()</strong> 中,我们继续往下看源码:</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">configCandidates</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">//1. 判断候选配置类定义属于哪种bean定义 执行相应的解析方法</span>
 <span class="k">for</span> <span class="o">(</span><span class="nc">BeanDefinitionHolder</span> <span class="n">holder</span> <span class="o">:</span> <span class="n">configCandidates</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">BeanDefinition</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">();</span>
     <span class="k">try</span> <span class="o">{</span>
         <span class="c1">//如果该bean定义是注解类型的bean定义 调用AnnotatedBeanDefinition中的parse方法</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">bd</span> <span class="k">instanceof</span> <span class="nc">AnnotatedBeanDefinition</span><span class="o">)</span> <span class="o">{</span>
             <span class="n">parse</span><span class="o">(((</span><span class="nc">AnnotatedBeanDefinition</span><span class="o">)</span> <span class="n">bd</span><span class="o">).</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">());</span>
         <span class="o">}</span>
         <span class="c1">//如果该bean定义是实现与AbstractBeanDefinition的注解 且该bean定义是否指定了一个bean类 是则调用AbstractBeanDefinition中的parse方法</span>
         <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">bd</span> <span class="k">instanceof</span> <span class="nc">AbstractBeanDefinition</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="nc">AbstractBeanDefinition</span><span class="o">)</span> <span class="n">bd</span><span class="o">).</span><span class="na">hasBeanClass</span><span class="o">())</span> <span class="o">{</span>
             <span class="n">parse</span><span class="o">(((</span><span class="nc">AbstractBeanDefinition</span><span class="o">)</span> <span class="n">bd</span><span class="o">).</span><span class="na">getBeanClass</span><span class="o">(),</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">());</span>
         <span class="o">}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="n">parse</span><span class="o">(</span><span class="n">bd</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">(),</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">());</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="k">catch</span> <span class="o">(</span><span class="nc">BeanDefinitionStoreException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanDefinitionStoreException</span><span class="o">(</span>
                 <span class="s">"Failed to parse configuration class ["</span> <span class="o">+</span> <span class="n">bd</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
     <span class="o">}</span>
 <span class="o">}</span>

 <span class="c1">//2. 处理DeferredImportSelector的子类 主要要是AutoConfigurationImportSelector 用来加载所有的EnableAutoConfiguration的子类</span>
 <span class="k">this</span><span class="o">.</span><span class="na">deferredImportSelectorHandler</span><span class="o">.</span><span class="na">process</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  可见解析分为两步,第一步根据bean定义的不同类型调用 <strong>parse()</strong> 方法进行解析配置类的所有注解,第二步就是调用 <strong>deferredImportSelectorHandler.process()</strong> 来处理 <strong>@Import</strong> 导入的自动配置类.详细解析流程见下.</p>
    <blockquote>
      <p>第三步的主要作用就是解析配置类,即找到通过@PropertySource、@ComponentScan、@Import、@ImportResource、@Bean指定的配置类</p>
    </blockquote>
  </li>
  <li>第四步通过 <strong>ConfigurationClassBeanDefinitionReader.loadBeanDefinitions</strong> 方法加载所有的配置类,源码如下:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Read {@code configurationModel}, registering bean definitions
 * with the registry based on its contents.
 * 读取configurationModel,根据其内容向注册表注册bean定义
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">loadBeanDefinitions</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ConfigurationClass</span><span class="o">&gt;</span> <span class="n">configurationModel</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">TrackedConditionEvaluator</span> <span class="n">trackedConditionEvaluator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TrackedConditionEvaluator</span><span class="o">();</span>
 <span class="k">for</span> <span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span> <span class="o">:</span> <span class="n">configurationModel</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">loadBeanDefinitionsForConfigurationClass</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">trackedConditionEvaluator</span><span class="o">);</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  可见它遍历所有的配置类,调用 <strong>loadBeanDefinitionsForConfigurationClass</strong> 方法来进行加载,其源码如下:</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Read a particular {@link ConfigurationClass}, registering bean definitions
 * for the class itself and all of its {@link Bean} methods.
 * 读取特定的ConfigurationClass类,为类本身及其所有Bean方法注册bean定义
 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">loadBeanDefinitionsForConfigurationClass</span><span class="o">(</span>
     <span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">TrackedConditionEvaluator</span> <span class="n">trackedConditionEvaluator</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">//1.检验是否需要跳过 还是通过 @Conditional注解</span>
 <span class="c1">//若跳过则将当前配置类从注册中心和导入列表中移除</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">trackedConditionEvaluator</span><span class="o">.</span><span class="na">shouldSkip</span><span class="o">(</span><span class="n">configClass</span><span class="o">))</span> <span class="o">{</span>
     <span class="nc">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="n">configClass</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">();</span>
     <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasLength</span><span class="o">(</span><span class="n">beanName</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">.</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
         <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">.</span><span class="na">removeBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="k">this</span><span class="o">.</span><span class="na">importRegistry</span><span class="o">.</span><span class="na">removeImportingClass</span><span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
     <span class="k">return</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="c1">//2.判断该类是否由@Import导入的</span>
 <span class="c1">//是则将自身作为bean定义注册</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">isImported</span><span class="o">())</span> <span class="o">{</span>
     <span class="n">registerBeanDefinitionForImportedConfigurationClass</span><span class="o">(</span><span class="n">configClass</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="c1">//3.获取配置类的bean方法 来注册bean定义</span>
 <span class="k">for</span> <span class="o">(</span><span class="nc">BeanMethod</span> <span class="n">beanMethod</span> <span class="o">:</span> <span class="n">configClass</span><span class="o">.</span><span class="na">getBeanMethods</span><span class="o">())</span> <span class="o">{</span>
     <span class="n">loadBeanDefinitionsForBeanMethod</span><span class="o">(</span><span class="n">beanMethod</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="c1">//4.从ImportedResources中注册bean定义</span>
 <span class="n">loadBeanDefinitionsFromImportedResources</span><span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getImportedResources</span><span class="o">());</span>
 <span class="c1">//5.从ImportBeanDefinitionRegister中注册bean定义 主要是针对AutoConfigurationPackages.Registrar.class</span>
 <span class="n">loadBeanDefinitionsFromRegistrars</span><span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getImportBeanDefinitionRegistrars</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  可见 <strong>loadBeanDefinitionsForConfigurationClass</strong> 可以分为五步:<br />
4.1 第一步前置检查,通过 <strong>@Conditional</strong> 配置检查该配置类是否需要跳过,若需要跳过则从注册中心和导入列表中移除该配置类<br />
4.2 第二步判断该配置类是否通过 <strong>@Import</strong> 导入的,若是,则将配置类自身作为bean定义注册. <strong>registerBeanDefinitionForImportedConfigurationClass</strong> 源码如下:</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Register the {@link Configuration} class itself as a bean definition.
 * 注册Configuration类自身作为bean定义
 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">registerBeanDefinitionForImportedConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">AnnotationMetadata</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">();</span>
 <span class="c1">//通过配置类的元数据创建通用配置注解类</span>
 <span class="nc">AnnotatedGenericBeanDefinition</span> <span class="n">configBeanDef</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotatedGenericBeanDefinition</span><span class="o">(</span><span class="n">metadata</span><span class="o">);</span>

 <span class="nc">ScopeMetadata</span> <span class="n">scopeMetadata</span> <span class="o">=</span> <span class="n">scopeMetadataResolver</span><span class="o">.</span><span class="na">resolveScopeMetadata</span><span class="o">(</span><span class="n">configBeanDef</span><span class="o">);</span>
 <span class="n">configBeanDef</span><span class="o">.</span><span class="na">setScope</span><span class="o">(</span><span class="n">scopeMetadata</span><span class="o">.</span><span class="na">getScopeName</span><span class="o">());</span>
 <span class="nc">String</span> <span class="n">configBeanName</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">importBeanNameGenerator</span><span class="o">.</span><span class="na">generateBeanName</span><span class="o">(</span><span class="n">configBeanDef</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
 <span class="c1">//处理通用注解</span>
 <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">processCommonDefinitionAnnotations</span><span class="o">(</span><span class="n">configBeanDef</span><span class="o">,</span> <span class="n">metadata</span><span class="o">);</span>

 <span class="c1">//创建bean定义持有者 并注册到注册表中</span>
 <span class="nc">BeanDefinitionHolder</span> <span class="n">definitionHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BeanDefinitionHolder</span><span class="o">(</span><span class="n">configBeanDef</span><span class="o">,</span> <span class="n">configBeanName</span><span class="o">);</span>
 <span class="n">definitionHolder</span> <span class="o">=</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">applyScopedProxyMode</span><span class="o">(</span><span class="n">scopeMetadata</span><span class="o">,</span> <span class="n">definitionHolder</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
 <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">.</span><span class="na">registerBeanDefinition</span><span class="o">(</span><span class="n">definitionHolder</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">(),</span> <span class="n">definitionHolder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">());</span>
 <span class="c1">//注册bean定义</span>
 <span class="n">configClass</span><span class="o">.</span><span class="na">setBeanName</span><span class="o">(</span><span class="n">configBeanName</span><span class="o">);</span>

 <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
     <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Registered bean definition for imported class '"</span> <span class="o">+</span> <span class="n">configBeanName</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>    </div>
    <p>  这段代码就比较清楚了,将配置类封装为AnnotatedGenericBeanDefinition并设置其属性,最后将其注册到注册中心中.<br />
 4.3 第三步则是处理所有@Bean方法,相关源码如下:</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
        * Read the given {@link BeanMethod}, registering bean definitions
        * with the BeanDefinitionRegistry based on its contents.
        * 读取给定的bean方法,根据其内容向BeanDefinitionRegistry注册bean定义
 */</span>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"deprecation"</span><span class="o">)</span>  <span class="c1">// for RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">loadBeanDefinitionsForBeanMethod</span><span class="o">(</span><span class="nc">BeanMethod</span> <span class="n">beanMethod</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">ConfigurationClass</span> <span class="n">configClass</span> <span class="o">=</span> <span class="n">beanMethod</span><span class="o">.</span><span class="na">getConfigurationClass</span><span class="o">();</span>
 <span class="nc">MethodMetadata</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">beanMethod</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">();</span>
 <span class="nc">String</span> <span class="n">methodName</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="na">getMethodName</span><span class="o">();</span>

 <span class="c1">// Do we need to mark the bean as skipped by its condition?</span>
 <span class="c1">//我们是否需要通过他的条件将这个bean标记为跳过</span>
 <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">conditionEvaluator</span><span class="o">.</span><span class="na">shouldSkip</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">REGISTER_BEAN</span><span class="o">))</span> <span class="o">{</span>
     <span class="n">configClass</span><span class="o">.</span><span class="na">skippedBeanMethods</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">methodName</span><span class="o">);</span>
     <span class="k">return</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">skippedBeanMethods</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">methodName</span><span class="o">))</span> <span class="o">{</span>
     <span class="k">return</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="nc">AnnotationAttributes</span> <span class="n">bean</span> <span class="o">=</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesFor</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">Bean</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
 <span class="nc">Assert</span><span class="o">.</span><span class="na">state</span><span class="o">(</span><span class="n">bean</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"No @Bean annotation attributes"</span><span class="o">);</span>

 <span class="c1">// Consider name and any aliases</span>
 <span class="c1">//考虑名称和任何别名</span>
 <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">bean</span><span class="o">.</span><span class="na">getStringArray</span><span class="o">(</span><span class="s">"name"</span><span class="o">)));</span>
 <span class="nc">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="o">(!</span><span class="n">names</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="n">names</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">methodName</span><span class="o">);</span>

 <span class="c1">// Register aliases even when overridden</span>
 <span class="c1">//即使被覆盖也注册别名</span>
 <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">alias</span> <span class="o">:</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">.</span><span class="na">registerAlias</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">alias</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="c1">// Has this effectively been overridden before (e.g. via XML)?</span>
 <span class="c1">// 这之前是否有效的被注册</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">isOverriddenByExistingDefinition</span><span class="o">(</span><span class="n">beanMethod</span><span class="o">,</span> <span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">beanName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">beanMethod</span><span class="o">.</span><span class="na">getConfigurationClass</span><span class="o">().</span><span class="na">getBeanName</span><span class="o">()))</span> <span class="o">{</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanDefinitionStoreException</span><span class="o">(</span><span class="n">beanMethod</span><span class="o">.</span><span class="na">getConfigurationClass</span><span class="o">().</span><span class="na">getResource</span><span class="o">().</span><span class="na">getDescription</span><span class="o">(),</span>
                 <span class="n">beanName</span><span class="o">,</span> <span class="s">"Bean name derived from @Bean method '"</span> <span class="o">+</span> <span class="n">beanMethod</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getMethodName</span><span class="o">()</span> <span class="o">+</span>
                 <span class="s">"' clashes with bean name for containing configuration class; please make those names unique!"</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="k">return</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="nc">ConfigurationClassBeanDefinition</span> <span class="n">beanDef</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConfigurationClassBeanDefinition</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">metadata</span><span class="o">);</span>
 <span class="n">beanDef</span><span class="o">.</span><span class="na">setResource</span><span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getResource</span><span class="o">());</span>
 <span class="n">beanDef</span><span class="o">.</span><span class="na">setSource</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">sourceExtractor</span><span class="o">.</span><span class="na">extractSource</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="n">configClass</span><span class="o">.</span><span class="na">getResource</span><span class="o">()));</span>

 <span class="c1">//当前bean方法是否为静态方法</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">metadata</span><span class="o">.</span><span class="na">isStatic</span><span class="o">())</span> <span class="o">{</span>
     <span class="c1">// static @Bean method</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">()</span> <span class="k">instanceof</span> <span class="nc">StandardAnnotationMetadata</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">beanDef</span><span class="o">.</span><span class="na">setBeanClass</span><span class="o">(((</span><span class="nc">StandardAnnotationMetadata</span><span class="o">)</span> <span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">()).</span><span class="na">getIntrospectedClass</span><span class="o">());</span>
     <span class="o">}</span>
     <span class="k">else</span> <span class="o">{</span>
         <span class="n">beanDef</span><span class="o">.</span><span class="na">setBeanClassName</span><span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
     <span class="o">}</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setUniqueFactoryMethodName</span><span class="o">(</span><span class="n">methodName</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="k">else</span> <span class="o">{</span>
     <span class="c1">// instance @Bean method</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setFactoryBeanName</span><span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">());</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setUniqueFactoryMethodName</span><span class="o">(</span><span class="n">methodName</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="k">if</span> <span class="o">(</span><span class="n">metadata</span> <span class="k">instanceof</span> <span class="nc">StandardMethodMetadata</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setResolvedFactoryMethod</span><span class="o">(((</span><span class="nc">StandardMethodMetadata</span><span class="o">)</span> <span class="n">metadata</span><span class="o">).</span><span class="na">getIntrospectedMethod</span><span class="o">());</span>
 <span class="o">}</span>

 <span class="n">beanDef</span><span class="o">.</span><span class="na">setAutowireMode</span><span class="o">(</span><span class="nc">AbstractBeanDefinition</span><span class="o">.</span><span class="na">AUTOWIRE_CONSTRUCTOR</span><span class="o">);</span>
 <span class="n">beanDef</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">beans</span><span class="o">.</span><span class="na">factory</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">RequiredAnnotationBeanPostProcessor</span><span class="o">.</span>
         <span class="no">SKIP_REQUIRED_CHECK_ATTRIBUTE</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">.</span><span class="na">TRUE</span><span class="o">);</span>

 <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">processCommonDefinitionAnnotations</span><span class="o">(</span><span class="n">beanDef</span><span class="o">,</span> <span class="n">metadata</span><span class="o">);</span>

 <span class="c1">//设置bean的属性</span>
 <span class="nc">Autowire</span> <span class="n">autowire</span> <span class="o">=</span> <span class="n">bean</span><span class="o">.</span><span class="na">getEnum</span><span class="o">(</span><span class="s">"autowire"</span><span class="o">);</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">autowire</span><span class="o">.</span><span class="na">isAutowire</span><span class="o">())</span> <span class="o">{</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setAutowireMode</span><span class="o">(</span><span class="n">autowire</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
 <span class="o">}</span>

 <span class="kt">boolean</span> <span class="n">autowireCandidate</span> <span class="o">=</span> <span class="n">bean</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"autowireCandidate"</span><span class="o">);</span>
 <span class="k">if</span> <span class="o">(!</span><span class="n">autowireCandidate</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setAutowireCandidate</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="nc">String</span> <span class="n">initMethodName</span> <span class="o">=</span> <span class="n">bean</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"initMethod"</span><span class="o">);</span>
 <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasText</span><span class="o">(</span><span class="n">initMethodName</span><span class="o">))</span> <span class="o">{</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setInitMethodName</span><span class="o">(</span><span class="n">initMethodName</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="nc">String</span> <span class="n">destroyMethodName</span> <span class="o">=</span> <span class="n">bean</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"destroyMethod"</span><span class="o">);</span>
 <span class="n">beanDef</span><span class="o">.</span><span class="na">setDestroyMethodName</span><span class="o">(</span><span class="n">destroyMethodName</span><span class="o">);</span>

 <span class="c1">// Consider scoping</span>
 <span class="c1">//考虑范围</span>
 <span class="nc">ScopedProxyMode</span> <span class="n">proxyMode</span> <span class="o">=</span> <span class="nc">ScopedProxyMode</span><span class="o">.</span><span class="na">NO</span><span class="o">;</span>
 <span class="nc">AnnotationAttributes</span> <span class="n">attributes</span> <span class="o">=</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesFor</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">Scope</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">attributes</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">beanDef</span><span class="o">.</span><span class="na">setScope</span><span class="o">(</span><span class="n">attributes</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"value"</span><span class="o">));</span>
     <span class="n">proxyMode</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="na">getEnum</span><span class="o">(</span><span class="s">"proxyMode"</span><span class="o">);</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">proxyMode</span> <span class="o">==</span> <span class="nc">ScopedProxyMode</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">proxyMode</span> <span class="o">=</span> <span class="nc">ScopedProxyMode</span><span class="o">.</span><span class="na">NO</span><span class="o">;</span>
     <span class="o">}</span>
 <span class="o">}</span>

 <span class="c1">// Replace the original bean definition with the target one, if necessary</span>
 <span class="c1">//如果有必要 将原始bean替换为目标bean</span>
 <span class="nc">BeanDefinition</span> <span class="n">beanDefToRegister</span> <span class="o">=</span> <span class="n">beanDef</span><span class="o">;</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">proxyMode</span> <span class="o">!=</span> <span class="nc">ScopedProxyMode</span><span class="o">.</span><span class="na">NO</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">BeanDefinitionHolder</span> <span class="n">proxyDef</span> <span class="o">=</span> <span class="nc">ScopedProxyCreator</span><span class="o">.</span><span class="na">createScopedProxy</span><span class="o">(</span>
             <span class="k">new</span> <span class="nf">BeanDefinitionHolder</span><span class="o">(</span><span class="n">beanDef</span><span class="o">,</span> <span class="n">beanName</span><span class="o">),</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">,</span>
             <span class="n">proxyMode</span> <span class="o">==</span> <span class="nc">ScopedProxyMode</span><span class="o">.</span><span class="na">TARGET_CLASS</span><span class="o">);</span>
     <span class="n">beanDefToRegister</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConfigurationClassBeanDefinition</span><span class="o">(</span>
             <span class="o">(</span><span class="nc">RootBeanDefinition</span><span class="o">)</span> <span class="n">proxyDef</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">(),</span> <span class="n">configClass</span><span class="o">,</span> <span class="n">metadata</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
     <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Registering bean definition for @Bean method %s.%s()"</span><span class="o">,</span>
             <span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">));</span>
 <span class="o">}</span>
 <span class="c1">//注册bean定义</span>
 <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">.</span><span class="na">registerBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">beanDefToRegister</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  看到这么长的一堆代码,任谁都不想看,但其实这段代码的逻辑并不复杂,还是先检查bean方法是否需要跳过,不需要跳过在根据配置类和@Bean注解的元数据创建bean定义,最后再注册到注册中心去即可.<br />
 4.4 从@ImportSource中加载bean定义,相关源码如下:</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">loadBeanDefinitionsFromImportedResources</span><span class="o">(</span>
     <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">BeanDefinitionReader</span><span class="o">&gt;&gt;</span> <span class="n">importedResources</span><span class="o">)</span> <span class="o">{</span>

 <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&lt;?&gt;,</span> <span class="nc">BeanDefinitionReader</span><span class="o">&gt;</span> <span class="n">readerInstanceCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

 <span class="n">importedResources</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">resource</span><span class="o">,</span> <span class="n">readerClass</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
     <span class="c1">// Default reader selection necessary?</span>
     <span class="c1">//需要选择默认读取器  主要是groovy或 xml方式</span>
     <span class="k">if</span> <span class="o">(</span><span class="nc">BeanDefinitionReader</span><span class="o">.</span><span class="na">class</span> <span class="o">==</span> <span class="n">readerClass</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">endsWithIgnoreCase</span><span class="o">(</span><span class="n">resource</span><span class="o">,</span> <span class="s">".groovy"</span><span class="o">))</span> <span class="o">{</span>
             <span class="c1">// When clearly asking for Groovy, that's what they'll get...</span>
             <span class="n">readerClass</span> <span class="o">=</span> <span class="nc">GroovyBeanDefinitionReader</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="c1">// Primarily ".xml" files but for any other extension as well</span>
             <span class="n">readerClass</span> <span class="o">=</span> <span class="nc">XmlBeanDefinitionReader</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
         <span class="o">}</span>
     <span class="o">}</span>

     <span class="c1">//从缓存中读取bean定义读取器   不存在先创建bean定义读取器 最后再加载bean定义</span>
     <span class="nc">BeanDefinitionReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">readerInstanceCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">readerClass</span><span class="o">);</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">reader</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">try</span> <span class="o">{</span>
             <span class="c1">// Instantiate the specified BeanDefinitionReader</span>
             <span class="c1">//实例化指定的bean定义读取器</span>
             <span class="n">reader</span> <span class="o">=</span> <span class="n">readerClass</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
             <span class="c1">// Delegate the current ResourceLoader to it if possible</span>
             <span class="c1">//如果可能的话委托给当前资源加载器</span>
             <span class="k">if</span> <span class="o">(</span><span class="n">reader</span> <span class="k">instanceof</span> <span class="nc">AbstractBeanDefinitionReader</span><span class="o">)</span> <span class="o">{</span>
                 <span class="nc">AbstractBeanDefinitionReader</span> <span class="n">abdr</span> <span class="o">=</span> <span class="o">((</span><span class="nc">AbstractBeanDefinitionReader</span><span class="o">)</span> <span class="n">reader</span><span class="o">);</span>
                 <span class="n">abdr</span><span class="o">.</span><span class="na">setResourceLoader</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">);</span>
                 <span class="n">abdr</span><span class="o">.</span><span class="na">setEnvironment</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">);</span>
             <span class="o">}</span>
             <span class="n">readerInstanceCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">readerClass</span><span class="o">,</span> <span class="n">reader</span><span class="o">);</span>
         <span class="o">}</span>
         <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span>
                     <span class="s">"Could not instantiate BeanDefinitionReader class ["</span> <span class="o">+</span> <span class="n">readerClass</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
         <span class="o">}</span>
     <span class="o">}</span>

     <span class="c1">// TODO SPR-6310: qualify relative path locations as done in AbstractContextLoader.modifyLocations</span>
     <span class="n">reader</span><span class="o">.</span><span class="na">loadBeanDefinitions</span><span class="o">(</span><span class="n">resource</span><span class="o">);</span>
 <span class="o">});</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  此注解用的不是很多,做了解即可.它的主要作用是通过BeanDefinitionReader去加载指定的配置文件中的属性.<br />
 4.5 从导入的ImportBeanDefinitionRegistrar的实现类中加载bean定义,这里我们主要针对的是 <strong>AutoConfigurationPackages.Registrar.class</strong> 类,源码如下:</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//通过注册表注册bean定义</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">loadBeanDefinitionsFromRegistrars</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">ImportBeanDefinitionRegistrar</span><span class="o">,</span> <span class="nc">AnnotationMetadata</span><span class="o">&gt;</span> <span class="n">registrars</span><span class="o">)</span> <span class="o">{</span>
 <span class="n">registrars</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">registrar</span><span class="o">,</span> <span class="n">metadata</span><span class="o">)</span> <span class="o">-&gt;</span>
         <span class="n">registrar</span><span class="o">.</span><span class="na">registerBeanDefinitions</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">importBeanNameGenerator</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  它的主要作用是调用每个ImportBeanDefinitionRegistrar的实现类重写的registerBeanDefinitions方法,我们继续看下 <strong>AutoConfigurationPackages.Registrar.class</strong> 中重写的方法:</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerBeanDefinitions</span><span class="o">(</span><span class="nc">AnnotationMetadata</span> <span class="n">metadata</span><span class="o">,</span> <span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">register</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="k">new</span> <span class="nc">PackageImport</span><span class="o">(</span><span class="n">metadata</span><span class="o">).</span><span class="na">getPackageName</span><span class="o">());</span>
 <span class="o">}</span>
    
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">BEAN</span> <span class="o">=</span> <span class="nc">AutoConfigurationPackages</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
    
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">,</span> <span class="nc">String</span><span class="o">...</span> <span class="n">packageNames</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">registry</span><span class="o">.</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="no">BEAN</span><span class="o">))</span> <span class="o">{</span>
         <span class="nc">BeanDefinition</span> <span class="n">beanDefinition</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="no">BEAN</span><span class="o">);</span>
         <span class="nc">ConstructorArgumentValues</span> <span class="n">constructorArguments</span> <span class="o">=</span> <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getConstructorArgumentValues</span><span class="o">();</span>
         <span class="n">constructorArguments</span><span class="o">.</span><span class="na">addIndexedArgumentValue</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">addBasePackages</span><span class="o">(</span><span class="n">constructorArguments</span><span class="o">,</span> <span class="n">packageNames</span><span class="o">));</span>
     <span class="o">}</span>
     <span class="k">else</span> <span class="o">{</span>
         <span class="nc">GenericBeanDefinition</span> <span class="n">beanDefinition</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericBeanDefinition</span><span class="o">();</span>
         <span class="n">beanDefinition</span><span class="o">.</span><span class="na">setBeanClass</span><span class="o">(</span><span class="nc">BasePackages</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
         <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getConstructorArgumentValues</span><span class="o">().</span><span class="na">addIndexedArgumentValue</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">packageNames</span><span class="o">);</span>
         <span class="n">beanDefinition</span><span class="o">.</span><span class="na">setRole</span><span class="o">(</span><span class="nc">BeanDefinition</span><span class="o">.</span><span class="na">ROLE_INFRASTRUCTURE</span><span class="o">);</span>
         <span class="n">registry</span><span class="o">.</span><span class="na">registerBeanDefinition</span><span class="o">(</span><span class="no">BEAN</span><span class="o">,</span> <span class="n">beanDefinition</span><span class="o">);</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>    </div>
    <p>  可见AutoConfigurationPackages.Registrar的作用就是注册AutoConfigurationPackages的bean定义.</p>
    <blockquote>
      <p>第四步就是将上一阶段找到的配置类进行加载,主要针对以下几个方面:配置类自身、@Bean注解导入的类、@ImportSource注解导入的类和@Import导入的ImportBeanDefinitionRegistrar的实现类</p>
    </blockquote>
  </li>
  <li>第五步检查是否所有的配置类都已经解析过了,解析完直接结束,源码如下:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Build and validate a configuration model based on the registry of
 * {@link Configuration} classes.
 * 基于Configuration类的注册表构建和验证配置模型
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processConfigBeanDefinitions</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
     <span class="o">...</span>
        
     <span class="c1">//5.最后检测后扫描到的配置类中是否有未扫描到的,存在则加入到candidates中继续解析</span>
     <span class="c1">//如果注册表中的bean定义数量 大于 之前 加载的候选类数量</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinitionCount</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">//最新的候选配置类数组</span>
         <span class="nc">String</span><span class="o">[]</span> <span class="n">newCandidateNames</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinitionNames</span><span class="o">();</span>
         <span class="c1">//旧的候选配置类集合</span>
         <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">oldCandidateNames</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">candidateNames</span><span class="o">));</span>
         <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">alreadyParsedClasses</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
         <span class="c1">//添加到alreadyParsedClasses中</span>
         <span class="k">for</span> <span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configurationClass</span> <span class="o">:</span> <span class="n">alreadyParsed</span><span class="o">)</span> <span class="o">{</span>
             <span class="n">alreadyParsedClasses</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">configurationClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
         <span class="o">}</span>
         <span class="c1">//比较新旧候选类  只有不存在于旧的候选者集合 且 属于配置候选者 才添加到candidates</span>
         <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">candidateName</span> <span class="o">:</span> <span class="n">newCandidateNames</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">if</span> <span class="o">(!</span><span class="n">oldCandidateNames</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">candidateName</span><span class="o">))</span> <span class="o">{</span>
                 <span class="nc">BeanDefinition</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">candidateName</span><span class="o">);</span>
                 <span class="k">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">checkConfigurationClassCandidate</span><span class="o">(</span><span class="n">bd</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                         <span class="o">!</span><span class="n">alreadyParsedClasses</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">bd</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">()))</span> <span class="o">{</span>
                     <span class="n">candidates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanDefinitionHolder</span><span class="o">(</span><span class="n">bd</span><span class="o">,</span> <span class="n">candidateName</span><span class="o">));</span>
                 <span class="o">}</span>
             <span class="o">}</span>
         <span class="o">}</span>
         <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">newCandidateNames</span><span class="o">;</span>
     <span class="o">}</span>
 <span class="o">}</span>
 <span class="k">while</span> <span class="o">(!</span><span class="n">candidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">());</span>

 <span class="c1">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span>
 <span class="c1">//将ImportRegistry注册为一个bean 为了支持ImportAware的配置类</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">sbr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sbr</span><span class="o">.</span><span class="na">containsSingleton</span><span class="o">(</span><span class="no">IMPORT_REGISTRY_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
     <span class="n">sbr</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="no">IMPORT_REGISTRY_BEAN_NAME</span><span class="o">,</span> <span class="n">parser</span><span class="o">.</span><span class="na">getImportRegistry</span><span class="o">());</span>
 <span class="o">}</span>

 <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span> <span class="k">instanceof</span> <span class="nc">CachingMetadataReaderFactory</span><span class="o">)</span> <span class="o">{</span>
     <span class="c1">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span>
     <span class="c1">// for a shared cache since it'll be cleared by the ApplicationContext.</span>
     <span class="c1">//清除外部提供的MetadataReaderFactory中的缓存; 这是共享缓存的空操作,因为它将被ApplicationContext清除</span>
     <span class="o">((</span><span class="nc">CachingMetadataReaderFactory</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">).</span><span class="na">clearCache</span><span class="o">();</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  可见将注册中心中注册的bean定义同已经解析过配置类和之前的候选类做比较,只有满足配置类条件且同时不在已解析集合和候选者集合中时才需要继续解析.若最后candidates为空说明配置类解析完成.<br />
  最后注册ConfigurationClassPostProcessor的bean定义以及清除缓存.</p>
    <blockquote>
      <p>第五步最后检查是否还有漏掉的配置类,有则继续解析,没有则表明解析完成</p>
    </blockquote>
  </li>
</ol>

<hr />

<h3 id="configurationclassparserparsecandidates">ConfigurationClassParser.parse(candidates)</h3>
<hr />
<p>  我们先来看 <strong>parse</strong> 方法:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="c1">//调用真正的解析方法</span>
    <span class="n">processConfigurationClass</span><span class="o">(</span><span class="k">new</span> <span class="nc">ConfigurationClass</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">beanName</span><span class="o">));</span>
<span class="o">}</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">processConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="c1">//1. 判断是否被Conditional修饰 且 是否应该注册</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">conditionEvaluator</span><span class="o">.</span><span class="na">shouldSkip</span><span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">PARSE_CONFIGURATION</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">//2. 如果当前配置类已经被处理过 则继续判断是否是@Import导入的,是则合并并返回 不是则移除继续解析</span>
    <span class="nc">ConfigurationClass</span> <span class="n">existingClass</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">configurationClasses</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">configClass</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">existingClass</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">isImported</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">existingClass</span><span class="o">.</span><span class="na">isImported</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">existingClass</span><span class="o">.</span><span class="na">mergeImportedBy</span><span class="o">(</span><span class="n">configClass</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// Explicit bean definition found, probably replacing an import.</span>
            <span class="c1">// Let's remove the old one and go with the new one.</span>
            <span class="k">this</span><span class="o">.</span><span class="na">configurationClasses</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">configClass</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">knownSuperclasses</span><span class="o">.</span><span class="na">values</span><span class="o">().</span><span class="na">removeIf</span><span class="o">(</span><span class="nl">configClass:</span><span class="o">:</span><span class="n">equals</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Recursively process the configuration class and its superclass hierarchy.</span>
    <span class="c1">//3. 递归处理配置类及其超类层次结构</span>
    <span class="nc">SourceClass</span> <span class="n">sourceClass</span> <span class="o">=</span> <span class="n">asSourceClass</span><span class="o">(</span><span class="n">configClass</span><span class="o">);</span>
    <span class="k">do</span> <span class="o">{</span><span class="n">候选者实现了</span> <span class="nc">ImportSelector</span> <span class="n">接口</span>
        <span class="c1">//执行解析逻辑</span>
        <span class="n">sourceClass</span> <span class="o">=</span> <span class="n">doProcessConfigurationClass</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">sourceClass</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>

    <span class="k">this</span><span class="o">.</span><span class="na">configurationClasses</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">configClass</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  我们先来看下 <strong>processConfigurationClass</strong> 的逻辑:<br />
1.第一步先判断当前配置类是否应该跳过,判断的条件是什么呢,我们看下源码:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Determine if an item should be skipped based on {@code @Conditional} annotations.
 * 根据@Conditional注解确定是否应该跳过该项目
 * @param metadata the meta data
 * @param phase the phase of the call
 * @return if the item should be skipped
 */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">shouldSkip</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">AnnotatedTypeMetadata</span> <span class="n">metadata</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">ConfigurationPhase</span> <span class="n">phase</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//如果注解元数据为null返回false   或 注解元数据不为null且注解元数据未被Conditional修饰也返回false</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">metadata</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">metadata</span><span class="o">.</span><span class="na">isAnnotated</span><span class="o">(</span><span class="nc">Conditional</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//如果配置解析器为null</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">phase</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">metadata</span> <span class="k">instanceof</span> <span class="nc">AnnotationMetadata</span> <span class="o">&amp;&amp;</span>
                <span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">isConfigurationCandidate</span><span class="o">((</span><span class="nc">AnnotationMetadata</span><span class="o">)</span> <span class="n">metadata</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">shouldSkip</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">PARSE_CONFIGURATION</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">shouldSkip</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">REGISTER_BEAN</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Condition</span><span class="o">&gt;</span> <span class="n">conditions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//获取@Conditional的value值并存入conditions中</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">conditionClasses</span> <span class="o">:</span> <span class="n">getConditionClasses</span><span class="o">(</span><span class="n">metadata</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">conditionClass</span> <span class="o">:</span> <span class="n">conditionClasses</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Condition</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">getCondition</span><span class="o">(</span><span class="n">conditionClass</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">());</span>
            <span class="n">conditions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">condition</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nc">AnnotationAwareOrderComparator</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">conditions</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">Condition</span> <span class="n">condition</span> <span class="o">:</span> <span class="n">conditions</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ConfigurationPhase</span> <span class="n">requiredPhase</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="nc">ConfigurationCondition</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">requiredPhase</span> <span class="o">=</span> <span class="o">((</span><span class="nc">ConfigurationCondition</span><span class="o">)</span> <span class="n">condition</span><span class="o">).</span><span class="na">getConfigurationPhase</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">requiredPhase</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">requiredPhase</span> <span class="o">==</span> <span class="n">phase</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">condition</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">context</span><span class="o">,</span> <span class="n">metadata</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  看到 <strong>@Conditional</strong> 这个注解是不是就很熟悉了,就是根据 <strong>Conditional</strong> 的属性来判断是否需要跳过.<br />
2.第二步则是判断当前配置类使用已经解析过,如果是通过 <strong>@Import</strong> 导入的配置类则合并并返回,不是则移除配置类继续解析<br />
3.第三步就是获取配置类源信息并通过 <strong>doProcessConfigurationClass</strong> 来进行解析配置类,最后再将解析过的配置类添加到configurationClasses中<br />
  接下来我们着重来看看这个 <strong>doProcessConfigurationClass</strong> :</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="c1">//3.1 首先递归处理任何嵌套的成员类</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">isAnnotated</span><span class="o">(</span><span class="nc">Component</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
        <span class="c1">// Recursively process any member (nested) classes first</span>
        <span class="n">processMemberClasses</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Process any @PropertySource annotations</span>
    <span class="c1">//3.2 处理所有的@PropertySource注解</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">propertySource</span> <span class="o">:</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesForRepeatable</span><span class="o">(</span>
            <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">PropertySources</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
            <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">PropertySource</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="k">instanceof</span> <span class="nc">ConfigurableEnvironment</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">processPropertySource</span><span class="o">(</span><span class="n">propertySource</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Ignoring @PropertySource annotation on ["</span> <span class="o">+</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">()</span> <span class="o">+</span>
                    <span class="s">"]. Reason: Environment must implement ConfigurableEnvironment"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Process any @ComponentScan annotations</span>
    <span class="c1">//3.3 处理所有的@ComponentScan注解</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">AnnotationAttributes</span><span class="o">&gt;</span> <span class="n">componentScans</span> <span class="o">=</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesForRepeatable</span><span class="o">(</span>
            <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ComponentScans</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">ComponentScan</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="c1">//扫描到的ComponentScan不为空且 Conditonal修饰的注解条件不应该跳过</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">componentScans</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
            <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">conditionEvaluator</span><span class="o">.</span><span class="na">shouldSkip</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">REGISTER_BEAN</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">componentScan</span> <span class="o">:</span> <span class="n">componentScans</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span>
            <span class="c1">//使用@ComponentScans注解修饰的配置类  -&gt; 立即执行扫描</span>
            <span class="c1">//扫描到ComponectScan指定的类  默认classpath下的所有类且被@Component修饰的类</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">scannedBeanDefinitions</span> <span class="o">=</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">componentScanParser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">componentScan</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
            <span class="c1">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span>
            <span class="c1">// 检查任何其他配置类的扫描定义集合 并 在需要时递归解析</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">BeanDefinitionHolder</span> <span class="n">holder</span> <span class="o">:</span> <span class="n">scannedBeanDefinitions</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">BeanDefinition</span> <span class="n">bdCand</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">().</span><span class="na">getOriginatingBeanDefinition</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">bdCand</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">bdCand</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">//检查通过ComponentScan扫描出来的类是否满足Configuration的候选 满足则进行类解析逻辑</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">checkConfigurationClassCandidate</span><span class="o">(</span><span class="n">bdCand</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">parse</span><span class="o">(</span><span class="n">bdCand</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">(),</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Process any @Import annotations</span>
    <span class="c1">//3.4 处理所有的@Import的注解</span>
    <span class="c1">//getImport方法目前在springboot启动中有以下几个值</span>
    <span class="c1">//1.org.springframework.boot.autoconfigure.AutoConfigurationImportSelector</span>
    <span class="c1">//2.org.springframework.boot.autoconfigure.AutoConfigurationPackages.Registrar</span>
    <span class="c1">//主要用于 处理所有使用@Import注解额类</span>
    <span class="n">processImports</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">,</span> <span class="n">getImports</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">),</span> <span class="kc">true</span><span class="o">);</span>

    <span class="c1">// Process any @ImportResource annotations</span>
    <span class="c1">//3.5 处理所有存在的@ImportResource注解</span>
    <span class="nc">AnnotationAttributes</span> <span class="n">importResource</span> <span class="o">=</span>
            <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesFor</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ImportResource</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">importResource</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">resources</span> <span class="o">=</span> <span class="n">importResource</span><span class="o">.</span><span class="na">getStringArray</span><span class="o">(</span><span class="s">"locations"</span><span class="o">);</span>
        <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">BeanDefinitionReader</span><span class="o">&gt;</span> <span class="n">readerClass</span> <span class="o">=</span> <span class="n">importResource</span><span class="o">.</span><span class="na">getClass</span><span class="o">(</span><span class="s">"reader"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">resource</span> <span class="o">:</span> <span class="n">resources</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">resolvedResource</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">.</span><span class="na">resolveRequiredPlaceholders</span><span class="o">(</span><span class="n">resource</span><span class="o">);</span>
            <span class="n">configClass</span><span class="o">.</span><span class="na">addImportedResource</span><span class="o">(</span><span class="n">resolvedResource</span><span class="o">,</span> <span class="n">readerClass</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Process individual @Bean methods</span>
    <span class="c1">//3.6 处理所有独立的@Bean方法</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">MethodMetadata</span><span class="o">&gt;</span> <span class="n">beanMethods</span> <span class="o">=</span> <span class="n">retrieveBeanMethodMetadata</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">MethodMetadata</span> <span class="n">methodMetadata</span> <span class="o">:</span> <span class="n">beanMethods</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">configClass</span><span class="o">.</span><span class="na">addBeanMethod</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanMethod</span><span class="o">(</span><span class="n">methodMetadata</span><span class="o">,</span> <span class="n">configClass</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// Process default methods on interfaces</span>
    <span class="c1">//3.7 处理接口上的默认方法</span>
    <span class="n">processInterfaces</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">);</span>

    <span class="c1">// Process superclass, if any</span>
    <span class="c1">//3.8 如果有的话处理父类</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">hasSuperClass</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">superclass</span> <span class="o">=</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getSuperClassName</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">superclass</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">superclass</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"java"</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">knownSuperclasses</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">superclass</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">knownSuperclasses</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">superclass</span><span class="o">,</span> <span class="n">configClass</span><span class="o">);</span>
            <span class="c1">// Superclass found, return its annotation metadata and recurse</span>
            <span class="k">return</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getSuperClass</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// No superclass -&gt; processing is complete</span>
    <span class="c1">//没有父类的话 处理完成 返回null</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可以看到 <strong>doProcessConfigurationClass</strong> 中解析了我们常见的注解,例如 <strong>@ComponentScan、@Import、@Bean</strong> 等等.下面我们一一看下是如何解析的:<br />
3.1 首先递归的解析嵌套类成员,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Register member (nested) classes that happen to be configuration classes themselves.
 * 注册 恰好是配置类本身的成员嵌套类
 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">processMemberClasses</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="c1">//获取来源类的成员类</span>
    <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">memberClasses</span> <span class="o">=</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMemberClasses</span><span class="o">();</span>
    <span class="c1">//筛选出符合条件的成员类 执行processConfigurationClass解析逻辑</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">memberClasses</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">memberClasses</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">SourceClass</span> <span class="n">memberClass</span> <span class="o">:</span> <span class="n">memberClasses</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">isConfigurationCandidate</span><span class="o">(</span><span class="n">memberClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">())</span> <span class="o">&amp;&amp;</span>
                    <span class="o">!</span><span class="n">memberClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">()))</span> <span class="o">{</span>
                <span class="n">candidates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">memberClass</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">OrderComparator</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">candidates</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">SourceClass</span> <span class="n">candidate</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">configClass</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">problemReporter</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="k">new</span> <span class="nc">CircularImportProblem</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">configClass</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">processConfigurationClass</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">asConfigClass</span><span class="o">(</span><span class="n">configClass</span><span class="o">));</span>
                <span class="o">}</span>
                <span class="k">finally</span> <span class="o">{</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  由上可见,首先先处理来源类中所有符合配置类条件的成员类,筛选出来后先将这些配置类进行解析.<br />
3.2 第二步解析 <strong>@PropertySources</strong> 注解:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="c1">// Process any @PropertySource annotations</span>
    <span class="c1">//3.2 处理所有的@PropertySource注解</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">propertySource</span> <span class="o">:</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesForRepeatable</span><span class="o">(</span>
            <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">PropertySources</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
            <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">PropertySource</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="k">instanceof</span> <span class="nc">ConfigurableEnvironment</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">processPropertySource</span><span class="o">(</span><span class="n">propertySource</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Ignoring @PropertySource annotation on ["</span> <span class="o">+</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">()</span> <span class="o">+</span>
                    <span class="s">"]. Reason: Environment must implement ConfigurableEnvironment"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

   <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  其中 <strong>AnnotationConfigUtils.attributesForRepeatable</strong> 方法的作用是获取指定注解的所有属性,通过属性是否存在可以判断是否存在该注解.这里我们判断是否存在@PropertySource的属性,不存在则跳过,存在且当前环境属于ConfigurableEnvironment时才处理该注解.<br />
  相关源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Process the given &lt;code&gt;@PropertySource&lt;/code&gt; annotation metadata.
 * 处理给定的@PropertySource注解元数据
 * @param propertySource metadata for the &lt;code&gt;@PropertySource&lt;/code&gt; annotation found
 * @throws IOException if loading a property source failed
 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">processPropertySource</span><span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">propertySource</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">propertySource</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasLength</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">String</span> <span class="n">encoding</span> <span class="o">=</span> <span class="n">propertySource</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"encoding"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasLength</span><span class="o">(</span><span class="n">encoding</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">locations</span> <span class="o">=</span> <span class="n">propertySource</span><span class="o">.</span><span class="na">getStringArray</span><span class="o">(</span><span class="s">"value"</span><span class="o">);</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">isTrue</span><span class="o">(</span><span class="n">locations</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"At least one @PropertySource(value) location is required"</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="n">ignoreResourceNotFound</span> <span class="o">=</span> <span class="n">propertySource</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"ignoreResourceNotFound"</span><span class="o">);</span>

    <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">PropertySourceFactory</span><span class="o">&gt;</span> <span class="n">factoryClass</span> <span class="o">=</span> <span class="n">propertySource</span><span class="o">.</span><span class="na">getClass</span><span class="o">(</span><span class="s">"factory"</span><span class="o">);</span>
    <span class="nc">PropertySourceFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="o">(</span><span class="n">factoryClass</span> <span class="o">==</span> <span class="nc">PropertySourceFactory</span><span class="o">.</span><span class="na">class</span> <span class="o">?</span>
            <span class="no">DEFAULT_PROPERTY_SOURCE_FACTORY</span> <span class="o">:</span> <span class="nc">BeanUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">factoryClass</span><span class="o">));</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">location</span> <span class="o">:</span> <span class="n">locations</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">resolvedLocation</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">.</span><span class="na">resolveRequiredPlaceholders</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
            <span class="nc">Resource</span> <span class="n">resource</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">.</span><span class="na">getResource</span><span class="o">(</span><span class="n">resolvedLocation</span><span class="o">);</span>
            <span class="n">addPropertySource</span><span class="o">(</span><span class="n">factory</span><span class="o">.</span><span class="na">createPropertySource</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">new</span> <span class="nc">EncodedResource</span><span class="o">(</span><span class="n">resource</span><span class="o">,</span> <span class="n">encoding</span><span class="o">)));</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">IllegalArgumentException</span> <span class="o">|</span> <span class="nc">FileNotFoundException</span> <span class="o">|</span> <span class="nc">UnknownHostException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Placeholders not resolvable or resource not found when trying to open it</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ignoreResourceNotFound</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isInfoEnabled</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Properties location ["</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s">"] not resolvable: "</span> <span class="o">+</span> <span class="n">ex</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  主要作用就是根据注解的各个属性获取并创建资源,存在则替换,不存在则新增.<br />
3.3 第三步解析 <strong>@ComponentScan</strong> 注解:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="c1">// Process any @ComponentScan annotations</span>
    <span class="c1">//3.3 处理所有的@ComponentScan注解</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">AnnotationAttributes</span><span class="o">&gt;</span> <span class="n">componentScans</span> <span class="o">=</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesForRepeatable</span><span class="o">(</span>
            <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ComponentScans</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">ComponentScan</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="c1">//扫描到的ComponentScan不为空且 Conditonal修饰的注解条件不应该跳过</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">componentScans</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
            <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">conditionEvaluator</span><span class="o">.</span><span class="na">shouldSkip</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">REGISTER_BEAN</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">componentScan</span> <span class="o">:</span> <span class="n">componentScans</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span>
            <span class="c1">//使用@ComponentScans注解修饰的配置类  -&gt; 立即执行扫描</span>
            <span class="c1">//扫描到ComponectScan指定的类  默认classpath下的所有类且被@Component修饰的类</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">scannedBeanDefinitions</span> <span class="o">=</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">componentScanParser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">componentScan</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
            <span class="c1">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span>
            <span class="c1">// 检查任何其他配置类的扫描定义集合 并 在需要时递归解析</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">BeanDefinitionHolder</span> <span class="n">holder</span> <span class="o">:</span> <span class="n">scannedBeanDefinitions</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">BeanDefinition</span> <span class="n">bdCand</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">().</span><span class="na">getOriginatingBeanDefinition</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">bdCand</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">bdCand</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">//检查通过ComponentScan扫描出来的类是否满足Configuration的候选 满足则进行类解析逻辑</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">checkConfigurationClassCandidate</span><span class="o">(</span><span class="n">bdCand</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">parse</span><span class="o">(</span><span class="n">bdCand</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">(),</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见通过是通过 <strong>AnnotationConfigUtils.attributesForRepeatable</strong> 方法获取到所有 <strong>@ComponentScan</strong> 注解的所有属性,然后根据该属性去扫描指定路径下的所有配置类,最近将所有满足条件的配置继续进行配置类解析.<br />
这里我们着重看下它是如何扫描指定包下的配置类的,它通过 <strong>componentScanParser</strong> 组件扫描器来进行扫描,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//处理ComponectScan的所有的属性</span>
<span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">componentScan</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">declaringClass</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ClassPathBeanDefinitionScanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathBeanDefinitionScanner</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">,</span>
            <span class="n">componentScan</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"useDefaultFilters"</span><span class="o">),</span> <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">);</span>

    <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">BeanNameGenerator</span><span class="o">&gt;</span> <span class="n">generatorClass</span> <span class="o">=</span> <span class="n">componentScan</span><span class="o">.</span><span class="na">getClass</span><span class="o">(</span><span class="s">"nameGenerator"</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="n">useInheritedGenerator</span> <span class="o">=</span> <span class="o">(</span><span class="nc">BeanNameGenerator</span><span class="o">.</span><span class="na">class</span> <span class="o">==</span> <span class="n">generatorClass</span><span class="o">);</span>
    <span class="n">scanner</span><span class="o">.</span><span class="na">setBeanNameGenerator</span><span class="o">(</span><span class="n">useInheritedGenerator</span> <span class="o">?</span> <span class="k">this</span><span class="o">.</span><span class="na">beanNameGenerator</span> <span class="o">:</span>
            <span class="nc">BeanUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">generatorClass</span><span class="o">));</span>

    <span class="nc">ScopedProxyMode</span> <span class="n">scopedProxyMode</span> <span class="o">=</span> <span class="n">componentScan</span><span class="o">.</span><span class="na">getEnum</span><span class="o">(</span><span class="s">"scopedProxy"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">scopedProxyMode</span> <span class="o">!=</span> <span class="nc">ScopedProxyMode</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">scanner</span><span class="o">.</span><span class="na">setScopedProxyMode</span><span class="o">(</span><span class="n">scopedProxyMode</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">ScopeMetadataResolver</span><span class="o">&gt;</span> <span class="n">resolverClass</span> <span class="o">=</span> <span class="n">componentScan</span><span class="o">.</span><span class="na">getClass</span><span class="o">(</span><span class="s">"scopeResolver"</span><span class="o">);</span>
        <span class="n">scanner</span><span class="o">.</span><span class="na">setScopeMetadataResolver</span><span class="o">(</span><span class="nc">BeanUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">resolverClass</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="n">scanner</span><span class="o">.</span><span class="na">setResourcePattern</span><span class="o">(</span><span class="n">componentScan</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"resourcePattern"</span><span class="o">));</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">filter</span> <span class="o">:</span> <span class="n">componentScan</span><span class="o">.</span><span class="na">getAnnotationArray</span><span class="o">(</span><span class="s">"includeFilters"</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">TypeFilter</span> <span class="n">typeFilter</span> <span class="o">:</span> <span class="n">typeFiltersFor</span><span class="o">(</span><span class="n">filter</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">scanner</span><span class="o">.</span><span class="na">addIncludeFilter</span><span class="o">(</span><span class="n">typeFilter</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">filter</span> <span class="o">:</span> <span class="n">componentScan</span><span class="o">.</span><span class="na">getAnnotationArray</span><span class="o">(</span><span class="s">"excludeFilters"</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">TypeFilter</span> <span class="n">typeFilter</span> <span class="o">:</span> <span class="n">typeFiltersFor</span><span class="o">(</span><span class="n">filter</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">scanner</span><span class="o">.</span><span class="na">addExcludeFilter</span><span class="o">(</span><span class="n">typeFilter</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="n">lazyInit</span> <span class="o">=</span> <span class="n">componentScan</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"lazyInit"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lazyInit</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">scanner</span><span class="o">.</span><span class="na">getBeanDefinitionDefaults</span><span class="o">().</span><span class="na">setLazyInit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">basePackages</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">basePackagesArray</span> <span class="o">=</span> <span class="n">componentScan</span><span class="o">.</span><span class="na">getStringArray</span><span class="o">(</span><span class="s">"basePackages"</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">pkg</span> <span class="o">:</span> <span class="n">basePackagesArray</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tokenized</span> <span class="o">=</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">tokenizeToStringArray</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">.</span><span class="na">resolvePlaceholders</span><span class="o">(</span><span class="n">pkg</span><span class="o">),</span>
                <span class="nc">ConfigurableApplicationContext</span><span class="o">.</span><span class="na">CONFIG_LOCATION_DELIMITERS</span><span class="o">);</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">basePackages</span><span class="o">,</span> <span class="n">tokenized</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//若没有指定basePackageClasses,会取主函数的包名,即扫描主函数所在包下的所有类</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">:</span> <span class="n">componentScan</span><span class="o">.</span><span class="na">getClassArray</span><span class="o">(</span><span class="s">"basePackageClasses"</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">basePackages</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">ClassUtils</span><span class="o">.</span><span class="na">getPackageName</span><span class="o">(</span><span class="n">clazz</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">basePackages</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">basePackages</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">ClassUtils</span><span class="o">.</span><span class="na">getPackageName</span><span class="o">(</span><span class="n">declaringClass</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="n">scanner</span><span class="o">.</span><span class="na">addExcludeFilter</span><span class="o">(</span><span class="k">new</span> <span class="nc">AbstractTypeHierarchyTraversingFilter</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">matchClassName</span><span class="o">(</span><span class="nc">String</span> <span class="n">className</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">declaringClass</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">className</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="c1">//扫描basePackages指定目录下的类  默认扫描classpath下的路径</span>
    <span class="k">return</span> <span class="n">scanner</span><span class="o">.</span><span class="na">doScan</span><span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">toStringArray</span><span class="o">(</span><span class="n">basePackages</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见扫描器一开始都在填充 <strong>@ComponentScan</strong> 的属性,这里需要注意的就是 <strong>basePackageClasses</strong> 属性,即指定扫描的路径,若未指定则会扫描主函数所在的包.<br />
  属性封装完成后,即执行扫描,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Perform a scan within the specified base packages,
 * returning the registered bean definitions.
 * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor
 * but rather leaves this up to the caller.
 * 在指定的包中执行扫描，返回注册的bean定义。
 * 这个方法不注册一个注解配置处理器，而是把这个留给调用者
 * @param basePackages the packages to check for annotated classes
 * @return set of beans registered if any for tooling registration purposes (never {@code null})
 */</span>
<span class="kd">protected</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="nf">doScan</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">basePackages</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notEmpty</span><span class="o">(</span><span class="n">basePackages</span><span class="o">,</span> <span class="s">"At least one base package must be specified"</span><span class="o">);</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">beanDefinitions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">basePackage</span> <span class="o">:</span> <span class="n">basePackages</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//获取候选者组件</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinition</span><span class="o">&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="n">findCandidateComponents</span><span class="o">(</span><span class="n">basePackage</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">BeanDefinition</span> <span class="n">candidate</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//解析作用域元数据 获取@Scope 注解的属性</span>
            <span class="nc">ScopeMetadata</span> <span class="n">scopeMetadata</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">scopeMetadataResolver</span><span class="o">.</span><span class="na">resolveScopeMetadata</span><span class="o">(</span><span class="n">candidate</span><span class="o">);</span>
            <span class="n">candidate</span><span class="o">.</span><span class="na">setScope</span><span class="o">(</span><span class="n">scopeMetadata</span><span class="o">.</span><span class="na">getScopeName</span><span class="o">());</span>
            <span class="c1">//生成bean的名字</span>
            <span class="nc">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">beanNameGenerator</span><span class="o">.</span><span class="na">generateBeanName</span><span class="o">(</span><span class="n">candidate</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
            <span class="c1">//判断该候选者是否属于AbstractBeanDefinition 执行后置处理</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">candidate</span> <span class="k">instanceof</span> <span class="nc">AbstractBeanDefinition</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">postProcessBeanDefinition</span><span class="o">((</span><span class="nc">AbstractBeanDefinition</span><span class="o">)</span> <span class="n">candidate</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//判断该候选者是否属于可注解的bean定义</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">candidate</span> <span class="k">instanceof</span> <span class="nc">AnnotatedBeanDefinition</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//处理通用的注解 例如:@Lazy、@Primary、@DependsOn、@Role、@Description</span>
                <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">processCommonDefinitionAnnotations</span><span class="o">((</span><span class="nc">AnnotatedBeanDefinition</span><span class="o">)</span> <span class="n">candidate</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//检查候选者是否已经注册过</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">checkCandidate</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">candidate</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">BeanDefinitionHolder</span> <span class="n">definitionHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BeanDefinitionHolder</span><span class="o">(</span><span class="n">candidate</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
                <span class="c1">//根据代理模式创建代理类，没有则不创建</span>
                <span class="n">definitionHolder</span> <span class="o">=</span>
                        <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">applyScopedProxyMode</span><span class="o">(</span><span class="n">scopeMetadata</span><span class="o">,</span> <span class="n">definitionHolder</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
                <span class="n">beanDefinitions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">definitionHolder</span><span class="o">);</span>
                <span class="c1">//将扫描出来的类注册到注册表中</span>
                <span class="n">registerBeanDefinition</span><span class="o">(</span><span class="n">definitionHolder</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">beanDefinitions</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  这里逻辑就比较清晰了,根据注解的属性扫描过滤出满足条件的配置类并注册到bean定义到注册表中.<br />
3.4 第四步解析 <strong>@Import</strong> 注解,看到这个注解是不是比较熟悉,在 <strong>@SpringBootApplication</strong> 注解中的 <strong>@EnableAutoConfiguration</strong> 中就包含两个 <strong>@Import</strong> 注解,就是在这里处理的,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="c1">// Process any @Import annotations</span>
    <span class="c1">//3.4 处理所有的@Import的注解</span>
    <span class="c1">//getImport方法目前在springboot启动中有以下几个值</span>
    <span class="c1">//1.org.springframework.boot.autoconfigure.AutoConfigurationImportSelector</span>
    <span class="c1">//2.org.springframework.boot.autoconfigure.AutoConfigurationPackages.Registrar</span>
    <span class="c1">//主要用于 处理所有使用@Import注解额类</span>
    <span class="n">processImports</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">,</span> <span class="n">getImports</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">),</span> <span class="kc">true</span><span class="o">);</span>

    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  由上可见,第四步可以拆分为两个方法, <strong>getImports()</strong> 和 <strong>processImports()</strong> ,顾名思义第一个方法肯定是获取所有的 <strong>@Import</strong> 注解,而第二个方法就是处理所有的 <strong>@Import</strong> 注解了.  <br />
  首先我们先来看下 <strong>getImports()</strong> 源码:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Returns {@code @Import} class, considering all meta-annotations.
 * 返回 @Import 的类 考虑所有的元注解
 * 即返回所有@Import注解的 value值所指向的类
 */</span>
<span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="nf">getImports</span><span class="o">(</span><span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">imports</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
    <span class="n">collectImports</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">,</span> <span class="n">imports</span><span class="o">,</span> <span class="n">visited</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">imports</span><span class="o">;</span>
<span class="o">}</span>
<span class="cm">/**
 * Recursively collect all declared {@code @Import} values. Unlike most
 * meta-annotations it is valid to have several {@code @Import}s declared with
 * different values; the usual process of returning values from the first
 * meta-annotation on a class is not sufficient.
 * 递归收集所有声明的@import值.  不像所有的元注解 有几个声明为不同的值的@Import注解是合法的.
 * 从类的第一个元注解返回值 通常是不够的
 * &lt;p&gt;For example, it is common for a {@code @Configuration} class to declare direct
 * {@code @Import}s in addition to meta-imports originating from an {@code @Enable}
 * annotation.
 * 举个例子: 除了源自@Enable注解的元导入之外 @Configuration类直接声明@Import是很常见的
 * @param sourceClass the class to search
 * @param imports the imports collected so far
 * @param visited used to track visited classes to prevent infinite recursion
 * @throws IOException if there is any problem reading metadata from the named class
 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">collectImports</span><span class="o">(</span><span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">imports</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

    <span class="c1">//递归获取到@Import注解  将该注解的值添加到imports中</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">SourceClass</span> <span class="n">annotation</span> <span class="o">:</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getAnnotations</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">annName</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">annName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Import</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
                <span class="n">collectImports</span><span class="o">(</span><span class="n">annotation</span><span class="o">,</span> <span class="n">imports</span><span class="o">,</span> <span class="n">visited</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">imports</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">.</span><span class="na">getAnnotationAttributes</span><span class="o">(</span><span class="nc">Import</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="s">"value"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见 <strong>collectImports()</strong> 通过递归的方法获取主函数中所有的 <strong>@Import</strong> 注解,并将对应的value值添加到结果集合中.这里其实就对应 <strong>org.springframework.boot.autoconfigure.AutoConfigurationImportSelector和org.springframework.boot.autoconfigure.AutoConfigurationPackages.Registrar</strong> 两个类.  <br />
  接着我们再来看看处理逻辑:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">processImports</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">currentSourceClass</span><span class="o">,</span>
        <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">importCandidates</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">checkForCircularImports</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//前置检查 </span>
    <span class="c1">//导入候选类为空</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">importCandidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//是否检查循环导入 且 当前配置类存在栈中</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">checkForCircularImports</span> <span class="o">&amp;&amp;</span> <span class="n">isChainedImportOnStack</span><span class="o">(</span><span class="n">configClass</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">problemReporter</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="k">new</span> <span class="nc">CircularImportProblem</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">//将当前处理的配置类压栈</span>
        <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">configClass</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//遍历Import的候选类 通过getImports方法获取的候选类</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">SourceClass</span> <span class="n">candidate</span> <span class="o">:</span> <span class="n">importCandidates</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//当前候选者是否可指定为 ImportSelector类</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">isAssignable</span><span class="o">(</span><span class="nc">ImportSelector</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span>
                    <span class="c1">//候选类如果属于ImportSelector -&gt; 委托给他来确定导入</span>
                    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">candidateClass</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="na">loadClass</span><span class="o">();</span>
                    <span class="c1">//实例化ImportSelector</span>
                    <span class="nc">ImportSelector</span> <span class="n">selector</span> <span class="o">=</span> <span class="nc">ParserStrategyUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">candidateClass</span><span class="o">,</span> <span class="nc">ImportSelector</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
                            <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
                    <span class="c1">//当前ImportSelector是否属于DeferredImportSelector  是则执行handle方法 将当前的配置和selector放入deferredImportSelectors中</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">selector</span> <span class="k">instanceof</span> <span class="nc">DeferredImportSelector</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">this</span><span class="o">.</span><span class="na">deferredImportSelectorHandler</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="o">(</span><span class="nc">DeferredImportSelector</span><span class="o">)</span> <span class="n">selector</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">else</span> <span class="o">{</span><span class="c1">//不属于直接继续执行 递归处理Import方法逻辑</span>
                        <span class="nc">String</span><span class="o">[]</span> <span class="n">importClassNames</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="na">selectImports</span><span class="o">(</span><span class="n">currentSourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">());</span>
                        <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">importSourceClasses</span> <span class="o">=</span> <span class="n">asSourceClasses</span><span class="o">(</span><span class="n">importClassNames</span><span class="o">);</span>
                        <span class="n">processImports</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">currentSourceClass</span><span class="o">,</span> <span class="n">importSourceClasses</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">//当前候选者是否可以指定为 ImportBeanDefinitionRegister类</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">isAssignable</span><span class="o">(</span><span class="nc">ImportBeanDefinitionRegistrar</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span>
                    <span class="c1">// delegate to it to register additional bean definitions</span>
                    <span class="c1">//候选类是 ImportBeanDefinitionRegistrar -&gt; 委托给他注册额外的bean定义</span>
                    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">candidateClass</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="na">loadClass</span><span class="o">();</span>
                    <span class="c1">//实例化ImportBeanDefinitionRegistrar类</span>
                    <span class="nc">ImportBeanDefinitionRegistrar</span> <span class="n">registrar</span> <span class="o">=</span>
                            <span class="nc">ParserStrategyUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">candidateClass</span><span class="o">,</span> <span class="nc">ImportBeanDefinitionRegistrar</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
                                    <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
                    <span class="c1">//将实例化的类 添加到importBeanDefinitionRegistrars中</span>
                    <span class="n">configClass</span><span class="o">.</span><span class="na">addImportBeanDefinitionRegistrar</span><span class="o">(</span><span class="n">registrar</span><span class="o">,</span> <span class="n">currentSourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="o">{</span><span class="c1">//若以上两个类都不属于  走默认逻辑</span>
                    <span class="c1">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span>
                    <span class="c1">// process it as an @Configuration class</span>
                    <span class="c1">//候选者类既不是ImportSelector 或 ImportBeanDefinitionRegistrar -&gt;  把他当做@Configuration类来处理</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">registerImport</span><span class="o">(</span>
                            <span class="n">currentSourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="n">candidate</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
                    <span class="c1">//执行@Configuration处理逻辑</span>
                    <span class="n">processConfigurationClass</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">asConfigClass</span><span class="o">(</span><span class="n">configClass</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">BeanDefinitionStoreException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanDefinitionStoreException</span><span class="o">(</span>
                    <span class="s">"Failed to process import candidates for configuration class ["</span> <span class="o">+</span>
                    <span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">finally</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>   <strong>processImports</strong> 首先肯定是基础的前置检查,然后就是将当前处理的配置类压栈,接着就是处理所有 <strong>@Import</strong> 导入的类,有以下三种情况:</p>
<ul>
  <li>候选者实现了 <strong>ImportSelector</strong> 接口:<br />
  候选者对应启动类中声明的 <strong>AutoConfigurationImportSelector.class</strong> 类,首先将此候选类实例化为 <strong>ImportSelector</strong> ,判断候选者是否实现了 <strong>DeferredImportSelector</strong> ,未实现则继续从源配置类的元注解中找到需要导入的配置类递归解析.  <br />
  我们着重来看下实现了 <strong>DeferredImportSelector</strong> 接口的实现逻辑,因为__AutoConfigurationImportSelector.class__ 类就实现了此接口.我们继续看下 <strong>handle</strong> 源码:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">DeferredImportSelectorHolder</span><span class="o">&gt;</span> <span class="n">deferredImportSelectors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="cm">/**
 * Handle the specified {@link DeferredImportSelector}. If deferred import
 * selectors are being collected, this registers this instance to the list. If
 * they are being processed, the {@link DeferredImportSelector} is also processed
 * immediately according to its {@link DeferredImportSelector.Group}.
 * 处理指定的DeferredImportSelector. 如果正在收集导入器,则将此梳理注册到列表中.
 * 如果他们正在被处理,DeferredImportSelector 也会根据DeferredImportSelector.Group来立即处理他们
 * @param configClass the source configuration class
 * @param importSelector the selector to handle
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">DeferredImportSelector</span> <span class="n">importSelector</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">DeferredImportSelectorHolder</span> <span class="n">holder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeferredImportSelectorHolder</span><span class="o">(</span>
            <span class="n">configClass</span><span class="o">,</span> <span class="n">importSelector</span><span class="o">);</span>
    <span class="c1">//如果deferredImportSelectors为空 执行注册和处理逻辑  不为空则添加到deferredImportSelectors中</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">deferredImportSelectors</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DeferredImportSelectorGroupingHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeferredImportSelectorGroupingHandler</span><span class="o">();</span>
        <span class="n">handler</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">holder</span><span class="o">);</span>
        <span class="n">handler</span><span class="o">.</span><span class="na">processGroupImports</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">deferredImportSelectors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">holder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  因为 <strong>deferredImportSelectors</strong> 已经初始化过,所以直接将 <strong>DeferredImportSelectorHolder</strong> 添加到 <strong>deferredImportSelectors</strong> 中供后续加载自动配置类使用.</p>
<ul>
  <li>候选者实现了 <strong>ImportBeanDefinitionRegistrar</strong> 接口:<br />
  候选者对应启动类中声明的 <strong>AutoConfigurationPackages.Registrar.class</strong> 类,将此类实例化为 <strong>ImportBeanDefinitionRegistrar</strong> 并添加到配置类的 <strong>importBeanDefinitionRegistrars</strong> 集合中供后续使用.</li>
  <li>候选者未实现以上两个接口:<br />
  将候选者当做普通配置类调用 <strong>processConfigurationClass</strong> 方法递归解析.</li>
</ul>

<p>3.5 第五步,处理所有 <strong>@ImportResource</strong> 注解,相关源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="c1">// Process any @ImportResource annotations</span>
    <span class="c1">//3.5 处理所有存在的@ImportResource注解</span>
    <span class="nc">AnnotationAttributes</span> <span class="n">importResource</span> <span class="o">=</span>
            <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesFor</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ImportResource</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">importResource</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">resources</span> <span class="o">=</span> <span class="n">importResource</span><span class="o">.</span><span class="na">getStringArray</span><span class="o">(</span><span class="s">"locations"</span><span class="o">);</span>
        <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">BeanDefinitionReader</span><span class="o">&gt;</span> <span class="n">readerClass</span> <span class="o">=</span> <span class="n">importResource</span><span class="o">.</span><span class="na">getClass</span><span class="o">(</span><span class="s">"reader"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">resource</span> <span class="o">:</span> <span class="n">resources</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">resolvedResource</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">.</span><span class="na">resolveRequiredPlaceholders</span><span class="o">(</span><span class="n">resource</span><span class="o">);</span>
            <span class="n">configClass</span><span class="o">.</span><span class="na">addImportedResource</span><span class="o">(</span><span class="n">resolvedResource</span><span class="o">,</span> <span class="n">readerClass</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见这段逻辑就相对简单一点了,获取 <strong>@ImportResource</strong> 的元数据,没有则直接跳过,有则继续获取 <strong>locations</strong> 属性获取需要读取的配置文件地址,然后将读取的配置文件资源加载到配置类中.  <br />
3.6 第六步,处理所有的 <strong>@Bean</strong> 注解:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="c1">// Process individual @Bean methods</span>
    <span class="c1">//3.6 处理所有独立的@Bean方法</span>
    <span class="c1">//3.6.1 检索源类中所有的@Bean方法</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">MethodMetadata</span><span class="o">&gt;</span> <span class="n">beanMethods</span> <span class="o">=</span> <span class="n">retrieveBeanMethodMetadata</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">);</span>
    <span class="c1">//3.6.2 将方法封装成BeanMethod并添加到配置类中</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">MethodMetadata</span> <span class="n">methodMetadata</span> <span class="o">:</span> <span class="n">beanMethods</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">configClass</span><span class="o">.</span><span class="na">addBeanMethod</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanMethod</span><span class="o">(</span><span class="n">methodMetadata</span><span class="o">,</span> <span class="n">configClass</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见主要就分为两步,检索和添加.<br />
3.6.1 <strong>retrieveBeanMethodMetadata</strong> 的作用就是检索所有的 <strong>@Bean</strong> 方法,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Retrieve the metadata for all &lt;code&gt;@Bean&lt;/code&gt; methods.
 * 检索所有@Bean方法的元数据
 */</span>
<span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">MethodMetadata</span><span class="o">&gt;</span> <span class="nf">retrieveBeanMethodMetadata</span><span class="o">(</span><span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//获取源类的元数据</span>
    <span class="nc">AnnotationMetadata</span> <span class="n">original</span> <span class="o">=</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">();</span>
    <span class="c1">//获取所有@bean注解的方法</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">MethodMetadata</span><span class="o">&gt;</span> <span class="n">beanMethods</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">getAnnotatedMethods</span><span class="o">(</span><span class="nc">Bean</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanMethods</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">original</span> <span class="k">instanceof</span> <span class="nc">StandardAnnotationMetadata</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Try reading the class file via ASM for deterministic declaration order...</span>
        <span class="c1">//尝试通过ASM读取类文件以获得确定性声明顺序</span>
        <span class="c1">// Unfortunately, the JVM's standard reflection returns methods in arbitrary</span>
        <span class="c1">// order, even between different runs of the same application on the same JVM.</span>
        <span class="c1">//不幸的是 JVM标准的反射以任意顺序返回方法,即使在同一jvm上同一应用程序的不同运行之间也是如此</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">AnnotationMetadata</span> <span class="n">asm</span> <span class="o">=</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">.</span><span class="na">getMetadataReader</span><span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">getClassName</span><span class="o">()).</span><span class="na">getAnnotationMetadata</span><span class="o">();</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">MethodMetadata</span><span class="o">&gt;</span> <span class="n">asmMethods</span> <span class="o">=</span> <span class="n">asm</span><span class="o">.</span><span class="na">getAnnotatedMethods</span><span class="o">(</span><span class="nc">Bean</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">asmMethods</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">beanMethods</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">MethodMetadata</span><span class="o">&gt;</span> <span class="n">selectedMethods</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="n">asmMethods</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">MethodMetadata</span> <span class="n">asmMethod</span> <span class="o">:</span> <span class="n">asmMethods</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">for</span> <span class="o">(</span><span class="nc">MethodMetadata</span> <span class="n">beanMethod</span> <span class="o">:</span> <span class="n">beanMethods</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">beanMethod</span><span class="o">.</span><span class="na">getMethodName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">asmMethod</span><span class="o">.</span><span class="na">getMethodName</span><span class="o">()))</span> <span class="o">{</span>
                            <span class="n">selectedMethods</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanMethod</span><span class="o">);</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">selectedMethods</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">beanMethods</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
                    <span class="c1">// All reflection-detected methods found in ASM method set -&gt; proceed</span>
                    <span class="n">beanMethods</span> <span class="o">=</span> <span class="n">selectedMethods</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Failed to read class file via ASM for determining @Bean method order"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
            <span class="c1">// No worries, let's continue with the reflection metadata we started with...</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">beanMethods</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见就是从源类的元数据中获取所有的 <strong>@Bean</strong> 方法,并且当出现多个方法时需要根据ASM来确定方法的顺序.<br />
3.6.2 就是将3.6.1检索出来的所有的方法封装成 <strong>BeanMethod</strong> 并添加到配置类中<br />
3.7 第七步,处理源类实现的接口上的所有方法:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="c1">// Process default methods on interfaces</span>
    <span class="c1">//3.7 处理接口上的默认方法</span>
    <span class="n">processInterfaces</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">);</span>

    <span class="o">...</span>
<span class="o">}</span>

<span class="cm">/**
 * Register default methods on interfaces implemented by the configuration class.
 * 在配置类实现的接口上注册默认方法
 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">processInterfaces</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="c1">//遍历源类实现的所有接口</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">SourceClass</span> <span class="n">ifc</span> <span class="o">:</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getInterfaces</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">//获取接口上的所有 @Bean方法</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">MethodMetadata</span><span class="o">&gt;</span> <span class="n">beanMethods</span> <span class="o">=</span> <span class="n">retrieveBeanMethodMetadata</span><span class="o">(</span><span class="n">ifc</span><span class="o">);</span>
        <span class="c1">//遍历所有的方法 将非抽象的方法封装为BeanMethod方法并添加到配置类中</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">MethodMetadata</span> <span class="n">methodMetadata</span> <span class="o">:</span> <span class="n">beanMethods</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">methodMetadata</span><span class="o">.</span><span class="na">isAbstract</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// A default method or other concrete method on a Java 8+ interface...</span>
                <span class="c1">//java8接口上的默认方法或其他具体方法</span>
                <span class="n">configClass</span><span class="o">.</span><span class="na">addBeanMethod</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanMethod</span><span class="o">(</span><span class="n">methodMetadata</span><span class="o">,</span> <span class="n">configClass</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//递归处理接口</span>
        <span class="n">processInterfaces</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">ifc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  根据3.6来看这个就很好理解了,3.6处理的是源类中的所有 <strong>@Bean</strong> 方法,而3.7处理的是所有接口上的 <strong>@Bean</strong> 方法,并通过递归的方式保证所有接口都处理完毕.<br />
3.8 第八步,处理父类:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="c1">// Process superclass, if any</span>
    <span class="c1">//3.8 如果有的话处理父类</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">hasSuperClass</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">superclass</span> <span class="o">=</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getSuperClassName</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">superclass</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">superclass</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"java"</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">knownSuperclasses</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">superclass</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">knownSuperclasses</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">superclass</span><span class="o">,</span> <span class="n">configClass</span><span class="o">);</span>
            <span class="c1">// Superclass found, return its annotation metadata and recurse</span>
            <span class="k">return</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getSuperClass</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// No superclass -&gt; processing is complete</span>
    <span class="c1">//没有父类的话 处理完成 返回null</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  其实到这一步,当前配置类的注解解析已经完成了,若配置类有父类的话直接将父类返回继续进行配置类解析,若没有直接返回null即可.</p>
<blockquote>
  <p>以上就是doProcessConfigurationClass的所有流程,即解析@Component、@PropertySource、@ComponentScan、@Import、@ImportResource、@Bean及其父类和实现的接口的所有注解.</p>
</blockquote>

<hr />

<h3 id="deferredimportselectorhandlerprocess">deferredImportSelectorHandler.process()</h3>
<hr />

<p>  ConfigurationClassParser.parse的第一步就是解析配置类,第二步即deferredImportSelectorHandler.process().
  首先抛出结论,主要是针对 <strong>AutoConfigurationImportSelector</strong> 用来加载所有的EnableAutoConfiguration的子类.<br />
  源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">DeferredImportSelectorHolder</span><span class="o">&gt;</span> <span class="n">deferredImports</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">deferredImportSelectors</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">deferredImportSelectors</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">deferredImports</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">DeferredImportSelectorGroupingHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeferredImportSelectorGroupingHandler</span><span class="o">();</span>
            <span class="n">deferredImports</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">DEFERRED_IMPORT_COMPARATOR</span><span class="o">);</span>
            <span class="c1">//1. 通过DeferredImportSelectorGroupingHandler注册AutoConfigurationGroup分组</span>
            <span class="n">deferredImports</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nl">handler:</span><span class="o">:</span><span class="n">register</span><span class="o">);</span>
            <span class="c1">//2. 处理分组的导入配置</span>
            <span class="n">handler</span><span class="o">.</span><span class="na">processGroupImports</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">finally</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">deferredImportSelectors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  首先先看第一步:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="nc">DeferredImportSelectorHolder</span> <span class="n">deferredImport</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//获取当前DeferredImportSelector的分组</span>
    <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Group</span><span class="o">&gt;</span> <span class="n">group</span> <span class="o">=</span> <span class="n">deferredImport</span><span class="o">.</span><span class="na">getImportSelector</span><span class="o">().</span><span class="na">getImportGroup</span><span class="o">();</span>
    <span class="c1">//将此分组添加到grouping中</span>
    <span class="nc">DeferredImportSelectorGrouping</span> <span class="n">grouping</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">groupings</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span>
            <span class="o">(</span><span class="n">group</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">group</span> <span class="o">:</span> <span class="n">deferredImport</span><span class="o">),</span>
            <span class="n">key</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">DeferredImportSelectorGrouping</span><span class="o">(</span><span class="n">createGroup</span><span class="o">(</span><span class="n">group</span><span class="o">)));</span>
    <span class="n">grouping</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">deferredImport</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">configurationClasses</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">deferredImport</span><span class="o">.</span><span class="na">getConfigurationClass</span><span class="o">().</span><span class="na">getMetadata</span><span class="o">(),</span>
            <span class="n">deferredImport</span><span class="o">.</span><span class="na">getConfigurationClass</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Group</span><span class="o">&gt;</span> <span class="nf">getImportGroup</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nc">AutoConfigurationGroup</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></div></div>
<p>  可见第一步的作用就是获取 <strong>AutoConfigurationGroup</strong> 自动配置分组,为后续获取自动配置类做准备.<br />
  接下来看关键的 <strong>handler.processGroupImports()</strong> 处理逻辑:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">processGroupImports</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//groupings中就存放着我们上一步添加的AutoConfigurationGroup</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">DeferredImportSelectorGrouping</span> <span class="n">grouping</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">groupings</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">//根据getImports()获取所有的配置类  再通过处理Import配置类的方法processImports将每个EnableAutoConfiguration的实现类当做@Configuration解析</span>
            <span class="n">grouping</span><span class="o">.</span><span class="na">getImports</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">entry</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="nc">ConfigurationClass</span> <span class="n">configurationClass</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">configurationClasses</span><span class="o">.</span><span class="na">get</span><span class="o">(</span>
                        <span class="n">entry</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">());</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">//将自动配置继续执行@Import的处理逻辑 默认都当做普通配置类解析</span>
                    <span class="n">processImports</span><span class="o">(</span><span class="n">configurationClass</span><span class="o">,</span> <span class="n">asSourceClass</span><span class="o">(</span><span class="n">configurationClass</span><span class="o">),</span>
                            <span class="n">asSourceClasses</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getImportClassName</span><span class="o">()),</span> <span class="kc">false</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">catch</span> <span class="o">(</span><span class="nc">BeanDefinitionStoreException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanDefinitionStoreException</span><span class="o">(</span>
                            <span class="s">"Failed to process import candidates for configuration class ["</span> <span class="o">+</span>
                                    <span class="n">configurationClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>  可见此段逻辑为获取分组中的导入选择器,获取所有需要导入的配置类重新执行 <strong>processImports</strong> 逻辑,这里的配置类都会都默认的配置类解析逻辑.<br />
  我们继续看它是如何获取分组的导入配置类的:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Return the imports defined by the group.
 * 返回通过组定义的导入类
 * @return each import with its associated configuration class
 */</span>
<span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Group</span><span class="o">.</span><span class="na">Entry</span><span class="o">&gt;</span> <span class="nf">getImports</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">DeferredImportSelectorHolder</span> <span class="n">deferredImport</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">deferredImports</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//调用org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.AutoConfigurationGroup#process 获取所有的EnableAutoConfiguration候选配置类</span>
        <span class="k">this</span><span class="o">.</span><span class="na">group</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">deferredImport</span><span class="o">.</span><span class="na">getConfigurationClass</span><span class="o">().</span><span class="na">getMetadata</span><span class="o">(),</span>
                <span class="n">deferredImport</span><span class="o">.</span><span class="na">getImportSelector</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">//返回满足条件的导入类</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">group</span><span class="o">.</span><span class="na">selectImports</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  此方法主要是 <strong>group.process</strong> 和 <strong>group.selectImports</strong> , <strong>group.process</strong> 的作用是通过SPI机制获取所有的EnableAutoConfiguration候选配置类,而 <strong>group.selectImports</strong> 就是筛选出满足条件的配置类.<br />
  继续看 <strong>group.process</strong> :</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="nc">AnnotationMetadata</span> <span class="n">annotationMetadata</span><span class="o">,</span> <span class="nc">DeferredImportSelector</span> <span class="n">deferredImportSelector</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">state</span><span class="o">(</span><span class="n">deferredImportSelector</span> <span class="k">instanceof</span> <span class="nc">AutoConfigurationImportSelector</span><span class="o">,</span>
            <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Only %s implementations are supported, got %s"</span><span class="o">,</span>
                    <span class="nc">AutoConfigurationImportSelector</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">(),</span>
                    <span class="n">deferredImportSelector</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="c1">//通过SPI机制获取满足条件的EnableAutoConfiguration的实现类</span>
    <span class="nc">AutoConfigurationEntry</span> <span class="n">autoConfigurationEntry</span> <span class="o">=</span> <span class="o">((</span><span class="nc">AutoConfigurationImportSelector</span><span class="o">)</span> <span class="n">deferredImportSelector</span><span class="o">)</span>
            <span class="o">.</span><span class="na">getAutoConfigurationEntry</span><span class="o">(</span><span class="n">getAutoConfigurationMetadata</span><span class="o">(),</span> <span class="n">annotationMetadata</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">autoConfigurationEntries</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">autoConfigurationEntry</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">importClassName</span> <span class="o">:</span> <span class="n">autoConfigurationEntry</span><span class="o">.</span><span class="na">getConfigurations</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">entries</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">importClassName</span><span class="o">,</span> <span class="n">annotationMetadata</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Return the {@link AutoConfigurationEntry} based on the {@link AnnotationMetadata}
 * of the importing {@link Configuration @Configuration} class.
 * 根据导入的Configuration注解类的AnnotationMetadata返回AutoConfigurationEntry
 * @param autoConfigurationMetadata the auto-configuration metadata
 * @param annotationMetadata the annotation metadata of the configuration class
 * @return the auto-configurations that should be imported
 */</span>
<span class="kd">protected</span> <span class="nc">AutoConfigurationEntry</span> <span class="nf">getAutoConfigurationEntry</span><span class="o">(</span><span class="nc">AutoConfigurationMetadata</span> <span class="n">autoConfigurationMetadata</span><span class="o">,</span>
        <span class="nc">AnnotationMetadata</span> <span class="n">annotationMetadata</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//判断是否开启自动配置</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isEnabled</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">EMPTY_ENTRY</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//获取@EnableAutoConfiguration注解的属性 即exclude和excludeName</span>
    <span class="nc">AnnotationAttributes</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">getAttributes</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">);</span>
    <span class="c1">//通过SpringFactoriesLoader.loadFactoryNames#META-INF/spring.factories中查找所有的EnableAutoConfiguration候选配置类</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">configurations</span> <span class="o">=</span> <span class="n">getCandidateConfigurations</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">,</span> <span class="n">attributes</span><span class="o">);</span>
    <span class="c1">//通过LinkedHashSet去重</span>
    <span class="n">configurations</span> <span class="o">=</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">configurations</span><span class="o">);</span>
    <span class="c1">//获取所有排除的包</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">exclusions</span> <span class="o">=</span> <span class="n">getExclusions</span><span class="o">(</span><span class="n">annotationMetadata</span><span class="o">,</span> <span class="n">attributes</span><span class="o">);</span>
    <span class="n">checkExcludedClasses</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="n">exclusions</span><span class="o">);</span>
    <span class="n">configurations</span><span class="o">.</span><span class="na">removeAll</span><span class="o">(</span><span class="n">exclusions</span><span class="o">);</span>
    <span class="c1">//获取配置类过滤器 从META-INF/spring.factories中加载AutoConfigurationImportFilter的实现类</span>
    <span class="n">configurations</span> <span class="o">=</span> <span class="n">filter</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="n">autoConfigurationMetadata</span><span class="o">);</span>
    <span class="c1">//处理自动配置导入事件</span>
    <span class="n">fireAutoConfigurationImportEvents</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="n">exclusions</span><span class="o">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">AutoConfigurationEntry</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="n">exclusions</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getCandidateConfigurations</span><span class="o">(</span><span class="nc">AnnotationMetadata</span> <span class="n">metadata</span><span class="o">,</span> <span class="nc">AnnotationAttributes</span> <span class="n">attributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//获取所有EnableAutoConfigurationde实现类名</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">configurations</span> <span class="o">=</span> <span class="nc">SpringFactoriesLoader</span><span class="o">.</span><span class="na">loadFactoryNames</span><span class="o">(</span><span class="n">getSpringFactoriesLoaderFactoryClass</span><span class="o">(),</span>
            <span class="n">getBeanClassLoader</span><span class="o">());</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notEmpty</span><span class="o">(</span><span class="n">configurations</span><span class="o">,</span> <span class="s">"No auto configuration classes found in META-INF/spring.factories. If you "</span>
            <span class="o">+</span> <span class="s">"are using a custom packaging, make sure that file is correct."</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">configurations</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getSpringFactoriesLoaderFactoryClass</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">EnableAutoConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  由上述调用链就可以很清晰的看出 <strong>getAutoConfigurationEntry</strong> 通过SPI机制获取 <strong>EnableAutoConfiguration</strong> 的自动配置实现类.<br />
  再来看下 <strong>group.selectImports</strong> :</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&gt;</span> <span class="nf">selectImports</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">autoConfigurationEntries</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//所有需要排除的配置</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">allExclusions</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">autoConfigurationEntries</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">AutoConfigurationEntry:</span><span class="o">:</span><span class="n">getExclusions</span><span class="o">).</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">Collection:</span><span class="o">:</span><span class="n">stream</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">());</span>
        <span class="c1">//找到的所有配置</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">processedConfigurations</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">autoConfigurationEntries</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">AutoConfigurationEntry:</span><span class="o">:</span><span class="n">getConfigurations</span><span class="o">).</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">Collection:</span><span class="o">:</span><span class="n">stream</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toCollection</span><span class="o">(</span><span class="nl">LinkedHashSet:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
        <span class="c1">//移除需要排除的</span>
        <span class="n">processedConfigurations</span><span class="o">.</span><span class="na">removeAll</span><span class="o">(</span><span class="n">allExclusions</span><span class="o">);</span>
        <span class="c1">//重新排序</span>
        <span class="k">return</span> <span class="nf">sortAutoConfigurations</span><span class="o">(</span><span class="n">processedConfigurations</span><span class="o">,</span> <span class="n">getAutoConfigurationMetadata</span><span class="o">()).</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">((</span><span class="n">importClassName</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">entries</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">importClassName</span><span class="o">),</span> <span class="n">importClassName</span><span class="o">))</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>  以上步骤就很清晰了,移除所有指定的配置,并将实现剩下的配置重新排序返回.</p>
<blockquote>
  <p>可见deferredImportSelectorHandler.process()就是SpringBoot的自动配置功能,找到/META-INF/spring.factories中所有的EnableAutoConfiguration实现类,并解析这些配置类.</p>
</blockquote>

<hr />
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">October 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000012" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>BalancedBinaryTree</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-jue-5806480.jpg" class="img-responsive img-centered" alt="BalancedBinaryTree">

                            
                                <h3>平衡二叉查找树</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />
<p>  因为二叉查找树在极端情况会退化成链表,导致查询的时间复杂度为O(n).因为平衡二叉查找树应运而生.<br />
  它是一种结构平衡的二查叉找树,即叶节点高度差的绝对值不超过1,并且左右两个子树都是一棵平衡二叉查找树.<br />
  它能在 __O(logn) __ 内完成插入、查找和删除操作.</p>
<hr />

<h3 id="2-3查找树">2-3查找树</h3>
<hr />
<p>  一棵2-3查找树或为一棵空树,或由以下节点组成:</p>
<ul>
  <li>2-节点:含有一个键(及其对应的值)和两条链接,左链接指向的2-3树中的键都小于该节点,右链接指向的2-3树中的键都大于该节点</li>
  <li>3-节点:含有两个键(及其对应的值)和三条链接,左链接指向的2-3树中的键都小于该节点,中链接指向的2-3树中的键都位于该节点的两个键之间,右链接指向的2-3树中的键都大于该节点 
  将指向一棵空树的链接称为空链接,一棵完美平衡的2-3查找树中的所有空链接到根节点的距离都应该相同,2-3查找树如下图:</li>
</ul>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/2-3 查找树示意图.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="2-3 查找树示意图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/2-3 查找树示意图.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">2-3 查找树示意图</div>
    </a>
</center>

<p>1.查找<br />
  判断一个键是否在树中,我们先将它和根节点中的键比较.如果它和其中任意个相等,查找命中;否则我们就根据比较的结果找到指向相应区间的链接,并在其指向的子树中递归地继续查找,如果这是个空链接,查找未命中.具体查询过程如图:</p>

<center>  
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/2-3 树中的查找命中(左)和未命中(右).png">  
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="2-3 树中的查找命中(左)和未命中(右)" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/2-3 树中的查找命中(左)和未命中(右).png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">2-3 树中的查找命中(左)和未命中(右)</div>  
    </a>  
</center>

<p>2.向2-节点中插入新键<br />
  要在2-3树中插入一个新节点,可以和二叉查找树一样先进行一次未命中的查找,然后把新节点挂在树的底部,但是这样的话无法保持完美平衡性.<br />
  我们使用2-3树的主要原因就在于它能够在插入后继续保持平衡.如果未命中的查找结束于一个2-节点:我们只要把这个2-节点替换为一个3-节点,将要插入的键保存到其中即可(如下图);如果未命中的查找结束于一个3-节点,事情就麻烦一点.</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向2- 结点中插入新的键.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向2- 结点中插入新的键" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向2- 结点中插入新的键.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">向2- 结点中插入新的键</div>
    </a>
</center>

<p>3.向一棵只含有一个3-节点的树中插入新键<br />
  假设我们需要向一棵只含有一个3-节点的树中插入一个新键.这棵树中有两个键,所以在它唯一的节点中已经没有可插入新键的空间了.<br />
  为了将新键插入,我们先临时将新键存入该节点中,使之成为一个4-节点.创建一个4-节点很方便,因为很容易将它转换为一棵由3个2-节点组成的2-3树,其中一个节点(根)含有中键,一个节点含有3个键中的最小者(和根节点的左链接相连),一个节点含有3个键中的最大者(和根节点的右链接相连).<br />
  这棵树既是一棵含有3个节点的二叉查找树,同时也是一棵完美平衡的2-3树,因为其中所有的空链接到根节点的距离都相等.插入前树的高度为0,插入后树的高度为1.它说明了树是如何生长的.如下图所示:</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向一棵只含有一个3-结点的树中插入新键.png">  
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向一棵只含有一个3-结点的树中插入新键" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向一棵只含有一个3-结点的树中插入新键.png" />  
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">向一棵只含有一个3-结点的树中插入新键</div>  
    </a>  
</center>

<p>4.向一个父节点为2-节点的3-节点插入新键<br />
  假设未命中的查找结束于一个3-节点,而它的父节点是一个2-节点.在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间.<br />
  我们先像刚才一样构造一个临时的4-节点并将其分解,但此时我们不会为中键创建一个新节点,而是将其移动至原来的父节点中.<br />
  你可以将这次转换看成将指向原3-节点的一条链接替换为新父节点中的原中键左右两边的两条链接,并分别指向两个新的2-节点.<br />
  根据我们的假设,父节点是有空间的:父节点是一个2-节点(一个键两条链接),插入之后变为了一个3-节点(两个键三条链接).<br />
  这次转换也并不影响2-3树的主要性质.树仍然是有序的,因为中键被移动到父节点中去了;树仍然是完美平衡的,插入后所有的空链接到根节点的距离仍然相同,过程如下图所示:</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向一个父结点为2-结点的3-结点中插入新键.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向一个父结点为2-结点的3-结点中插入新键" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向一个父结点为2-结点的3-结点中插入新键.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">向一个父结点为2-结点的3-结点中插入新键</div>
    </a>
</center>

<p>5.向一个父节点为3-节点的3-节点中插入新键<br />
  现在假设未命中的查找结束于一个父节点为3-节点的节点.我们再次和刚才一样构造一个临时的4-节点并分解它,然后将它的中键插入它的父节点中.但父节点也是一个3-节点,因此我们再用和这个中键构造一个新的临时4-节点,然后在这节点上进行相同的变换,即分解这个父节点并将它的中键插入到它的父节点中.<br />
  我们就这样一直向上不断分解临时的4-节点并将中间插入到它的父节点中,直到遇到一个2-节点并将它替换为一个不需要继续分解的3-节点,或者是到达3-节点的根.过程如下图:</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向一个父结点为3-结点的3-结点中插入新键.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向一个父结点为3-结点的3-结点中插入新键" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向一个父结点为3-结点的3-结点中插入新键.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">向一个父结点为3-结点的3-结点中插入新键</div>
    </a>
</center>

<p>6.分解根节点<br />
  如果从插入节点到根节点的路径上全都是3-节点,我们的根节点最终变成一个临时的4-节点.此时我们可以按照向一棵只有一个3-节点的树中插入新键的方法处理这个问题.我们将临时的4-节点分解为3个2-节点,使得树高加1,如下图所示:</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/分解根结点.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="分解根结点" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/分解根结点.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">分解根结点</div>
    </a>
</center>

<p>7.局部变换<br />
  将一个4-节点分解为一棵2-3树可能有6种情况,总结在下图.<br />
  这个4-节点可能是根节点,可能是一个2-节点的左子节点或右子节点,也可能是一个3-节点的左子节点、中子节点或者右子节点.<br />
  2-3树插入算法的根本在于这些变换都是局部的:除了相关的节点和链接之外不必修改或者检查树的其他部分.每次变换中,变更的链接数量不会超过一个很小的常数.需要特别指出的是,不光是在树的底部,树中的任何地方只要符合相应的模式,变换都可以进行.每个变换都会将4-节点中的一个键送入它的父节点中,并重构相应的链接而不必涉及树的其他部分.</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/在一棵2-3树中分解一个4-结点的情况汇总.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="在一棵2-3树中分解一个4-结点的情况汇总" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/在一棵2-3树中分解一个4-结点的情况汇总.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">在一棵2-3树中分解一个4-结点的情况汇总</div>
    </a>
</center>

<p>8.全局性质<br />
  这些局部变换不会影响树的全局有序性和平衡性:任意空链接到根节点的路径长度都是相等的.<br />
  下图所示的是当一个4-节点是一个3-节点的中子节点时的完整变换情况.如果在变换之前根节点到所有空链接的路径长度为h,那么变换之后该长度仍然为h.所有的变换都是这个性质,即使是将一个4-节点分解为两个2-节点并将其父节点由2-节点变为3-节点,或是由3-节点变为一个临时的4-节点也是如此.<br />
  当根节点被分解为3个2-节点时,所有空链接到根节点的路径长度才会加1.</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/4-结点的分解是一次局部变换,不会影响树的有序性和平衡性.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="4-结点的分解是一次局部变换,不会影响树的有序性和平衡性" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/4-结点的分解是一次局部变换,不会影响树的有序性和平衡性.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">4-结点的分解是一次局部变换,不会影响树的有序性和平衡性</div>
    </a>
</center>

<p>  和标准的二叉查找树由上向下生长不同,2-3树的生长是由下向上的.如下图所示:</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/2-3树的构造轨迹.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="2-3树的构造轨迹" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/2-3树的构造轨迹.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">2-3树的构造轨迹</div>
    </a>
</center>

<blockquote>
  <p>结论
在一棵大小为N的2-3树中,查找和插入操作访问的节点必然不超过lgN个</p>
</blockquote>

<hr />

<h3 id="红黑二叉查找树">红黑二叉查找树</h3>
<hr />
<p>1.替换3-节点<br />
  红黑二叉查找树背后的基本思想是用标准的二叉查找树(完全由2-节点构成)和一些额外的信息(替换3-节点)来表示2-3树.
我们将树中的链接分为两种类型:红链接将两个2-节点链接起来构成一个3-节点,黑链接则是2-3树中的普通链接.确切地说,我们将3-节点表示为由一条左斜的红色链接(两个2-节点其中之一是另一个左子节点)相连的两个2-节点,如下图所示.
这种表示法的一个优点是,无需修改就可以直接只用标准二叉查找树的get()方法.对于任意的2-3树,只要对节点进行转换,我们都可以立即派生出一颗对应的二叉查找树.将用这种方式表示2-3树的二叉查找树称为红黑二叉查找树.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/由一条红色左链接相连的两个2-结点表示一个3-结点.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="由一条红色左链接相连的两个2-结点表示一个3-结点" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/由一条红色左链接相连的两个2-结点表示一个3-结点.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">由一条红色左链接相连的两个2-结点表示一个3-结点</div>
    </a>
</center>

<p>2.等价的定义<br />
  红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树:</p>
<ul>
  <li>红链接均为左链接</li>
  <li>没有任何一个节点同时和两条红链接相连</li>
  <li>该树是完美黑色平衡的,即任意空链接到根节点的路径上的黑链接数量相同</li>
</ul>

<p>3.一一对应<br />
  如果我们将一棵红黑树的红链接画平,那么所有的空链接到根节点的距离都将使相同的.如下图所示.
如果将由红链接相连的节点合并,得到的就是一棵2-3树.相反,如果将一棵2-3树中的3-节点画做由红色左链接相连的两个2-节点,那么不会存在能够和两条红链接相连的节点,且树必然是完美黑色平衡的,因为黑链接即2-3树中的普通链接,根据定义这些链接必然是完美平衡的.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/将红链接画平时,一棵红黑树就是一棵2-3树.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="将红链接画平时,一棵红黑树就是一棵2-3树" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/将红链接画平时,一棵红黑树就是一棵2-3树.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">将红链接画平时,一棵红黑树就是一棵2-3树</div>
    </a>
</center>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/红黑树和2-3树的一一对应关系.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="红黑树和2-3树的一一对应关系" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/红黑树和2-3树的一一对应关系.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">红黑树和2-3树的一一对应关系</div>
    </a>
</center>
<p>4.颜色表示<br />
  因为每个节点都只会有一条指向自己的链接(从它的父节点指向它),我们将链接的颜色保存在表示节点的Node数据类型的布尔变量color中.如果指向它的链接的颜色是红色的,那么该变量为true,黑色为false.约定空链接为黑色.
使用私有方法isRed()来测试一个节点和它的父节点之间的链接的颜色.当我们提到一个节点的颜色时,我们指的是指向该节点的链接的颜色,反之亦然.代码及图示如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="no">RED</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="no">BLACK</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">{</span>
    <span class="nc">Key</span> <span class="n">key</span><span class="o">;</span>        <span class="c1">//键</span>
    <span class="nc">Value</span> <span class="n">value</span><span class="o">;</span>    <span class="c1">//相关联的值</span>
    <span class="nc">Node</span> <span class="n">left</span><span class="o">,</span><span class="n">right</span><span class="o">;</span><span class="c1">//左右子树</span>
    <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>          <span class="c1">//这棵子树中的节点总数</span>
    <span class="kt">boolean</span> <span class="n">color</span><span class="o">;</span>  <span class="c1">//由其父节点指向它的链接的颜色</span>

    <span class="nc">Node</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">color</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span><span class="o">=</span><span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span><span class="o">=</span><span class="n">val</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">N</span><span class="o">=</span><span class="no">N</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span><span class="o">=</span><span class="n">color</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isRed</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="no">RED</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/红黑树的结点表示.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="红黑树的结点表示" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/红黑树的结点表示.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">红黑树的结点表示</div>
    </a>
</center>

<p>5.旋转<br />
  在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接,但在操作完成前这些情况都会被小心地旋转并修复.旋转操作会改变红链接的指向.
首先,假设我们有一条红色的右链接需要被转化为左链接,如下图.这个操作叫做左旋转,它对应的方法接受一条并指向红黑树中的某个节点的链接作为参数.
假设被指向的节点的右链接是红色的,这个方法会对树进行必要的调整并返回一个指向包含同一组键的子树且左链接为红色的根节点的链接.
这个操作很容易理解:我们只是将用两个键中的较小者作为根节点变为较大者作为根节点.实现将一个红色左链接转换为一个红色右链接的一个右旋转的代码完全相同,只需要将left和right互换即可.</p>
<ul>
  <li>左旋转
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Node</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">){</span>
  <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
  <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
  <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
  <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
  <span class="n">h</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
  <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">N</span><span class="o">;</span>
  <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)+</span><span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/左旋转h的右链接.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="左旋转h的右链接" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/左旋转h的右链接.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">左旋转h的右链接</div>
    </a>
</center>

<ul>
  <li>右旋转
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Node</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">){</span>
  <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
  <span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
  <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
  <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
  <span class="n">h</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
  <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">N</span><span class="o">;</span>
  <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)+</span><span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/右旋转h的左链接.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="右旋转h的左链接" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/右旋转h的左链接.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">右旋转h的左链接</div>
    </a>
</center>

<p>6.在旋转后重置父节点的链接<br />
  无论坐旋转还是右旋转,旋转操作都会返回一条链接.我们总是会用rotateRight()或rotateLeft()的返回值重置父节点(或是根节点)中相应的链接.
返回的链接可能是左链接也可能是右链接,但是我们总会将它赋予父节点中的链接.这个链接可能是红色也可能黑色–rotateLeft()和rotateRight()都通过将x.color设为h.color保留它原来的颜色.
这可能会产生两条连续的红链接,但我们的算法会继续用旋转操作修正这种情况.<br />
  在插入新的键时,我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系,因为旋转操作可以保证红黑树的两个重要性质:有序性和完美平衡性.
也就是说,我们在红黑树中进行旋转时无需为树的有序性或完美平衡性担心.下面我们继续看看如何使用旋转操作来保持红黑树的另外两个重要性质.</p>

<p>7.向单个2-节点中插入新键<br />
  一棵树只含有一个键的红黑树只含有一个2-节点.插入另一个键后,马上就需要将它们旋转.如果新键小于老键,只需要新增一个红色的节点即可,新的红黑树和单个3-节点完全等价.
如果新键大于老键,那么新增的红色节点将会产生一条红色的右链接.我们需要使用 <strong>root=rotateLeft(root)</strong> 将其旋转为红色左链接并修正根节点,插入操作才算完成.
两种情况的结果为一棵和单个3-节点等价的红黑树,其中含有两个键,一条红链接,树的黑链接高度为1,如下图所示:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向单个2-结点中插入一个新键.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向单个2-结点中插入一个新键" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向单个2-结点中插入一个新键.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">向单个2-结点中插入一个新键</div>
    </a>
</center>

<p>8.向树底部的2-节点插入新键<br />
  用和二叉树查找树相同的方式向一棵红黑树中插入一个新键会在树的底部新增一个节点(为了保证有序性),但总是用红链接将新节点和它的父节点相连.
如果它的父节点是一个2-节点,那么刚才讨论的两种处理方法仍然适用.如果指向新节点的是父节点的左链接,那么父节点就直接成为了一个3-节点;
如果指向新节点的是父节点的右链接,这就是一个错误的3-节点,但一次左旋转就能修正它,如下图所示:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向树底部的2-结点插入一个新键.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向树底部的2-结点插入一个新键" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向树底部的2-结点插入一个新键.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">向树底部的2-结点插入一个新键</div>
    </a>
</center>

<p>9.向一棵双键树(即一个3-节点)中插入新键<br />
  这种情况又可分为三种情况:新键小于树中的两个键,在两者之间,或是大于树中的两个键.每种情况都会产生一个同时链接到两条红链接的节点,而我们的目标就是修正这一点.</p>
<ul>
  <li>三者中最简单的情况就是新键大于原树中的两个键,因此它被链接到3-节点的右链接.此时树是平衡的,根节点为中间大小的键,它有两条红链接分别和较小和较大的节点相连.
如果我们将两条链接的颜色都由红变黑,那么我们就得到了一棵有三个节点组成,高度为2的平衡树.它正好能对应一棵2-3树,如下图左侧.其他两种情况最终也会转换为这种情况.</li>
  <li>如果新键小于原树中的两个键,它就会被链接到最左边的空链接,这种就产生了两条连续的红链接,如下图中间侧.此时我们只需要将上层的红链接右旋转即可得到第一种情况(中值键为根节点并和其他两个节点用红链接相连)</li>
  <li>如果新键介于原树中的两个键之间,这又会产生两条连续的红链接,一条红色左链接接一条红色右链接,如下图右侧.此时我们只需要将下层的红链接左旋转即可得到第二种情况(两条连续的红色链接)</li>
</ul>

<p>  总的来说,我们通过0次,1次和2次旋转以及颜色的变化得到了期望的结果.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向一棵双键树(即一个3-结点)中插入一个新键的三种情况.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向一棵双键树(即一个3-结点)中插入一个新键的三种情况" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向一棵双键树(即一个3-结点)中插入一个新键的三种情况.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">向一棵双键树(即一个3-结点)中插入一个新键的三种情况</div>
    </a>
</center>

<p>10.颜色转换<br />
  如下图,我们专门用一个方法 <strong>flipColors()</strong> 来转换一个节点的两个红色子节点的颜色.除了将子节点的颜色由红变黑之外,我们同时还要将父节点的颜色由黑变红.
这项操作最重重要的性质在于它和旋转操作一样是局部变换,不会影响整棵树的黑色平衡.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/通过转换链接的颜色来分解4-结点.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="通过转换链接的颜色来分解4-结点" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/通过转换链接的颜色来分解4-结点.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">通过转换链接的颜色来分解4-结点</div>
    </a>
</center>

<p>11.根节点总是黑色<br />
  在第9种情况中,颜色转换会使根节点变为红色.严格的说,红色的根节点说明根节点是一个3-节点的一部分,但是实际情况并不是这样.因此我们在每次插入后都会将根节点设为黑色.注意,每当根节点由红变黑时树的黑链接高度就会加1.</p>

<p>12.向树底部的3-节点插入新键<br />
  现在假设我们需要在树的底部的一个3-节点下加入一个新节点.前面讨论的三种情况都会出现,如下图所示.指向新节点的链接可能是3-节点的右链接(此时我们只需要转换颜色即可),
或是左链接(此时我们需要进行右旋转然后再转换颜色),或是中链接(此时我们需要先左旋转下层链接然后右旋转上层链接,最后再转换颜色).颜色转换会使到中节点的链接变红,相当于将它送入了父节点.这意味着在父节点中继续插入一个新键,我们也会用相同的办法解决这个问题.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向树底部的3-结点插入一个新键.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向树底部的3-结点插入一个新键" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/向树底部的3-结点插入一个新键.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">向树底部的3-结点插入一个新键</div>
    </a>
</center>

<p>13.将红链接在树中向上传递<br />
  2-3树中的插入算法需要我们分解3-节点,将中间键插入父节点,如此这般直到遇到一个2-节点或是根节点.我们所考虑过的所有情况都是为了达成这个目标:
每次必要的旋转之后我们都会进行颜色转换,这使得中节点变红.在父节点看来,处理这样一个红色节点的方式和处理一个新插入的红色节点完全相同,即继续把红链接转移到中节点上去.
下图中总结的三种情况显示了在红黑树中实现2-3树的插入算法的关键操作所需的步骤:要在一个3-节点下插入新键,先创建一个临时的4-节点,将其分解并将红链接由中间键传递给它的父节点.重复这个过程,我们就能将红链接在树中向上传递,直至遇到一个2-节点或者根节点.<br />
  总之,只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作,我们就能保证插入操作后红黑树和2-3树的一一对应关系.在沿着插入点到根节点的路上向上移动时在所经过的每个节点中顺序完成以下操作,我们就能完成插入操作:</p>
<ul>
  <li>如果右子节点是红色的而左子节点是黑色的,进行左旋转</li>
  <li>如果左子节点是红色的且它的左子节点也是红色的,进行右旋转</li>
  <li>如果左右子节点均为红色,进行颜色转换</li>
</ul>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/红黑树中红链接向上传递.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="红黑树中红链接向上传递" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/红黑树中红链接向上传递.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">红黑树中红链接向上传递</div>
    </a>
</center>

<p>14.实现<br />
  因为保持树的平衡性所需的操作是由下向上在每个经过的节点中进行的,将它们植入我们已有的实现中十分简单:只需要在递归调用之后完成这些操作即可.算法如下所示:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReaBlackBST</span><span class="o">&lt;</span><span class="nc">Key</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;&gt;,</span> <span class="nc">Value</span><span class="o">&gt;</span>
<span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="c1">//含有color变量的Node对象</span>
    
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isRed</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">flipColors</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">//查找key,找到则更新其值,否则为它新建一个节点</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">BLACK</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">h</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="no">RED</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">cmp</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">h</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)){</span>
            <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  除了递归调用后的三条if语句,红黑树中put()的递归实现和二叉查找树中put()的实现完全相同.它们在查找路径上保证了红黑树和2-3树的一一对应关系,
使得树的平衡性接近完美.第一条if语句会将任意含有红色右链接的3-节点(或临时的4-节点)向左旋转;第二条if语句会将临时的4-节点中两条连续红链接中的上层链接向右旋转;
第三条if语句会进行颜色转换并将红链接在树中向上传递.<br />
  下图给出了使用我们的标准索引测试用例进行测试的轨迹和用同一组键按升序构造一棵红黑树的测试轨迹.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/红黑树的构造轨迹.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="红黑树的构造轨迹" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/红黑树的构造轨迹.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">红黑树的构造轨迹</div>
    </a>
</center>

<p>15.删除操作<br />
  和插入操作一样,我们也可以定义一系列局部变换来在删除一个节点的同时保持树的完美平衡性.这个过程比插入一个节点更加复杂.
因为我们不仅要在(为了删除一个节点而)构造临时4-节点时沿着查找路径向下进行变换,还要在分解遗留的4-节点时沿着查找路径向上进行变换.</p>

<p>16.自顶向下的2-3-4树<br />
  我们先学习一个沿查找路径既能向上也能向下进行变换的稍简单的算法:2-3-4树的插入算法,2-3-4树中允许存在我们以前见过的4-节点.
它的插入算法沿查找路径向下进行变换是为了保证当前节点不是4-节点(这样树底才有空间来插入新的键),沿查找路径向上进行变换是为了将之前创建的4-节点配平,如下图所示.<br />
  向下的变换和我们在2-3树中分解4-节点所进行的变换完全相同.</p>
<ul>
  <li>如果根节点是4-节点,我们就将它分解成三个2-节点,使得树高加1</li>
  <li>在向下查找的过程中,如果遇到一个父节点为2-节点的4-节点,我们将4-节点分解成两个2-节点并将其中间键传递给它的父节点,使得父节点变为一个3-节点</li>
  <li>如果遇到一个父节点为3-节点的4-节点,我们将4-节点分解为两个2-节点并将其中间键传递给它的父节点,使得父节点变为一个4-节点</li>
</ul>

<p>我们不必担心会遇到父节点为4-节点的4-节点,因为插入算法本身就保证了这种情况不会出现.到达树的底部之后,也只会遇到3-节点或者3-节点,所以我们可以插入新的键.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/自顶向下的2-3-4树的插入算法中的变换.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="自顶向下的2-3-4树的插入算法中的变换" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/自顶向下的2-3-4树的插入算法中的变换.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">自顶向下的2-3-4树的插入算法中的变换</div>
    </a>
</center>
<p>要用红黑树实现这个算法,我们需要:</p>
<ul>
  <li>将4-节点表示为由三个2-节点组成的一棵平衡的子树,根节点和两个子节点都用红链接相连</li>
  <li>在向下的过程中分解所有4-节点并进行颜色转换</li>
  <li>和插入操作一样,在向上的过程中用旋转将4-节点配平</li>
</ul>

<p>  我们只需要移动算法14的pub()方法中的一行代码就能实现2-3-4树中的插入操作:将colorFlip()语句(及其if语句)移动到递归调用之前(null测试和比较操作之间).</p>

<p>17.删除最小键  <br />
  我们注意到从树底部的3-节点中删除键是很简单的,但2-节点则不然.从2-节点中删除一个键会留下一个空节点,一般我们会将它替换为一个空链接,
但这样会破坏树的完美平衡性.所以我们需要这样做:为了保证我们不会删除一个2-节点,我们沿着左链接向下进行变换,确保当前节点不是2-节点(可能是3-节点,也可能是临时的4-节点).
首先,根节点可能有两种情况.如果根是2-节点且它的两个子节点都是2-节点,我们可以直接将这个三个节点变成一个4-节点;否则我们需要保证根节点的左子节点不是2-节点,
如果有必要可以从它右侧的兄弟节点借一个键来.以上情况如下图所示.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/删除最小键操作中的变换.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="删除最小键操作中的变换" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/删除最小键操作中的变换.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">删除最小键操作中的变换</div>
    </a>
</center>
<p>  在沿着左链接向下的过程中,保证以下情况之一成立:</p>
<ul>
  <li>如果当前节点的左子节点不是2-节点,完成</li>
  <li>如果当前节点的左子节点是2-节点而它的亲兄弟节点不是2-节点,将左子节点的兄弟节点中的一个键移动左子节点中</li>
  <li>如果当前节点的左子节点和它的亲兄弟节点都是2-节点,将左子节点、父节点中的最小键和左子节点最近的兄弟节点合并为一个4-节点,使父节点由3-节点变为2-节点或者由4-节点变为3-节点</li>
</ul>

<p>  在遍历的过程中执行这个过程,最后能够得到一个含有最小键的3-节点或者4-节点,然后我们就可以直接从其中将其删除,将3-节点变为2-节点,
或者将4-节点变为3-节点.然后我们再回头向上分解所有临时的4-节点</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Node</span> <span class="nf">moveRedLeft</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">){</span>
    <span class="c1">//假设节点h为红色,h.left和h.left.left都是黑色</span>
    <span class="c1">//将h.left或者h.left的子节点之一变红</span>
    <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
        <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMin</span><span class="o">(){</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">)){</span>
        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">deleleMin</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">()){</span>
        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">BLACK</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">Node</span> <span class="nf">deleteMin</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
        <span class="n">h</span><span class="o">.</span><span class="na">moveRedLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">balance</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">Node</span> <span class="nf">balance</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)){</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span> <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>

    <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  其中balance()方法由下一行代码和算法14的最后5行代码组成: <strong>if (isRed(h.right)) h = rotateLeft(h);</strong><br />
  这里的flipColors()方法将补全三条链接的颜色,而不是正文中实现插入操作时实现的flipColors()方法.
对于删除,我们会将父节点设为BLACK(黑)而将两个子节点设为RED(红).</p>

<p>18.删除最大键<br />
  实现红黑树的deleteMax()方法.需要注意的是因为红链接都是左链接,所以这里用到的变换和上一道练习中的稍有不同.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Node</span> <span class="nf">moveRedRight</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">){</span>
    <span class="c1">//假设节点h为红色,h.right和h.right.left都是黑色</span>
    <span class="c1">//将h.right或者h.right的子节点之一变红</span>
    <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMax</span><span class="o">(){</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">)){</span>
        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">deleteMax</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">()){</span>
        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">BLACK</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">Node</span> <span class="nf">deleteMax</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
        <span class="n">h</span><span class="o">.</span><span class="na">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">moveRedRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMax</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">balance</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>19.删除操作<br />
  在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前节点均不是2-节点.
如果被查找的键在树的底部,我们可以直接删除它.如果不在,我们需要将它和它的后继节点交换,就和二叉查找树一样.
因为当前节点必然不是2-节点,问题已经转化为一棵根节点不是2-节点的子树中删除最小的键,我们可以在这棵子树中使用前文所述的算法.
和以前一样,删除之后我们需要向上回溯并分解余下的4-节点.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">)){</span>
        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">()){</span>
        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">BLACK</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">moveRedLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">)){</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">moveRedRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">h</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">min</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">).</span><span class="na">key</span><span class="o">);</span>
            <span class="n">h</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">).</span><span class="na">key</span><span class="o">;</span>
            <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nf">balance</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />

<h3 id="红黑树的性质">红黑树的性质</h3>
<hr />

<p>  最终结论是所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别.<br />
1.性能分析</p>
<ul>
  <li>一棵大小为N的红黑树的高度不会超过2lgN
&amp;emps: 证明:红黑树的最坏情况是它所对应的2-3树中构成最左边的路径节点全都是3-节点而其余均为2-节点.
最左边的路径长度是只包含2-节点的路径长度(~lgN)的两倍.</li>
  <li>一棵大小为N的红黑树,根节点到任意节点的平均路径长度为-1.00lgN</li>
</ul>

<p>2.有序符号表API</p>
<ul>
  <li>在一棵红黑树中,以下操作在最坏情况下所需的时间是对数级别的:查找(get)、插入(put)、查找最大键、查找最小键、floor()、ceiling()、rank()、select()、
删除最小键(deleteMin)、删除最大键(deleteMax)、删除(delete)和范围查询(range).</li>
</ul>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/各种符号表实现的性能总结.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="各种符号表实现的性能总结" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/balancedBinaryTree/各种符号表实现的性能总结.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">各种符号表实现的性能总结</div>
    </a>
</center>
<hr />

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Tree</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">Septemper 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000006" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SpringBoot启动源码解析(六)</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-rachel-claire-4577793.jpg" class="img-responsive img-centered" alt="SpringBoot">

                            
                                <h3>SpringBootApplication Run方法解析(四):refreshContext</h3>
                            
                            </div>

                            <p><h3 id="run方法入口">Run方法入口</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Run the Spring application, creating and refreshing a new
 * {@link ApplicationContext}.
 * 运行Spring应用，创建和刷新一个新的应用上下文
 * @param args the application arguments (usually passed from a Java main method)
 * @return a running {@link ApplicationContext}
 */</span>
<span class="kd">public</span> <span class="nc">ConfigurableApplicationContext</span> <span class="nf">run</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//1.创建启动计时器</span>
    <span class="nc">StopWatch</span> <span class="n">stopWatch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StopWatch</span><span class="o">();</span>
    <span class="n">stopWatch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="c1">//创建启动上下文并初始化相应的Bootstrapper 目前暂未使用</span>
    <span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SpringBootExceptionReporter</span><span class="o">&gt;</span> <span class="n">exceptionReporters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//设置系统的配置模式，一般用于服务端开发 默认为true</span>
    <span class="n">configureHeadlessProperty</span><span class="o">();</span>
    <span class="c1">//获取spring上下文启动监听者  从META-INF/spring.factories中获取SpringApplicationRunListener的实现类并加载</span>
    <span class="nc">SpringApplicationRunListeners</span> <span class="n">listeners</span> <span class="o">=</span> <span class="n">getRunListeners</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
    <span class="c1">//发布启动中事件</span>
    <span class="n">listeners</span><span class="o">.</span><span class="na">starting</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//2.创建默认上下文参数</span>
        <span class="nc">ApplicationArguments</span> <span class="n">applicationArguments</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultApplicationArguments</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
        <span class="c1">//3.准备环境，将资源属性添加到环境中并与上下文绑定</span>
        <span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span> <span class="o">=</span> <span class="n">prepareEnvironment</span><span class="o">(</span><span class="n">listeners</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
        <span class="c1">//设置spring.beaninfo.ignore中过滤的bean</span>
        <span class="n">configureIgnoreBeanInfo</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
        <span class="c1">//打印spring标记</span>
        <span class="nc">Banner</span> <span class="n">printedBanner</span> <span class="o">=</span> <span class="n">printBanner</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
        <span class="c1">//4.根据web应用类型创建指定的应用上下文</span>
        <span class="c1">//注意:这里反射创建AnnotationConfigServletWebServerApplicationContext时,构造中创建AnnotatedBeanDefinitionReader中的AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)方法很重要</span>
        <span class="c1">//它将几个常见的BeanPostProcessor和BeanFactoryPostProcessor注册到注册表中  最重要的是internalConfigurationAnnotationProcessor来解析Configuration的配置类</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">createApplicationContext</span><span class="o">();</span>
        <span class="n">exceptionReporters</span> <span class="o">=</span> <span class="n">getSpringFactoriesInstances</span><span class="o">(</span><span class="nc">SpringBootExceptionReporter</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
                <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">ConfigurableApplicationContext</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span> <span class="n">context</span><span class="o">);</span>
        <span class="c1">//5.准备上下文</span>
        <span class="c1">//主要做了两件事:</span>
        <span class="c1">// 1.调用前面实例化的ApplicationContextInitializer的initialize方式初始化上下文</span>
        <span class="c1">// 2.在其中的load方法中将启动主函数bean定义注册到注册表中 beanDefinitionMap</span>
        <span class="n">prepareContext</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">environment</span><span class="o">,</span> <span class="n">listeners</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">,</span> <span class="n">printedBanner</span><span class="o">);</span>
        <span class="c1">//6.刷新上下文</span>
        <span class="n">refreshContext</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="n">afterRefresh</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
        <span class="n">stopWatch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">logStartupInfo</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">StartupInfoLogger</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mainApplicationClass</span><span class="o">).</span><span class="na">logStarted</span><span class="o">(</span><span class="n">getApplicationLog</span><span class="o">(),</span> <span class="n">stopWatch</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//监听者发布已启动事件</span>
        <span class="n">listeners</span><span class="o">.</span><span class="na">started</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="c1">//7.调用所有的ApplicationRunner和CommandLineRunner的实现类</span>
        <span class="n">callRunners</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleRunFailure</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">exceptionReporters</span><span class="o">,</span> <span class="n">listeners</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//监听者发布运行中事件</span>
        <span class="n">listeners</span><span class="o">.</span><span class="na">running</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleRunFailure</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">exceptionReporters</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />
<h3 id="refreshcontext">refreshContext</h3>
<hr />
<p>  本篇我们一起分析下SpringBoot启动流程中最重要的一步 <strong>refreshContext</strong> ,字面意思就是刷新上下文,基本上这个完成后上下文就差不多可以使用了.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">refreshContext</span><span class="o">(</span><span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//刷新上下文, 调用AbstractApplicationContext的refresh方法</span>
    <span class="n">refresh</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="c1">//是否需要注册下线钩子 默认为true</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">registerShutdownHook</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//执行AbstractApplicationContext的注册下线钩子方法</span>
            <span class="n">context</span><span class="o">.</span><span class="na">registerShutdownHook</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">AccessControlException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Not allowed in some environments.</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Refresh the underlying {@link ApplicationContext}.
 * 刷新潜在的上下文
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">refresh</span><span class="o">(</span><span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">AbstractApplicationContext</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">applicationContext</span><span class="o">);</span>
    <span class="o">((</span><span class="nc">AbstractApplicationContext</span><span class="o">)</span> <span class="n">applicationContext</span><span class="o">).</span><span class="na">refresh</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  由此可见,在SpringBoot中 <strong>refresh</strong> 的作用就是调用spring中真正的刷新上下文操作,并在刷新完成后注册上下文下线钩子.<br />
  接下来, 我们来真正看下在spring中的 <strong>refresh</strong> 方法源码:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Synchronization monitor for the "refresh" and "destroy". */</span>
<span class="c1">// 刷新和销毁的同步监视器</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">startupShutdownMonitor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">refresh</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">BeansException</span><span class="o">,</span> <span class="nc">IllegalStateException</span> <span class="o">{</span>
    <span class="c1">//锁定当前监视器锁 保证只有一个</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">startupShutdownMonitor</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Prepare this context for refreshing.</span>
        <span class="c1">//1.为刷新准备上下文,主要是设置启动时间和激活标志位以及初始化一些其他的属性</span>
        <span class="n">prepareRefresh</span><span class="o">();</span>

        <span class="c1">// Tell the subclass to refresh the internal bean factory.</span>
        <span class="c1">//2.告诉子类刷新内部的bean工厂 主要为bean工厂设置serializationId 并返回该bean工厂</span>
        <span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="n">obtainFreshBeanFactory</span><span class="o">();</span>

        <span class="c1">// Prepare the bean factory for use in this context.</span>
        <span class="c1">//3.准备在此上下文中使用的bean工厂 详细解析见下方</span>
        <span class="n">prepareBeanFactory</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// Allows post-processing of the bean factory in context subclasses.</span>
            <span class="c1">// 4. 允许在上下文子类中对bean工厂进行后置处理 注册WebApplicationContextServletContextAwareProcessor后置处理器和注册request、session等特定web范围 </span>
            <span class="n">postProcessBeanFactory</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">);</span>

            <span class="c1">// Invoke factory processors registered as beans in the context.</span>
            <span class="c1">// 非常核心 5.调用在上下文中注册为bean的工厂处理器 通过ConfigurationClassPostProcessor来解析所有的配置类</span>
            <span class="n">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">);</span>

            <span class="c1">// Register bean processors that intercept bean creation.</span>
            <span class="c1">// 6.注册拦截bean创建的bean处理器</span>
            <span class="n">registerBeanPostProcessors</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">);</span>

            <span class="c1">// Initialize message source for this context.</span>
            <span class="c1">// 7.为上下文初始化消息源</span>
            <span class="n">initMessageSource</span><span class="o">();</span>

            <span class="c1">// Initialize event multicaster for this context.</span>
            <span class="c1">// 8.为上下文初始化事件广播器</span>
            <span class="n">initApplicationEventMulticaster</span><span class="o">();</span>

            <span class="c1">// Initialize other special beans in specific context subclasses.</span>
            <span class="c1">// 9. 初始化在指定上下文子类中的其他特殊bean</span>
            <span class="c1">//主要是调用ServletWebServerApplicationContext重写的方法,初始化内置tomcat</span>
            <span class="n">onRefresh</span><span class="o">();</span>

            <span class="c1">// Check for listener beans and register them.</span>
            <span class="c1">//10. 检查监听器bean并注册他们</span>
            <span class="n">registerListeners</span><span class="o">();</span>

            <span class="c1">// Instantiate all remaining (non-lazy-init) singletons.</span>
            <span class="c1">// 11. 实例化所有剩下的非懒加载的单例</span>
            <span class="n">finishBeanFactoryInitialization</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">);</span>

            <span class="c1">// Last step: publish corresponding event.</span>
            <span class="c1">// 12.最后一步发布相关事件</span>
            <span class="n">finishRefresh</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">catch</span> <span class="o">(</span><span class="nc">BeansException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isWarnEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Exception encountered during context initialization - "</span> <span class="o">+</span>
                        <span class="s">"cancelling refresh attempt: "</span> <span class="o">+</span> <span class="n">ex</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Destroy already created singletons to avoid dangling resources.</span>
            <span class="n">destroyBeans</span><span class="o">();</span>

            <span class="c1">// Reset 'active' flag.</span>
            <span class="n">cancelRefresh</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>

            <span class="c1">// Propagate exception to caller.</span>
            <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">// Reset common introspection caches in Spring's core, since we</span>
            <span class="c1">// might not ever need metadata for singleton beans anymore...</span>
            <span class="n">resetCommonCaches</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>refresh</strong> 中的每一个方法都是非常重要的,那就可以大约分为十三步,我们一步步往下分析.</p>

<p>1.第一步准备上下文prepareRefresh,相关源码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//调用AnnotationConfigServletWebServerApplicationContext重写的prepareRefresh</span>
<span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">prepareRefresh</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">scanner</span><span class="o">.</span><span class="na">clearCache</span><span class="o">();</span>
    <span class="c1">//调用父类AbstractApplicationContext的prepareRefresh方法</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">prepareRefresh</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/**
 * Prepare this context for refreshing, setting its startup date and
 * active flag as well as performing any initialization of property sources.
 * 为刷新准备上下文, 设置它的开始时间和激活标志以及执行任何属性源的初始化
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">prepareRefresh</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Switch to active.</span>
    <span class="k">this</span><span class="o">.</span><span class="na">startupDate</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">closed</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">active</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Refreshing "</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Refreshing "</span> <span class="o">+</span> <span class="n">getDisplayName</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Initialize any placeholder property sources in the context environment.</span>
    <span class="c1">//在上下文环境中初始化任何占位符属性源  主要就重置 ServletContext和ServletConfig 默认为空 所以未进行处理</span>
    <span class="n">initPropertySources</span><span class="o">();</span>

    <span class="c1">// Validate that all properties marked as required are resolvable:</span>
    <span class="c1">// see ConfigurablePropertyResolver#setRequiredProperties</span>
    <span class="c1">//验证所有标记为必须的属性都是可解析的</span>
    <span class="n">getEnvironment</span><span class="o">().</span><span class="na">validateRequiredProperties</span><span class="o">();</span>

    <span class="c1">// Store pre-refresh ApplicationListeners...</span>
    <span class="c1">//初始化用于存储ApplicationListeners的集合 </span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">ealryApplicationListeners</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">earlyApplicationListeners</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">.</span><span class="na">applicationListeners</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// Reset local application listeners to pre-refresh state.</span>
        <span class="k">this</span><span class="o">.</span><span class="na">applicationListeners</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">applicationListeners</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">earlyApplicationListeners</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Allow for the collection of early ApplicationEvents,</span>
    <span class="c1">// to be published once the multicaster is available...</span>
    <span class="c1">// 初始化早期事件收集器   允许收集早期的ApplicationEvents, 一旦多播器可用就发布</span>
    <span class="k">this</span><span class="o">.</span><span class="na">earlyApplicationEvents</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见第一步主要就是设置了启动时间 <strong>startupDate</strong> 和启动标志 <strong>active=true</strong> , 初始化上下文中 <strong>ServletContext和ServletConfig</strong> 属性,最后并初始化存放早期应用监听者和应用事件的集合 <strong>earlyApplicationListeners、earlyApplicationEvents</strong> .</p>

<p>2.第二步obtainFreshBeanFactory,相关源码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Tell the subclass to refresh the internal bean factory.
 * 告诉子类刷下内部bean工厂
 */</span>
<span class="kd">protected</span> <span class="nc">ConfigurableListableBeanFactory</span> <span class="nf">obtainFreshBeanFactory</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">//刷新bean工厂 即设置refreshed状态 并 设置bean工厂的序列化id</span>
    <span class="n">refreshBeanFactory</span><span class="o">();</span>
    <span class="c1">//返回持有的bean工厂</span>
    <span class="k">return</span> <span class="nf">getBeanFactory</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/**
 * Do nothing: We hold a single internal BeanFactory and rely on callers
 * to register beans through our public methods (or the BeanFactory's).
 * 我们拥有一个内部bean工厂并依靠调用者通过我们的公共方法注册bean
 */</span>
<span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">refreshBeanFactory</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span> <span class="o">{</span>
    <span class="c1">//使用cas的方式设置 refreshed状态 只有原来为false才会设置成功 否则抛出非法状态异常</span>
    <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">refreshed</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span>
                <span class="s">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//为该bean工厂设置序列化id</span>
    <span class="k">this</span><span class="o">.</span><span class="na">beanFactory</span><span class="o">.</span><span class="na">setSerializationId</span><span class="o">(</span><span class="n">getId</span><span class="o">());</span>
<span class="o">}</span>

<span class="cm">/**
 * Specify an id for serialization purposes, allowing this BeanFactory to be
 * deserialized from this id back into the BeanFactory object, if needed.
 * 为序列化目的指定id,如果需要,运行将此bean工厂从这个id反序列化回bean工厂对象
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSerializationId</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">String</span> <span class="n">serializationId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//如果序列化id不为空 则在serializableFactories中保存当前序列化id和bean工厂的对应关系</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">serializationId</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">serializableFactories</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">serializationId</span><span class="o">,</span> <span class="k">new</span> <span class="nc">WeakReference</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">serializationId</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">serializableFactories</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">serializationId</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//设置当前bean工厂的序列化id</span>
    <span class="k">this</span><span class="o">.</span><span class="na">serializationId</span> <span class="o">=</span> <span class="n">serializationId</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
 * Return the single internal BeanFactory held by this context
 * (as ConfigurableListableBeanFactory).
 * 返回上下文持有的内部单个bean工厂
 */</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="nc">ConfigurableListableBeanFactory</span> <span class="nf">getBeanFactory</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">beanFactory</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  由此可见,第二步的作用就是刷新上下文中的bean工厂,刷新主要包括通过CAS设置bean工厂中的refreshed状态为true,并设置bean工厂的序列化id <strong>serializationId</strong> ,此值为应用的名称,即 <strong>spring.application.name</strong> 指定的名称.<br />
  最后并返回刷新后的bean工厂即可.</p>

<p>3.第三步prepareBeanFactory相关源码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Configure the factory's standard context characteristics,
 * such as the context's ClassLoader and post-processors.
 * 配置工厂的标准上下文特征,例如上下文的类加载和后置处理器
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">prepareBeanFactory</span><span class="o">(</span><span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Tell the internal bean factory to use the context's class loader etc.</span>
    <span class="c1">// 告诉内部bean工厂使用上下文的类加载器等 首先设置类加载器</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">setBeanClassLoader</span><span class="o">(</span><span class="n">getClassLoader</span><span class="o">());</span>
    <span class="c1">// 然后根据类加载器创建StandardBeanExpressionResolver 它的作用是解析#{}表达式通常配合@Value注解使用  #{}用于执行SpEL表达式,并将内容赋值给属性 @{}用于加载外部属性文件中的值 两者可以混合使用</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">setBeanExpressionResolver</span><span class="o">(</span><span class="k">new</span> <span class="nc">StandardBeanExpressionResolver</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanClassLoader</span><span class="o">()));</span>
    <span class="c1">// 设置自定义property编辑注册器 主要是解析application.properties中的属性</span>
    <span class="c1">// 操作如下 https://blog.csdn.znet/qq_43414291/article/details/111226055</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">addPropertyEditorRegistrar</span><span class="o">(</span><span class="k">new</span> <span class="nc">ResourceEditorRegistrar</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">getEnvironment</span><span class="o">()));</span>

    <span class="c1">// Configure the bean factory with context callbacks.</span>
    <span class="c1">// 使用上下文回调设置bean工厂</span>
    <span class="c1">//在bean工厂中添加ApplicationContextAwareProcessor后置处理器  他的主要作用是在初始化bean之前 将所有实现了Aware相关接口的属性设置到bean中</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">addBeanPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">ApplicationContextAwareProcessor</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
    <span class="c1">//忽略指定接口的自动装配功能</span>
    <span class="c1">//主要目的:spring是懒加载,当类A中有属性B时,从容器中获取A对象时会判断属性B是否初始化,没有初始化的话会自动初始化B.</span>
	<span class="c1">//			然而有些情况是不希望初始化B的.例如B实现了BeanNameAware、BeanFactoryAware、BeanClassLoaderAware接口(该接口的作用是获取其在容器中的名称、容器、类加载器)</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">ignoreDependencyInterface</span><span class="o">(</span><span class="nc">EnvironmentAware</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">ignoreDependencyInterface</span><span class="o">(</span><span class="nc">EmbeddedValueResolverAware</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">ignoreDependencyInterface</span><span class="o">(</span><span class="nc">ResourceLoaderAware</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">ignoreDependencyInterface</span><span class="o">(</span><span class="nc">ApplicationEventPublisherAware</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">ignoreDependencyInterface</span><span class="o">(</span><span class="nc">MessageSourceAware</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">ignoreDependencyInterface</span><span class="o">(</span><span class="nc">ApplicationContextAware</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="c1">// BeanFactory interface not registered as resolvable type in a plain factory.</span>
    <span class="c1">// MessageSource registered (and found for autowiring) as a bean.</span>
    <span class="c1">//使用相应的自动装配值注册一个特殊的依赖类型,后面若需要自动装配该类型直接使用接口</span>
    <span class="c1">//registerResolvableDependency作用: 在spring自动装配的时候如果一个接口有多个实现类，并且都已经放到IOC中，那么自动装配会出现异常，spring不知道把哪个实现类注入进入。</span>
    <span class="c1">//									指定该类型接口，如果外部要注入该类型接口的对象，则会注入我们指定的对象，而不会去管其他接口实现类</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerResolvableDependency</span><span class="o">(</span><span class="nc">BeanFactory</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerResolvableDependency</span><span class="o">(</span><span class="nc">ResourceLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerResolvableDependency</span><span class="o">(</span><span class="nc">ApplicationEventPublisher</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerResolvableDependency</span><span class="o">(</span><span class="nc">ApplicationContext</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>

    <span class="c1">// Register early post-processor for detecting inner beans as ApplicationListeners.</span>
    <span class="c1">//注册早期后置处理器 为了检测内部bean作为 ApplicationListener</span>
    <span class="c1">//ApplicationListenerDetector的作用就是检测所有实现了ApplicationListener接口的单例并添加到上下文中</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">addBeanPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">ApplicationListenerDetector</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>

    <span class="c1">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span>
    <span class="c1">//如果有的话, 检测LoadTimeWeaver并准备织入</span>
    <span class="c1">//判断bean工厂中是否包含loadTimeWeaver</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">containsBean</span><span class="o">(</span><span class="no">LOAD_TIME_WEAVER_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">//如果包含的话注册LoadTimeWeaverAwareProcessor后置处理器</span>
        <span class="c1">//它的作用是 在bean初始化前 将默认的LoadTimeWeaver传递给实现了LoadTimeWeaverAware接口的bean</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">addBeanPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">LoadTimeWeaverAwareProcessor</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">));</span>
        <span class="c1">// Set a temporary ClassLoader for type matching.</span>
        <span class="c1">//设置临时类加载器进行类型匹配</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">setTempClassLoader</span><span class="o">(</span><span class="k">new</span> <span class="nc">ContextTypeMatchClassLoader</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanClassLoader</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="c1">// Register default environment beans.</span>
    <span class="c1">//如果bean工厂中不包含 environment的bean 则向bean工厂注册它</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">containsLocalBean</span><span class="o">(</span><span class="no">ENVIRONMENT_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="no">ENVIRONMENT_BEAN_NAME</span><span class="o">,</span> <span class="n">getEnvironment</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">//如果bean工厂中不包含 systemProperties的bean  直接向bean工厂注册它</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">containsLocalBean</span><span class="o">(</span><span class="no">SYSTEM_PROPERTIES_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="no">SYSTEM_PROPERTIES_BEAN_NAME</span><span class="o">,</span> <span class="n">getEnvironment</span><span class="o">().</span><span class="na">getSystemProperties</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">//如果bean工厂中不包含systemEnvironment的bean  直接向bean工厂注册它</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">containsLocalBean</span><span class="o">(</span><span class="no">SYSTEM_ENVIRONMENT_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="no">SYSTEM_ENVIRONMENT_BEAN_NAME</span><span class="o">,</span> <span class="n">getEnvironment</span><span class="o">().</span><span class="na">getSystemEnvironment</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见第三步的作用就是设置bean工厂的通用功能.例如设置类加载器、设置 <strong>BeanExpressionResolver</strong> 用来解析 <strong>#{}</strong> 属性、设置 <strong>PropertyEditorRegistrar</strong> 来自定义解析 <strong>application.properties</strong> 中的值.<br />
添加 <strong>ApplicationContextAwareProcessor</strong> 后置处理器在bean初始化前设置实现所有相关Aware接口的属性同时要将这些Aware接口忽略防止进行自动装配, 既然有忽略那也就有注册,注册 <strong>BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</strong> 为已解析类型,当遇到这几种类型直接使用即可.<br />
  然后再检查bean工厂中是否有 <strong>LoadTimeWeaver</strong> 的bean,有则注册 <strong>LoadTimeWeaverAwareProcessor</strong> 后置处理器用来将默认的 <strong>LoadTimeWeaver</strong> 传递给实现了 <strong>LoadTimeWeaverAware</strong> 接口的bean并设置临时类加载器以进行类型匹配.<br />
  最后就是检测 <strong>environment、systemProperties、systemEnvironment</strong> 这三个bean是否存在,存在则进行注册.<br />
  以上步骤执行完后, 一个bean工厂也就可以准备使用了.</p>

<p>4.第四步postProcessBeanFactory相关源码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext#postProcessBeanFactory</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">postProcessBeanFactory</span><span class="o">(</span><span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//首先继续调用父类的postProcessBeanFactory方法继续处理bean工厂</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">postProcessBeanFactory</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">);</span>
    <span class="c1">//如果指定扫描路径则进行扫描 默认为null</span>
    <span class="k">if</span> <span class="o">(!</span><span class="nc">ObjectUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">basePackages</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">scanner</span><span class="o">.</span><span class="na">scan</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">basePackages</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//如果注解类不为空则进行注册该bean  默认为空</span>
    <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">annotatedClasses</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">reader</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="nc">ClassUtils</span><span class="o">.</span><span class="na">toClassArray</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">annotatedClasses</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见直接调用了父类的postProcessBeanFactory方法, AnnotationConfigServletWebServerApplicationContext的父类为ServletWebServerApplicationContext,那么继续看父类的代码:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">postProcessBeanFactory</span><span class="o">(</span><span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//注册WebApplicationContextServletContextAwareProcessor后置处理器</span>
    <span class="c1">//主要就是用来设置bean初始化之前设置servletContext和servletConfig</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">addBeanPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">WebApplicationContextServletContextAwareProcessor</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
    <span class="c1">//忽略ServletContextAware的自动装配功能</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">ignoreDependencyInterface</span><span class="o">(</span><span class="nc">ServletContextAware</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="c1">//注册web应用范围 默认注册request和session</span>
    <span class="n">registerWebApplicationScopes</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">registerWebApplicationScopes</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">//定义ExistingWebApplicationScopes 用来存储已经注册的范围</span>
    <span class="nc">ExistingWebApplicationScopes</span> <span class="n">existingScopes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ExistingWebApplicationScopes</span><span class="o">(</span><span class="n">getBeanFactory</span><span class="o">());</span>
    <span class="c1">//注册默认的request、session范围</span>
    <span class="nc">WebApplicationContextUtils</span><span class="o">.</span><span class="na">registerWebApplicationScopes</span><span class="o">(</span><span class="n">getBeanFactory</span><span class="o">());</span>
    <span class="c1">//将注册的范围保存到ExistingWebApplicationScopes</span>
    <span class="n">existingScopes</span><span class="o">.</span><span class="na">restore</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/**
 * Register web-specific scopes ("request", "session", "globalSession", "application")
 * with the given BeanFactory, as used by the WebApplicationContext.
 * 使用WebApplicationContext使用的给定bean工厂注册特定于web的范围"request", "session", "globalSession", "application" 
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">registerWebApplicationScopes</span><span class="o">(</span><span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">,</span>
        <span class="nd">@Nullable</span> <span class="nc">ServletContext</span> <span class="n">sc</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//注册request、session</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerScope</span><span class="o">(</span><span class="nc">WebApplicationContext</span><span class="o">.</span><span class="na">SCOPE_REQUEST</span><span class="o">,</span> <span class="k">new</span> <span class="nc">RequestScope</span><span class="o">());</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerScope</span><span class="o">(</span><span class="nc">WebApplicationContext</span><span class="o">.</span><span class="na">SCOPE_SESSION</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SessionScope</span><span class="o">());</span>
    <span class="c1">//如果ServletContext不为空 则注册 globalSession、application</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sc</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ServletContextScope</span> <span class="n">appScope</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServletContextScope</span><span class="o">(</span><span class="n">sc</span><span class="o">);</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerScope</span><span class="o">(</span><span class="nc">WebApplicationContext</span><span class="o">.</span><span class="na">SCOPE_APPLICATION</span><span class="o">,</span> <span class="n">appScope</span><span class="o">);</span>
        <span class="c1">// Register as ServletContext attribute, for ContextCleanupListener to detect it.</span>
        <span class="n">sc</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="nc">ServletContextScope</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">appScope</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//使用相应的自动装配值注册一个特殊的依赖类型,后面若需要自动装配该类型直接使用接口</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerResolvableDependency</span><span class="o">(</span><span class="nc">ServletRequest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">new</span> <span class="nc">RequestObjectFactory</span><span class="o">());</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerResolvableDependency</span><span class="o">(</span><span class="nc">ServletResponse</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ResponseObjectFactory</span><span class="o">());</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerResolvableDependency</span><span class="o">(</span><span class="nc">HttpSession</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SessionObjectFactory</span><span class="o">());</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerResolvableDependency</span><span class="o">(</span><span class="nc">WebRequest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">new</span> <span class="nc">WebRequestObjectFactory</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">jsfPresent</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">FacesDependencyRegistrar</span><span class="o">.</span><span class="na">registerFacesDependencies</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见父类ServletWebServerApplicationContext的作用就是注册一个 <strong>WebApplicationContextServletContextAwareProcessor</strong> 后置处理器来在bean初始化之前设置 <strong>ServletContext和ServletConfig</strong> ,然后就是注册web指定的范围 <strong>request、session</strong> .
由此可见第四步主要就是后置处理Bean工厂,具体实现在ServletWebServerApplicationContext中,结论如上.</p>

<p>5.第五步invokeBeanFactoryPostProcessors,非常重要,个人认为核心逻辑都在这里,我们好好看看,相关源码如下:</p>

<p>  我们先抛出大体的结论,通过 <strong>invokeBeanFactoryPostProcessors</strong> 方法处理,此方法中处理 <strong>BeanDefinitionRegistryPostProcessor</strong> 和 <strong>BeanFactoryPostProcessor</strong> 两个后置处理器,<br />
其中 <strong>BeanDefinitionRegistryPostProcessor</strong> 中有一个 <strong>ConfigurationClassPostProcessor</strong> ,它的作用就是解析所有的 <strong>@Configuration</strong> 修饰的类,也就是主函数,并在解析的过程中通过 <strong>@SpringBootApplication及其元注解</strong> 解析项目中指定包下的配置类.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Instantiate and invoke all registered BeanFactoryPostProcessor beans,
 * respecting explicit order if given.
 * 实例化且调用所有注册的bean工厂后置处理器bean,如果给定顺序的按显示顺序来
 * &lt;p&gt;Must be called before singleton instantiation.
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//真正调用bean工厂后置处理器的地方 解析所有的BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor并按照PriorityOrdered、Ordered和默认 三种顺序执行</span>
    <span class="nc">PostProcessorRegistrationDelegate</span><span class="o">.</span><span class="na">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">,</span> <span class="n">getBeanFactoryPostProcessors</span><span class="o">());</span>

    <span class="c1">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span>
    <span class="c1">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span>
    <span class="c1">//再次检测扫描是否包含LoadTimeWeaver  例如有可能通过ConfigurationClassPostProcessor类解析@Bean注解 注册 LoadTimeWeaver的bean</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getTempClassLoader</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">containsBean</span><span class="o">(</span><span class="no">LOAD_TIME_WEAVER_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">addBeanPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">LoadTimeWeaverAwareProcessor</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">));</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">setTempClassLoader</span><span class="o">(</span><span class="k">new</span> <span class="nc">ContextTypeMatchClassLoader</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanClassLoader</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//解析所有的BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor并按照PriorityOrdered、Ordered和默认 三种顺序执行</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">invokeBeanFactoryPostProcessors</span><span class="o">(</span>
        <span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanFactoryPostProcessor</span><span class="o">&gt;</span> <span class="n">beanFactoryPostProcessors</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//入参beanFactoryPostProcessors有以下三个:</span>
    <span class="c1">//1.org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor</span>
    <span class="c1">//  实现BeanDefinitionRegistryPostProcessor,通过postProcessBeanDefinitionRegistry回调接口注册internalCachingMetadataReaderFactory用来缓存类的元数据,并将该属性metadataReaderFactory 添加到internalConfigurationAnnotationProcessor中</span>
    <span class="c1">//2.org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor</span>
    <span class="c1">//  实现BeanDefinitionRegistryPostProcessor,通过postProcessBeanDefinitionRegistry回调接口来报告警告 不是特别重要</span>
    <span class="c1">//3.org.springframework.boot.context.config.ConfigFileApplicationListener$PropertySourceOrderingPostProcessor</span>
    <span class="c1">//  实现BeanFactoryPostProcessor,通过postProcessBeanFactory来找到environment中的defaultProperties,并将其添加到属性源末尾  通常defaultProperties为null 所以无需处理 </span>

    <span class="c1">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span>
    <span class="c1">//如果有的话首先调用BeanDefinitionRegistryPostProcessors  它的作用是在BeanFactoryPostProcessor生效前注册进一步的bean定义</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">processedBeans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="c1">//BeanDefinitionRegistry是BeanFactoryPostProcessor的子类,所以我们肯定要先处理BeanDefinitionRegistry</span>
    <span class="c1">//前置处理逻辑</span>
    <span class="c1">//判断当前bean工厂是否属于BeanDefinitionRegistry  不属于直接调用注册在上下文中的BeanFactoryPostProcessor 否则继续处理</span>
    <span class="c1">//定义两个regularPostProcessors和registryProcessors分别存放两中后置处理器 肯定是要先执行子类BeanDefinitionRegistryPostProcessor</span>
    <span class="c1">//遍历上下文中的后置处理器 遇到BeanDefinitionRegistryPostProcessor直接执行postProcessBeanDefinitionRegistry回调并将其添加到registryProcessors集合中</span>
    <span class="c1">//                      遇到BeanFactoryPostProcessor则直接添加到regularPostProcessors集合中</span>
    <span class="c1">//接下来就是处理BeanDefinitionRegistryPostProcessor的正文了:</span>
    <span class="c1">//1. 首先从bean工厂已注册的bean定义中找到实现BeanDefinitionRegistryPostProcessor的bean  </span>
    <span class="c1">//   目前只有一个就是ConfigurationClassPostProcessor, 我们再仔细想想这个是不是很眼熟,它又是在何时注册为bean定义的, </span>
    <span class="c1">//   前面我们其实介绍过就是在创建AnnotationConfigServletWebServerApplicationContext上下文构造时的AnnotatedBeanDefinitionReader中的AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)方法,它会注册ConfigurationClassPostProcessor的bean定义到上下文中</span>
    <span class="c1">//2. 既然找到了ConfigurationClassPostProcessor,判断它是否实现了PriorityOrdered,实现了的话则通过getBean方法实例化该bean,并添加到currentRegistryProcessors集合中 getBean方法也是Spring中非常重要的方法,后面我们再介绍</span>
    <span class="c1">//3. 实例化完指定bean后将currentRegistryProcessors进行排序并将已经集合中的所有元素添加到registryProcessors集合中</span>
    <span class="c1">//4. 最重要的一步 执行所有的BeanDefinitionRegistryPostProcessor后置处理器的postProcessBeanDefinitionRegistry, 这里主要是执行ConfigurationClassPostProcessor的回调, 它的主要作用就是解析主函数 逻辑是非常重要的 后面我们慢慢分析</span>
    <span class="c1">//5. 执行完之后将currentRegistryProcessors清空</span>
    <span class="c1">//6. 再次按照步骤1-5的顺序 将所有BeanDefinitionRegistryPostProcessor的bean按照Ordered和默认顺序进行处理即可  </span>
    <span class="c1">//7. 最后依次执行registryProcessors和regularPostProcessors中的所有后置处理器的postProcessBeanFactory方法</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span> <span class="k">instanceof</span> <span class="nc">BeanDefinitionRegistry</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span> <span class="o">=</span> <span class="o">(</span><span class="nc">BeanDefinitionRegistry</span><span class="o">)</span> <span class="n">beanFactory</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanFactoryPostProcessor</span><span class="o">&gt;</span> <span class="n">regularPostProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">&gt;</span> <span class="n">registryProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">//预先执行上下文实例中注册的后置处理器</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">BeanFactoryPostProcessor</span> <span class="n">postProcessor</span> <span class="o">:</span> <span class="n">beanFactoryPostProcessors</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">postProcessor</span> <span class="k">instanceof</span> <span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">BeanDefinitionRegistryPostProcessor</span> <span class="n">registryProcessor</span> <span class="o">=</span>
                        <span class="o">(</span><span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">)</span> <span class="n">postProcessor</span><span class="o">;</span>
                <span class="n">registryProcessor</span><span class="o">.</span><span class="na">postProcessBeanDefinitionRegistry</span><span class="o">(</span><span class="n">registry</span><span class="o">);</span>
                <span class="n">registryProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registryProcessor</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">regularPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">postProcessor</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
        <span class="c1">// uninitialized to let the bean factory post-processors apply to them!</span>
        <span class="c1">// Separate between BeanDefinitionRegistryPostProcessors that implement</span>
        <span class="c1">// PriorityOrdered, Ordered, and the rest.</span>
        <span class="c1">//这里不实例化化工厂bean: 我们需要让所有常规bean未初始化以便让bean工厂后置处理器应用他们</span>
        <span class="c1">//将实现PriorityOrdered、Ordered和其余部分的BeanDefinitionRegistryPostProcessors分开</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">&gt;</span> <span class="n">currentRegistryProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span>
        <span class="c1">//首先调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessors</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">postProcessorNames</span> <span class="o">=</span>
                <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanNamesForType</span><span class="o">(</span><span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">ppName</span> <span class="o">:</span> <span class="n">postProcessorNames</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">isTypeMatch</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">PriorityOrdered</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">currentRegistryProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
                <span class="n">processedBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ppName</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">sortPostProcessors</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
        <span class="n">registryProcessors</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">);</span>
        <span class="n">invokeBeanDefinitionRegistryPostProcessors</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">,</span> <span class="n">registry</span><span class="o">);</span>
        <span class="n">currentRegistryProcessors</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>

        <span class="c1">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span>
        <span class="c1">//接着调用实现了Ordered接口的BeanDefinitionRegistryPostProcessors</span>
        <span class="n">postProcessorNames</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanNamesForType</span><span class="o">(</span><span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">ppName</span> <span class="o">:</span> <span class="n">postProcessorNames</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">processedBeans</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">ppName</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">isTypeMatch</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">Ordered</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">currentRegistryProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
                <span class="n">processedBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ppName</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">sortPostProcessors</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
        <span class="n">registryProcessors</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">);</span>
        <span class="n">invokeBeanDefinitionRegistryPostProcessors</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">,</span> <span class="n">registry</span><span class="o">);</span>
        <span class="n">currentRegistryProcessors</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>

        <span class="c1">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span>
        <span class="c1">//最后调用剩下的BeanDefinitionRegistryPostProcessors直到没有</span>
        <span class="kt">boolean</span> <span class="n">reiterate</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">reiterate</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">reiterate</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">postProcessorNames</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanNamesForType</span><span class="o">(</span><span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">ppName</span> <span class="o">:</span> <span class="n">postProcessorNames</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">processedBeans</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">ppName</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">currentRegistryProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
                    <span class="n">processedBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ppName</span><span class="o">);</span>
                    <span class="n">reiterate</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">sortPostProcessors</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
            <span class="n">registryProcessors</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">);</span>
            <span class="n">invokeBeanDefinitionRegistryPostProcessors</span><span class="o">(</span><span class="n">currentRegistryProcessors</span><span class="o">,</span> <span class="n">registry</span><span class="o">);</span>
            <span class="n">currentRegistryProcessors</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span>
        <span class="c1">//调用目前为止处理的所有后置处理器的 postProcessBeanFactory方法</span>
        <span class="n">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="n">registryProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
        <span class="n">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="n">regularPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// Invoke factory processors registered with the context instance.</span>
        <span class="c1">// 调用通过上下文实例注册的工厂处理器</span>
        <span class="n">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="n">beanFactoryPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
    <span class="c1">// uninitialized to let the bean factory post-processors apply to them!</span>
    <span class="c1">//这里不实例化工厂bean:我们需要让所有常规bean不实例化以便让bean工厂后置处理器应用他们</span>
    
    <span class="c1">//上下文中主要有这6个后置处理器:</span>
    <span class="c1">//1. org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span>
    <span class="c1">//   处理配置类 第一阶段以及处理过 无需再处理</span>
    <span class="c1">//2. org.springframework.context.event.internalEventListenerProcessor</span>
    <span class="c1">//   主要作用是设置实现EventListenerFactory接口的bean</span>
    <span class="c1">//3. propertySourcesPlaceholderConfigurer</span>
    <span class="c1">//   它的作用就是解析 ${} 占位符的值和@Value 在Environment和PropertySources中的值</span>
    <span class="c1">//4. org.springframework.boot.context.properties.ConfigurationPropertiesBeanDefinitionValidator</span>
    <span class="c1">//   主要作用是验证常规bean定义没有创建 ConstructorBinding的bean</span>
    <span class="c1">//5. preserveErrorControllerTargetClassPostProcessor</span>
    <span class="c1">//   创建ErrorController相关的bean定义并设置preserveTargetClass属性为true</span>
    <span class="c1">//6. emBeanDefinitionRegistrarPostProcessor</span>
    <span class="c1">//   主要是处理jpa相关属性  无需关心</span>

    <span class="c1">//这里就是处理BeanFactoryPostProcessor的逻辑,大致逻辑与处理BeanDefinitionRegistryPostProcessor类似</span>
    <span class="c1">//1. 首先从bean工厂的定义中找到实现BeanFactoryPostProcessor接口的所有bean定义</span>
    <span class="c1">//2. 接着定义三个集合 priorityOrderedPostProcessors、orderedPostProcessorNames、nonOrderedPostProcessorNames 分别存放实现了 PriorityOrdered、Ordered、默认顺序的bean</span>
    <span class="c1">//   这里需要注意 只有实现了PriorityOrdered的bean才会立即实例化</span>
    <span class="c1">//3. 首先还是先调用实现了PriorityOrdered接口的后置处理器的postProcessBeanFactory接口</span>
    <span class="c1">//4. 接着先获取所有实现了Ordered接口的后置处理器的bean,接着调用postProcessBeanFactory接口</span>
    <span class="c1">//5. 按步骤4处理剩下的后置处理器</span>
    <span class="c1">//6. 最后清空bean工厂中的元数据缓存</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">postProcessorNames</span> <span class="o">=</span>
            <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanNamesForType</span><span class="o">(</span><span class="nc">BeanFactoryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

    <span class="c1">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span>
    <span class="c1">// Ordered, and the rest.</span>
    <span class="c1">//将实现PriorityOrdered、Ordered和剩余部分的BeanFactoryPostProcessor分开</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanFactoryPostProcessor</span><span class="o">&gt;</span> <span class="n">priorityOrderedPostProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">orderedPostProcessorNames</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nonOrderedPostProcessorNames</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">ppName</span> <span class="o">:</span> <span class="n">postProcessorNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">processedBeans</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">ppName</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// skip - already processed in first phase above</span>
            <span class="c1">//第一阶段处理过的直接跳过</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">isTypeMatch</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">PriorityOrdered</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">priorityOrderedPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">BeanFactoryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">isTypeMatch</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">Ordered</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">orderedPostProcessorNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ppName</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">nonOrderedPostProcessorNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ppName</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span>
    <span class="c1">//首先调用实现了PriorityOrdered接口的BeanFactoryPostProcessors</span>
    <span class="n">sortPostProcessors</span><span class="o">(</span><span class="n">priorityOrderedPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
    <span class="n">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="n">priorityOrderedPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>

    <span class="c1">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span>
    <span class="c1">//接着 调用实现了Ordered接口的BeanFactoryProcessors</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanFactoryPostProcessor</span><span class="o">&gt;</span> <span class="n">orderedPostProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">orderedPostProcessorNames</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">postProcessorName</span> <span class="o">:</span> <span class="n">orderedPostProcessorNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">orderedPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">postProcessorName</span><span class="o">,</span> <span class="nc">BeanFactoryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="n">sortPostProcessors</span><span class="o">(</span><span class="n">orderedPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
    <span class="n">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="n">orderedPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>

    <span class="c1">// Finally, invoke all other BeanFactoryPostProcessors.</span>
    <span class="c1">//最后 调用所有剩下的BeanFactoryPostProcessor</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanFactoryPostProcessor</span><span class="o">&gt;</span> <span class="n">nonOrderedPostProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">nonOrderedPostProcessorNames</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">postProcessorName</span> <span class="o">:</span> <span class="n">nonOrderedPostProcessorNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nonOrderedPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">postProcessorName</span><span class="o">,</span> <span class="nc">BeanFactoryPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="n">invokeBeanFactoryPostProcessors</span><span class="o">(</span><span class="n">nonOrderedPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>

    <span class="c1">// Clear cached merged bean definitions since the post-processors might have</span>
    <span class="c1">// modified the original metadata, e.g. replacing placeholders in values...</span>
    <span class="c1">//清除可能由于后置处理器修改原始元数据的缓存的合并bean定义</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">clearMetadataCache</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>我们就 <strong>invokeBeanFactoryPostProcessors</strong> 先总结一下:<br />
  看方法名,就是调用实现 <strong>BeanFactoryPostProcessor</strong> 接口的所有后置处理器,先看一下我们这里需要处理的后置处理器的类图,有些内部类不好合并就不展示了:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/BeanFactoryPostProcessor.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="BeanFactoryPostProcessor类图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/BeanFactoryPostProcessor.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">BeanFactoryPostProcessor类图</div>
    </a>
</center>
<p>  可见我们这里除了处理实现了BeanFactoryPostProcessor的后置处理器,还处理了实现BeanDefinitionRegistryPostProcessor的后置处理器,其实BeanDefinitionRegistryPostProcessor也是实现了BeanFactoryPostProcessor,从类图中可以看出.<br />
  那我们这里的逻辑就很清晰了,首先处理实现BeanDefinitionRegistryPostProcessor的后置处理器,通过postProcessBeanDefinitionRegistry回调方法,然后是处理实现了BeanFactoryPostProcessor的后置处理器,通过postProcessBeanFactory回调方法.每个后置处理器都有自己的逻辑,需具体分析.</p>

<blockquote>
  <p>invokeBeanFactoryPostProcessors小结</p>
</blockquote>

<p>前置处理逻辑:<br />
  判断当前bean工厂是否属于BeanDefinitionRegistry,不属于直接调用注册在上下文中的BeanFactoryPostProcessor,否则继续处理.<br />
  定义两个regularPostProcessors和registryProcessors分别存放两种后置处理器,肯定是要先执行子类BeanDefinitionRegistryPostProcessor
遍历上下文中的后置处理器,遇到BeanDefinitionRegistryPostProcessor直接执行postProcessBeanDefinitionRegistry回调并将其添加到registryProcessors集合中,遇到BeanFactoryPostProcessor则直接添加到regularPostProcessors集合中.  <br />
第一阶段处理BeanDefinitionRegistryPostProcessor:</p>
<ol>
  <li>首先从bean工厂已注册的bean定义中找到实现BeanDefinitionRegistryPostProcessor的bean<br />
目前只有一个就是ConfigurationClassPostProcessor, 我们再仔细想想这个是不是很眼熟,它又是在何时注册为bean定义的, 
前面我们其实介绍过就是在创建AnnotationConfigServletWebServerApplicationContext上下文构造时的AnnotatedBeanDefinitionReader中的AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)方法,它会注册ConfigurationClassPostProcessor的bean定义到上下文中</li>
  <li>既然找到了ConfigurationClassPostProcessor,判断它是否实现了PriorityOrdered,实现了的话则通过getBean方法实例化该bean,并添加到currentRegistryProcessors集合中 getBean方法也是Spring中非常重要的方法,后面我们再介绍</li>
  <li>实例化完指定bean后将currentRegistryProcessors进行排序并将已经集合中的所有元素添加到registryProcessors集合中</li>
  <li>最重要的一步 执行所有的BeanDefinitionRegistryPostProcessor后置处理器的postProcessBeanDefinitionRegistry, 这里主要是执行ConfigurationClassPostProcessor的回调, 它的主要作用就是解析主函数 逻辑是非常重要的 后面我们慢慢分析</li>
  <li>执行完之后将currentRegistryProcessors清空</li>
  <li>再次按照步骤1-5的顺序 将所有BeanDefinitionRegistryPostProcessor的bean按照Ordered和默认顺序进行处理即可</li>
  <li>最后依次执行registryProcessors和regularPostProcessors中的所有后置处理器的postProcessBeanFactory方法</li>
</ol>

<p>第二阶段处理BeanFactoryPostProcessor,大致逻辑与处理BeanDefinitionRegistryPostProcessor类似:</p>
<ol>
  <li>首先从bean工厂的定义中找到实现BeanFactoryPostProcessor接口的所有bean定义</li>
  <li>接着定义三个集合 priorityOrderedPostProcessors、orderedPostProcessorNames、nonOrderedPostProcessorNames 分别存放实现了 PriorityOrdered、Ordered、默认顺序的bean
这里需要注意 只有实现了PriorityOrdered的bean才会立即实例化</li>
  <li>首先还是先调用实现了PriorityOrdered接口的后置处理器的postProcessBeanFactory接口</li>
  <li>接着先获取所有实现了Ordered接口的后置处理器的bean,接着调用postProcessBeanFactory接口</li>
  <li>按步骤4处理剩下的后置处理器</li>
  <li>最后清空bean工厂中的元数据缓存</li>
</ol>

<p>  下面我们来着重看下最重要的后置处理器 <strong>ConfigurationClassPostProcessor</strong> 它的作用是在启动时通过 <strong>postProcessBeanDefinitionRegistry</strong> 回调处理@Configuration修饰的类.
<strong>postProcessBeanDefinitionRegistry</strong> 回调源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Derive further bean definitions from the configuration classes in the registry.
 * 从在注册表中的配置类派生出进一步的bean定义
 */</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postProcessBeanDefinitionRegistry</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//获取该注册表的哈希值 判断是否已经处理过 若处理过直接抛出异常 未处理则加入已注册集合registriesPostProcessed</span>
    <span class="kt">int</span> <span class="n">registryId</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">registry</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">registriesPostProcessed</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">registryId</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span>
                <span class="s">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> <span class="o">+</span> <span class="n">registry</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">factoriesPostProcessed</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">registryId</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span>
                <span class="s">"postProcessBeanFactory already called on this post-processor against "</span> <span class="o">+</span> <span class="n">registry</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">registriesPostProcessed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registryId</span><span class="o">);</span>
    <span class="c1">//处理注册表中所有被@Configuration修饰的bean定义</span>
    <span class="n">processConfigBeanDefinitions</span><span class="o">(</span><span class="n">registry</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>可见回调中其实就做了两件事:</p>
<ol>
  <li>获取该注册表的hash值并判断是否处理过,若已处理则直接抛出异常,否则将此值添加到已注册结合registriesPostProcessed</li>
  <li>解析注册表中所有被@Configuration修饰的bean定义,这里就是配置类的最主要解析逻辑,解析见 <strong>SpringBoot启动源码解析(七)</strong></li>
</ol>

<p>6.第六步创建拦截bean创建的bean处理器,相关源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Instantiate and register all BeanPostProcessor beans,
 * respecting explicit order if given.
 * 实例化和注册所有的BeanPostProcessor的bean,如果给出,尊重明确的规则
 * &lt;p&gt;Must be called before any instantiation of application beans.
 * 必须在应用bean实例化之前被调用
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">registerBeanPostProcessors</span><span class="o">(</span><span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">PostProcessorRegistrationDelegate</span><span class="o">.</span><span class="na">registerBeanPostProcessors</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">//注册所有的BeanPostProcessor</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">registerBeanPostProcessors</span><span class="o">(</span>
        <span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">,</span> <span class="nc">AbstractApplicationContext</span> <span class="n">applicationContext</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">//1.获取所有的BeanPostProcessor的实现类</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">postProcessorNames</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanNamesForType</span><span class="o">(</span><span class="nc">BeanPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

    <span class="c1">// Register BeanPostProcessorChecker that logs an info message when</span>
    <span class="c1">// a bean is created during BeanPostProcessor instantiation, i.e. when</span>
    <span class="c1">// a bean is not eligible for getting processed by all BeanPostProcessors.</span>
    <span class="c1">//2.注册BeanPostProcessorChecker,当bean在BeanPostProcessor实例化期间创建bean时记录信息</span>
    <span class="kt">int</span> <span class="n">beanProcessorTargetCount</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanPostProcessorCount</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">postProcessorNames</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">addBeanPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanPostProcessorChecker</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">,</span> <span class="n">beanProcessorTargetCount</span><span class="o">));</span>

    <span class="c1">// Separate between BeanPostProcessors that implement PriorityOrdered,</span>
    <span class="c1">// Ordered, and the rest.</span>
    <span class="c1">//3. 分开实现了PriorityOrdered、OrderedBeanPostProcessor和剩下的BeanPostProcessor</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanPostProcessor</span><span class="o">&gt;</span> <span class="n">priorityOrderedPostProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanPostProcessor</span><span class="o">&gt;</span> <span class="n">internalPostProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">orderedPostProcessorNames</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nonOrderedPostProcessorNames</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//找出实现了PriorityOrdered、Ordered和剩下的接口 同时还有保存既实现了PriorityOrdered又属于MergedBeanDefinitionPostProcessor的类</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">ppName</span> <span class="o">:</span> <span class="n">postProcessorNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">isTypeMatch</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">PriorityOrdered</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">BeanPostProcessor</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">BeanPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">priorityOrderedPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pp</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="k">instanceof</span> <span class="nc">MergedBeanDefinitionPostProcessor</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">internalPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pp</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">isTypeMatch</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">Ordered</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">orderedPostProcessorNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ppName</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">nonOrderedPostProcessorNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ppName</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// First, register the BeanPostProcessors that implement PriorityOrdered.</span>
    <span class="c1">//4.首先注册实现了PriorityOrdered的BeanPostProcessor</span>
    <span class="n">sortPostProcessors</span><span class="o">(</span><span class="n">priorityOrderedPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
    <span class="n">registerBeanPostProcessors</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">,</span> <span class="n">priorityOrderedPostProcessors</span><span class="o">);</span>

    <span class="c1">// Next, register the BeanPostProcessors that implement Ordered.</span>
    <span class="c1">//5.接下来 注册实现了ordered的BeanPostProcessor 同时记录属于MergedBeanDefinitionPostProcessor的类</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanPostProcessor</span><span class="o">&gt;</span> <span class="n">orderedPostProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">orderedPostProcessorNames</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">ppName</span> <span class="o">:</span> <span class="n">orderedPostProcessorNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BeanPostProcessor</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">BeanPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">orderedPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pp</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="k">instanceof</span> <span class="nc">MergedBeanDefinitionPostProcessor</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">internalPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pp</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">sortPostProcessors</span><span class="o">(</span><span class="n">orderedPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
    <span class="n">registerBeanPostProcessors</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">,</span> <span class="n">orderedPostProcessors</span><span class="o">);</span>

    <span class="c1">// Now, register all regular BeanPostProcessors.</span>
    <span class="c1">//6.最后注册所有常规的BeanPostProcessor 同时记录属于MergedBeanDefinitionPostProcessor的类</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanPostProcessor</span><span class="o">&gt;</span> <span class="n">nonOrderedPostProcessors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">nonOrderedPostProcessorNames</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">ppName</span> <span class="o">:</span> <span class="n">nonOrderedPostProcessorNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BeanPostProcessor</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">ppName</span><span class="o">,</span> <span class="nc">BeanPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">nonOrderedPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pp</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="k">instanceof</span> <span class="nc">MergedBeanDefinitionPostProcessor</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">internalPostProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pp</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">registerBeanPostProcessors</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">,</span> <span class="n">nonOrderedPostProcessors</span><span class="o">);</span>

    <span class="c1">// Finally, re-register all internal BeanPostProcessors.</span>
    <span class="c1">//7.最后重新注册所有内部的BeanPostProcessor 相当于后置处理器会移动到处理链的末尾</span>
    <span class="n">sortPostProcessors</span><span class="o">(</span><span class="n">internalPostProcessors</span><span class="o">,</span> <span class="n">beanFactory</span><span class="o">);</span>
    <span class="n">registerBeanPostProcessors</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">,</span> <span class="n">internalPostProcessors</span><span class="o">);</span>

    <span class="c1">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span>
    <span class="c1">// moving it to the end of the processor chain (for picking up proxies etc).</span>
    <span class="c1">//8.重新注册后置处理器以将内部bean检测为ApplicationListeners,将其移动到处理器链的末尾</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">addBeanPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">ApplicationListenerDetector</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  第六步注册bean后置处理器同第五步基本类似,总结如下:<br />
    6.1 首先找到bean工厂中所有BeanPostProcessor的实现类<br />
    6.2 首先统计原来bean工厂已注册的bean后置处理器的数量加上6.1找到的实现类数量并加上1,这个1对应BeanPostProcessorChecker,紧跟着就注册它,它的作用是当bean在BeanPostProcessor实例化期间创建bean时记录信息<br />
    6.3 根据实现了PriorityOrdered、Ordered和默认顺序的BeanPostProcessor进行分类,并同时找出既实现了MergedBeanDefinitionPostProcessor和PriorityOrdered的BeanPostProcessor<br />
    6.4 首先注册实现了PriorityOrdered的BeanPostProcessor<br />
    6.5 接下来注册实现了ordered的BeanPostProcessor,同时记录属于MergedBeanDefinitionPostProcessor的类<br />
    6.6 然后注册所有常规的BeanPostProcessor 同时记录属于MergedBeanDefinitionPostProcessor的类<br />
    6.7 后面重新注册所有实现了MergedBeanDefinitionPostProcessor的后置处理器,作用是这些后置处理器会移动到处理链的末尾<br />
    6.8 最后重新注册后置处理器以将内部bean检测为ApplicationListeners,将其移动到处理器链的末尾</p>

<p>7.为上下文初始化消息源,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">MESSAGE_SOURCE_BEAN_NAME</span> <span class="o">=</span> <span class="s">"messageSource"</span><span class="o">;</span>
<span class="cm">/**
 * Initialize the MessageSource.
 * 初始化消息源
 * Use parent's if none defined in this context.
 * 如果在上下文中没有定义则使用父类的
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">initMessageSource</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="n">getBeanFactory</span><span class="o">();</span>
    <span class="c1">//判断当前bean工厂中是否包含messageSource的bean</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">containsLocalBean</span><span class="o">(</span><span class="no">MESSAGE_SOURCE_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">MESSAGE_SOURCE_BEAN_NAME</span><span class="o">,</span> <span class="nc">MessageSource</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="c1">// Make MessageSource aware of parent MessageSource.</span>
        <span class="c1">// 将父消息源设置到当前消息源中</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">messageSource</span> <span class="k">instanceof</span> <span class="nc">HierarchicalMessageSource</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">HierarchicalMessageSource</span> <span class="n">hms</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HierarchicalMessageSource</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">messageSource</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">hms</span><span class="o">.</span><span class="na">getParentMessageSource</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Only set parent context as parent MessageSource if no parent MessageSource</span>
                <span class="c1">// registered already.</span>
                <span class="n">hms</span><span class="o">.</span><span class="na">setParentMessageSource</span><span class="o">(</span><span class="n">getInternalParentMessageSource</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Using MessageSource ["</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">//不存在则创建默认消息源并注册到bean工厂中</span>
        <span class="c1">// Use empty MessageSource to be able to accept getMessage calls.</span>
        <span class="c1">//使用空消息源来接受getMessage的调用</span>
        <span class="nc">DelegatingMessageSource</span> <span class="n">dms</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DelegatingMessageSource</span><span class="o">();</span>
        <span class="n">dms</span><span class="o">.</span><span class="na">setParentMessageSource</span><span class="o">(</span><span class="n">getInternalParentMessageSource</span><span class="o">());</span>
        <span class="k">this</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">dms</span><span class="o">;</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="no">MESSAGE_SOURCE_BEAN_NAME</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">messageSource</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"No '"</span> <span class="o">+</span> <span class="no">MESSAGE_SOURCE_BEAN_NAME</span> <span class="o">+</span> <span class="s">"' bean, using ["</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  代码比较清晰,查看bean工厂中是否包含messageSource的bean,存在则继续设置父类的消息源,不存在则创建默认消息源并注册到bean工厂中</p>

<p>8.为上下文初始化事件广播器,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">APPLICATION_EVENT_MULTICASTER_BEAN_NAME</span> <span class="o">=</span> <span class="s">"applicationEventMulticaster"</span><span class="o">;</span>

<span class="cm">/**
 * Initialize the ApplicationEventMulticaster.
 * 初始化ApplicationEventMulticaster
 * Uses SimpleApplicationEventMulticaster if none defined in the context.
 * 如果在上下文中没有定义则使用SimpleApplicationEventMulticaster
 * @see org.springframework.context.event.SimpleApplicationEventMulticaster
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">initApplicationEventMulticaster</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="n">getBeanFactory</span><span class="o">();</span>
    <span class="c1">//判断bean工厂中是否存在applicationEventMulticaster的bean</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">containsLocalBean</span><span class="o">(</span><span class="no">APPLICATION_EVENT_MULTICASTER_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">//存在直接取出该bean赋值给applicationEventMulticaster</span>
        <span class="k">this</span><span class="o">.</span><span class="na">applicationEventMulticaster</span> <span class="o">=</span>
                <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">APPLICATION_EVENT_MULTICASTER_BEAN_NAME</span><span class="o">,</span> <span class="nc">ApplicationEventMulticaster</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Using ApplicationEventMulticaster ["</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">applicationEventMulticaster</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">//不存在则创建SimpleApplicationEventMulticaster 并注册到bean工厂中</span>
        <span class="k">this</span><span class="o">.</span><span class="na">applicationEventMulticaster</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleApplicationEventMulticaster</span><span class="o">(</span><span class="n">beanFactory</span><span class="o">);</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="no">APPLICATION_EVENT_MULTICASTER_BEAN_NAME</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">applicationEventMulticaster</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"No '"</span> <span class="o">+</span> <span class="no">APPLICATION_EVENT_MULTICASTER_BEAN_NAME</span> <span class="o">+</span> <span class="s">"' bean, using "</span> <span class="o">+</span>
                    <span class="s">"["</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">applicationEventMulticaster</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见逻辑和第七步类似,都是先判断上下文中是否存在applicationEventMulticaster,存在则直接赋值给applicationEventMulticaster,不存在则先进行初始化默认的广播器给applicationEventMulticaster,最后再向bean工厂注册这个广播器.</p>

<p>9.初始化特定上下文子类中的其他特殊bean,主要针对ServletWebServerApplicationContext上下文,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onRefresh</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">//1.调用父类GenericWebApplicationContext的刷新方法 注册themeSource</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onRefresh</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//2.创建tomcat服务</span>
        <span class="n">createWebServer</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ApplicationContextException</span><span class="o">(</span><span class="s">"Unable to start web server"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见此方法主要分为两步,第一步调用父类的刷新方法和第二步创建web服务,即tomcat.<br />
&amp;emsp 我们先来看看第一步主要做的了什么:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onRefresh</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">themeSource</span> <span class="o">=</span> <span class="nc">UiApplicationContextUtils</span><span class="o">.</span><span class="na">initThemeSource</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">THEME_SOURCE_BEAN_NAME</span> <span class="o">=</span> <span class="s">"themeSource"</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ThemeSource</span> <span class="nf">initThemeSource</span><span class="o">(</span><span class="nc">ApplicationContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//上文中是否包含主题来源</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">containsLocalBean</span><span class="o">(</span><span class="no">THEME_SOURCE_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">//包含则获取获取该bean并判断是否需要谁知父类住主题来源并返回</span>
        <span class="nc">ThemeSource</span> <span class="n">themeSource</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">THEME_SOURCE_BEAN_NAME</span><span class="o">,</span> <span class="nc">ThemeSource</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="c1">// Make ThemeSource aware of parent ThemeSource.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getParent</span><span class="o">()</span> <span class="k">instanceof</span> <span class="nc">ThemeSource</span> <span class="o">&amp;&amp;</span> <span class="n">themeSource</span> <span class="k">instanceof</span> <span class="nc">HierarchicalThemeSource</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">HierarchicalThemeSource</span> <span class="n">hts</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HierarchicalThemeSource</span><span class="o">)</span> <span class="n">themeSource</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">hts</span><span class="o">.</span><span class="na">getParentThemeSource</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Only set parent context as parent ThemeSource if no parent ThemeSource</span>
                <span class="c1">// registered already.</span>
                <span class="n">hts</span><span class="o">.</span><span class="na">setParentThemeSource</span><span class="o">((</span><span class="nc">ThemeSource</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getParent</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Using ThemeSource ["</span> <span class="o">+</span> <span class="n">themeSource</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">themeSource</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">//不包含则初始化默认主题来源 并返回</span>
        <span class="c1">// Use default ThemeSource to be able to accept getTheme calls, either</span>
        <span class="c1">// delegating to parent context's default or to local ResourceBundleThemeSource.</span>
        <span class="nc">HierarchicalThemeSource</span> <span class="n">themeSource</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getParent</span><span class="o">()</span> <span class="k">instanceof</span> <span class="nc">ThemeSource</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">themeSource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DelegatingThemeSource</span><span class="o">();</span>
            <span class="n">themeSource</span><span class="o">.</span><span class="na">setParentThemeSource</span><span class="o">((</span><span class="nc">ThemeSource</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getParent</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">themeSource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ResourceBundleThemeSource</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Unable to locate ThemeSource with name '"</span> <span class="o">+</span> <span class="no">THEME_SOURCE_BEAN_NAME</span> <span class="o">+</span>
                    <span class="s">"': using default ["</span> <span class="o">+</span> <span class="n">themeSource</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">themeSource</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  看到这里就很好理解了,就是判断上下文中是否含有themeSource,有则对其父类进行设置,没有则进行初始化并返回.<br />
  我们再看第二步做了什么:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">createWebServer</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">WebServer</span> <span class="n">webServer</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">webServer</span><span class="o">;</span>
    <span class="nc">ServletContext</span> <span class="n">servletContext</span> <span class="o">=</span> <span class="n">getServletContext</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">webServer</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">servletContext</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//通过TomcatServletWebServerFactory创建tomcat服务</span>
        <span class="nc">ServletWebServerFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="n">getWebServerFactory</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">webServer</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getWebServer</span><span class="o">(</span><span class="n">getSelfInitializer</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">servletContext</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">getSelfInitializer</span><span class="o">().</span><span class="na">onStartup</span><span class="o">(</span><span class="n">servletContext</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">ServletException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ApplicationContextException</span><span class="o">(</span><span class="s">"Cannot initialize servlet context"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">initPropertySources</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  这里最重要的就是factory.getWebServer,通过TomcatServletWebServerFactory工厂创建tomcat服务.具体细节待分析,有兴趣可以自己看看.<br />
  第九步主要就是创建themeSource和创建并启动tomcat服务.</p>

<p>10.检查监听器并注册他们,相关源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Add beans that implement ApplicationListener as listeners.
 * 添加实现了ApplicationListener的bean作为监听者
 * Doesn't affect other listeners, which can be added without being beans.
 * 不影响其他监听器,可以不加bean
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">registerListeners</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Register statically specified listeners first.</span>
    <span class="c1">//首先注册静态的指定的监听器</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">ApplicationListener</span><span class="o">&lt;?&gt;</span> <span class="n">listener</span> <span class="o">:</span> <span class="n">getApplicationListeners</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">getApplicationEventMulticaster</span><span class="o">().</span><span class="na">addApplicationListener</span><span class="o">(</span><span class="n">listener</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
    <span class="c1">// uninitialized to let post-processors apply to them!</span>
    <span class="c1">//这里不用初始化工厂bean:我们需要让所有常规的bean不初始化 让 后置处理器应用他们</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">listenerBeanNames</span> <span class="o">=</span> <span class="n">getBeanNamesForType</span><span class="o">(</span><span class="nc">ApplicationListener</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">listenerBeanName</span> <span class="o">:</span> <span class="n">listenerBeanNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">getApplicationEventMulticaster</span><span class="o">().</span><span class="na">addApplicationListenerBean</span><span class="o">(</span><span class="n">listenerBeanName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Publish early application events now that we finally have a multicaster...</span>
    <span class="c1">// 发布 我们最终拥有广播器的早期事件</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ApplicationEvent</span><span class="o">&gt;</span> <span class="n">earlyEventsToProcess</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">earlyApplicationEvents</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">earlyApplicationEvents</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">earlyEventsToProcess</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ApplicationEvent</span> <span class="n">earlyEvent</span> <span class="o">:</span> <span class="n">earlyEventsToProcess</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">getApplicationEventMulticaster</span><span class="o">().</span><span class="na">multicastEvent</span><span class="o">(</span><span class="n">earlyEvent</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  这段代码比较容易理解,首先看下 <strong>getApplicationListeners())</strong> 就是获取在构造函数中获取的所有ApplicationListener子类并将他们加入到事件广播器中.
然后就是获取bean工厂中所有ApplicationListener类型的bean名称,并添加到事件广播器中.最后就是通过事件广播器发送早期事件,早期事件为空所以不做处理.</p>

<p>11.初始化剩下的所有非懒加载的单例,源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Finish the initialization of this context's bean factory,
 * initializing all remaining singleton beans.
 * 完成上下文bean工厂的初始化,初始化所有剩下的单例bean
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finishBeanFactoryInitialization</span><span class="o">(</span><span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Initialize conversion service for this context.</span>
    <span class="c1">// 1.为上下文初始化转换服务</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">containsBean</span><span class="o">(</span><span class="no">CONVERSION_SERVICE_BEAN_NAME</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">beanFactory</span><span class="o">.</span><span class="na">isTypeMatch</span><span class="o">(</span><span class="no">CONVERSION_SERVICE_BEAN_NAME</span><span class="o">,</span> <span class="nc">ConversionService</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">setConversionService</span><span class="o">(</span>
                <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">CONVERSION_SERVICE_BEAN_NAME</span><span class="o">,</span> <span class="nc">ConversionService</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// Register a default embedded value resolver if no bean post-processor</span>
    <span class="c1">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span>
    <span class="c1">// at this point, primarily for resolution in annotation attribute values.</span>
    <span class="c1">//注册一个默认的内嵌值间解析器如果没有bean后置处理器注册过(像 PropertyPlaceholderConfigurer)</span>
    <span class="c1">//在此时, 主要用于注解属性值的解析</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">hasEmbeddedValueResolver</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">addEmbeddedValueResolver</span><span class="o">(</span><span class="n">strVal</span> <span class="o">-&gt;</span> <span class="n">getEnvironment</span><span class="o">().</span><span class="na">resolvePlaceholders</span><span class="o">(</span><span class="n">strVal</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span>
    <span class="c1">// 尽早初始化LoadTimeWeaverAware以允许尽早注册他们的转换器</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">weaverAwareNames</span> <span class="o">=</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBeanNamesForType</span><span class="o">(</span><span class="nc">LoadTimeWeaverAware</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">weaverAwareName</span> <span class="o">:</span> <span class="n">weaverAwareNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">getBean</span><span class="o">(</span><span class="n">weaverAwareName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Stop using the temporary ClassLoader for type matching.</span>
    <span class="c1">// 2.停止使用临时类加载器进行类型匹配</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">setTempClassLoader</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

    <span class="c1">// Allow for caching all bean definition metadata, not expecting further changes.</span>
    <span class="c1">//允许缓存所有的bean定义元数据,不希望有进一步的修改</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">freezeConfiguration</span><span class="o">();</span>

    <span class="c1">// Instantiate all remaining (non-lazy-init) singletons.</span>
    <span class="c1">// 3.初始化所有剩下 非懒加载的单例</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">preInstantiateSingletons</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见第十一步可以分为以下三步,首先是判断bean工厂中是否包含conversionService的bean,有则设置到bean工厂中;设置StringValueResolver为内置的解析器;初始化bean工厂中所有实现LoadTimeWeaverAware的bean,以上就是第一步所做的事,可以理解为前置检查.<br />
  第二步就是 <strong>setTempClassLoader和freezeConfiguration</strong> 看方法名称就可以明白了,主要就是停止使用临时类加载器并冻结已经加载好的beanDefinitionNames.<br />
  第三步就也是最重要的一步了,它就是初始化所有剩下的单例bean的关键所在.源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">preInstantiateSingletons</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Pre-instantiating singletons in "</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span>
    <span class="c1">// 迭代一个副本以允许初始化方法依次注册新的bean定义</span>
    <span class="c1">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span>
    <span class="c1">//尽管这可能不是常规工厂启动的一部分,但是他工作的很好</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">beanNames</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">.</span><span class="na">beanDefinitionNames</span><span class="o">);</span>

    <span class="c1">// Trigger initialization of all non-lazy singleton beans...</span>
    <span class="c1">//触发所有的非单例bean的初始化</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">beanNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">RootBeanDefinition</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">getMergedLocalBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">bd</span><span class="o">.</span><span class="na">isAbstract</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">bd</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bd</span><span class="o">.</span><span class="na">isLazyInit</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isFactoryBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">getBean</span><span class="o">(</span><span class="no">FACTORY_BEAN_PREFIX</span> <span class="o">+</span> <span class="n">beanName</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">FactoryBean</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="nc">FactoryBean</span><span class="o">&lt;?&gt;</span> <span class="n">factory</span> <span class="o">=</span> <span class="o">(</span><span class="nc">FactoryBean</span><span class="o">&lt;?&gt;)</span> <span class="n">bean</span><span class="o">;</span>
                    <span class="kt">boolean</span> <span class="n">isEagerInit</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">factory</span> <span class="k">instanceof</span> <span class="nc">SmartFactoryBean</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">isEagerInit</span> <span class="o">=</span> <span class="nc">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">((</span><span class="nc">PrivilegedAction</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;)</span>
                                        <span class="o">((</span><span class="nc">SmartFactoryBean</span><span class="o">&lt;?&gt;)</span> <span class="n">factory</span><span class="o">)::</span><span class="n">isEagerInit</span><span class="o">,</span>
                                <span class="n">getAccessControlContext</span><span class="o">());</span>
                    <span class="o">}</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="n">isEagerInit</span> <span class="o">=</span> <span class="o">(</span><span class="n">factory</span> <span class="k">instanceof</span> <span class="nc">SmartFactoryBean</span> <span class="o">&amp;&amp;</span>
                                <span class="o">((</span><span class="nc">SmartFactoryBean</span><span class="o">&lt;?&gt;)</span> <span class="n">factory</span><span class="o">).</span><span class="na">isEagerInit</span><span class="o">());</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">isEagerInit</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">getBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">getBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Trigger post-initialization callback for all applicable beans...</span>
    <span class="c1">//为所有的初始化bean触发初始化后回调</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">beanNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">singletonInstance</span> <span class="o">=</span> <span class="n">getSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">singletonInstance</span> <span class="k">instanceof</span> <span class="nc">SmartInitializingSingleton</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="nc">SmartInitializingSingleton</span> <span class="n">smartSingleton</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SmartInitializingSingleton</span><span class="o">)</span> <span class="n">singletonInstance</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">((</span><span class="nc">PrivilegedAction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="n">smartSingleton</span><span class="o">.</span><span class="na">afterSingletonsInstantiated</span><span class="o">();</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">},</span> <span class="n">getAccessControlContext</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">smartSingleton</span><span class="o">.</span><span class="na">afterSingletonsInstantiated</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  现在再看这个代码,逻辑一目了然,首先获取bean工厂中的所有beanNames,然后遍历这个beanNames,挑选出非抽象的且是单例且是非懒加载的调用 <strong>getBean()</strong> 进行初始化,最后找到所有实现了SmartInitializingSingleton接口触发初始化回调完成初始化.</p>

<p>12.最后一步发布相关事件,发布完成即应用启动成功,相关源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finishRefresh</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">//1.调用父类AbstractApplicationContext的finishRefresh</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">finishRefresh</span><span class="o">();</span>
    <span class="c1">//2.启动tomcat服务并发布服务初始化完成事件</span>
    <span class="nc">WebServer</span> <span class="n">webServer</span> <span class="o">=</span> <span class="n">startWebServer</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">webServer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">publishEvent</span><span class="o">(</span><span class="k">new</span> <span class="nc">ServletWebServerInitializedEvent</span><span class="o">(</span><span class="n">webServer</span><span class="o">,</span> <span class="k">this</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  可见最后一步可以分为两步,调用父类的完成刷新方法和启动tomcat服务并发布服务初始化完成事件.<br />
  我们先来看下父类的完成刷新做了什么:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Finish the refresh of this context, invoking the LifecycleProcessor's
 * onRefresh() method and publishing the
 * {@link org.springframework.context.event.ContextRefreshedEvent}.
 * 完成上下文的刷新,调用LifecycleProcessor的onRefresh方法 且 发布ContextRefreshedEvent事件
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finishRefresh</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Clear context-level resource caches (such as ASM metadata from scanning).</span>
    <span class="c1">//清除上下文级别的资源缓存</span>
    <span class="n">clearResourceCaches</span><span class="o">();</span>

    <span class="c1">// Initialize lifecycle processor for this context.</span>
    <span class="c1">//为上下文初始化生命周期处理器</span>
    <span class="n">initLifecycleProcessor</span><span class="o">();</span>

    <span class="c1">// Propagate refresh to lifecycle processor first.</span>
    <span class="c1">//首先将刷新传播到生命周期处理器中</span>
    <span class="n">getLifecycleProcessor</span><span class="o">().</span><span class="na">onRefresh</span><span class="o">();</span>

    <span class="c1">// Publish the final event.</span>
    <span class="c1">//发布最终完成事件</span>
    <span class="n">publishEvent</span><span class="o">(</span><span class="k">new</span> <span class="nc">ContextRefreshedEvent</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>

    <span class="c1">// Participate in LiveBeansView MBean, if active.</span>
    <span class="c1">// 如果激活的话 参与 LiveBeansView MBean</span>
    <span class="nc">LiveBeansView</span><span class="o">.</span><span class="na">registerApplicationContext</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  主要就是清除上下文资源缓存,初始化生命周期处理器并刷新它,最后发布上下已刷新事件并尝试注册LiveBeansView.</p>

<hr />

<h3 id="refreshcontext总结">refreshContext总结</h3>
<hr />
<ol>
  <li>为刷新做准备,主要是设置启动状态及一些属性的初始化</li>
  <li>通知子类刷新内部bean工厂并返回,主要是设置bean工厂序列化id,即应用的上下文</li>
  <li>准备在此上下文中使用的bean工厂,主要设置bean工厂的通用功能</li>
  <li>允许在上下文子类中对bean工厂进行后置处理,主要是注册相关后置处理器及应用范围</li>
  <li>调用在上下文中注册为bean的工厂处理器,即所有实现的BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor接口的后置处理器,首先解析实现了BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法.其次根据PriorityOrdered、Ordered和默认这三个顺序解析实现了BeanFactoryPostProcessor接口的postProcessBeanFactory方法.
这里最重要的要数实现了BeanDefinitionRegistryPostProcessor接口的ConfigurationClassPostProcessor类,它是解析SpringBoot启动类的关键.</li>
  <li>注册拦截bean创建的后置处理器,主要是找到实现了BeanPostProcessor接口的类初始化并注册</li>
  <li>初始化此上下文的消息源,初始化DelegatingMessageSource并注册messageSource到bean工厂中</li>
  <li>为上下文初始化事件多播器,初始化SimpleApplicationEventMulticaster并注册applicationEventMulticaster到bean工厂中</li>
  <li>初始化特定上下文子类中的其他特殊bean,初始化上下文中的themeSource和其内嵌的tomcat</li>
  <li>检查监听器bean并注册他们,将所有实现了ApplicationListener接口的bean注册到第八步创建的事件广播器中并尝试发布事件</li>
  <li>实例化所有剩余的非延迟初始化单例,设置bean工厂相关属性并冻结其bean名称,最后实例化所有剩余的非延迟单例</li>
  <li>完成此上下文的刷新,调用LifecycleProcessor的onRefresh()方法并发布上下文已刷新事件</li>
  <li>最后清除启动过程中的缓存
    <hr />
  </li>
</ol>

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">Septemper 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000005" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SpringBoot启动源码解析(五)</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-pok-rie-136728.jpg" class="img-responsive img-centered" alt="SpringBoot">

                            
                                <h3>SpringBootApplication Run方法解析(三):prepareContext</h3>
                            
                            </div>

                            <p><h3 id="run方法入口">Run方法入口</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Run the Spring application, creating and refreshing a new
 * {@link ApplicationContext}.
 * 运行Spring应用，创建和刷新一个新的应用上下文
 * @param args the application arguments (usually passed from a Java main method)
 * @return a running {@link ApplicationContext}
 */</span>
<span class="kd">public</span> <span class="nc">ConfigurableApplicationContext</span> <span class="nf">run</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//1.创建启动计时器</span>
    <span class="nc">StopWatch</span> <span class="n">stopWatch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StopWatch</span><span class="o">();</span>
    <span class="n">stopWatch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="c1">//创建启动上下文并初始化相应的Bootstrapper 目前暂未使用</span>
    <span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SpringBootExceptionReporter</span><span class="o">&gt;</span> <span class="n">exceptionReporters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//设置系统的配置模式，一般用于服务端开发 默认为true</span>
    <span class="n">configureHeadlessProperty</span><span class="o">();</span>
    <span class="c1">//获取spring上下文启动监听者  从META-INF/spring.factories中获取SpringApplicationRunListener的实现类并加载</span>
    <span class="nc">SpringApplicationRunListeners</span> <span class="n">listeners</span> <span class="o">=</span> <span class="n">getRunListeners</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
    <span class="c1">//发布启动中事件</span>
    <span class="n">listeners</span><span class="o">.</span><span class="na">starting</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//2.创建默认上下文参数</span>
        <span class="nc">ApplicationArguments</span> <span class="n">applicationArguments</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultApplicationArguments</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
        <span class="c1">//3.准备环境，将资源属性添加到环境中并与上下文绑定</span>
        <span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span> <span class="o">=</span> <span class="n">prepareEnvironment</span><span class="o">(</span><span class="n">listeners</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
        <span class="c1">//设置spring.beaninfo.ignore中过滤的bean</span>
        <span class="n">configureIgnoreBeanInfo</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
        <span class="c1">//打印spring标记</span>
        <span class="nc">Banner</span> <span class="n">printedBanner</span> <span class="o">=</span> <span class="n">printBanner</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
        <span class="c1">//4.根据web应用类型创建指定的应用上下文</span>
        <span class="c1">//注意:这里反射创建AnnotationConfigServletWebServerApplicationContext时,构造中创建AnnotatedBeanDefinitionReader中的AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)方法很重要</span>
        <span class="c1">//它将几个常见的BeanPostProcessor和BeanFactoryPostProcessor注册到注册表中  最重要的是internalConfigurationAnnotationProcessor来解析Configuration的配置类</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">createApplicationContext</span><span class="o">();</span>
        <span class="n">exceptionReporters</span> <span class="o">=</span> <span class="n">getSpringFactoriesInstances</span><span class="o">(</span><span class="nc">SpringBootExceptionReporter</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
                <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">ConfigurableApplicationContext</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span> <span class="n">context</span><span class="o">);</span>
        <span class="c1">//5.准备上下文</span>
        <span class="c1">//主要做了两件事:</span>
        <span class="c1">// 1.调用前面实例化的ApplicationContextInitializer的initialize方式初始化上下文</span>
        <span class="c1">// 2.在其中的load方法中将启动主函数bean定义注册到注册表中 beanDefinitionMap</span>
        <span class="n">prepareContext</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">environment</span><span class="o">,</span> <span class="n">listeners</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">,</span> <span class="n">printedBanner</span><span class="o">);</span>
        <span class="c1">//6.刷新上下文</span>
        <span class="n">refreshContext</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="n">afterRefresh</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
        <span class="n">stopWatch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">logStartupInfo</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">StartupInfoLogger</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mainApplicationClass</span><span class="o">).</span><span class="na">logStarted</span><span class="o">(</span><span class="n">getApplicationLog</span><span class="o">(),</span> <span class="n">stopWatch</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//监听者发布已启动事件</span>
        <span class="n">listeners</span><span class="o">.</span><span class="na">started</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="c1">//7.调用所有的ApplicationRunner和CommandLineRunner的实现类</span>
        <span class="n">callRunners</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleRunFailure</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">exceptionReporters</span><span class="o">,</span> <span class="n">listeners</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//监听者发布运行中事件</span>
        <span class="n">listeners</span><span class="o">.</span><span class="na">running</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleRunFailure</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">exceptionReporters</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />

<h3 id="preparecontext">prepareContext</h3>
<hr />
<p>本篇我们一起来看下 <strong>prepareContext</strong> 方法主要做了什么:<br />
第五步主要就是根据前面创建的 <strong>environment、listeners、applicationArguments、printedBanner</strong> 参数准备创建的上下文 <strong>context</strong> ,相关源码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">prepareContext</span><span class="o">(</span><span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span><span class="o">,</span> <span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">,</span>
        <span class="nc">SpringApplicationRunListeners</span> <span class="n">listeners</span><span class="o">,</span> <span class="nc">ApplicationArguments</span> <span class="n">applicationArguments</span><span class="o">,</span> <span class="nc">Banner</span> <span class="n">printedBanner</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//5.1为上下文设置environment</span>
    <span class="n">context</span><span class="o">.</span><span class="na">setEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="c1">//处理任何相关的后置处理,主要是设置 beanNameGenerator、resourceLoader、addConversionService</span>
    <span class="n">postProcessApplicationContext</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="c1">//5.2应用所有在构造函数阶段初始化的ApplicationContextInitializer</span>
    <span class="n">applyInitializers</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="c1">//5.3发布环境已准备事件</span>
    <span class="n">listeners</span><span class="o">.</span><span class="na">contextPrepared</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="c1">//5.4打印启动信息</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">logStartupInfo</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logStartupInfo</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getParent</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">logStartupProfileInfo</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// Add boot specific singleton beans</span>
    <span class="c1">//向bean工厂中注册springApplicationArguments和springBootBanner 两个单例</span>
    <span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBeanFactory</span><span class="o">();</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="s">"springApplicationArguments"</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">printedBanner</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="s">"springBootBanner"</span><span class="o">,</span> <span class="n">printedBanner</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//设置是否允许bean定义被覆盖,默认为false</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span> <span class="k">instanceof</span> <span class="nc">DefaultListableBeanFactory</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">((</span><span class="nc">DefaultListableBeanFactory</span><span class="o">)</span> <span class="n">beanFactory</span><span class="o">)</span>
                <span class="o">.</span><span class="na">setAllowBeanDefinitionOverriding</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">allowBeanDefinitionOverriding</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//如果应用设置为懒加载则添加懒加载后置处理器, 默认为false不用添加</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">lazyInitialization</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">.</span><span class="na">addBeanFactoryPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">LazyInitializationBeanFactoryPostProcessor</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">// Load the sources</span>
    <span class="c1">//5.5加载资源,这里其实就是换的启动函数,并将它注册为bean</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">sources</span> <span class="o">=</span> <span class="n">getAllSources</span><span class="o">();</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notEmpty</span><span class="o">(</span><span class="n">sources</span><span class="o">,</span> <span class="s">"Sources must not be empty"</span><span class="o">);</span>
    <span class="n">load</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">sources</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
    <span class="c1">//5.6发布上下文已加载事件</span>
    <span class="n">listeners</span><span class="o">.</span><span class="na">contextLoaded</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>5.1 首先看第一步相关的源码</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Delegates given environment to underlying {@link AnnotatedBeanDefinitionReader} and
 * {@link ClassPathBeanDefinitionScanner} members.
 * 委托给定的环境给底层的AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner成员
 */</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setEnvironment</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">setEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">reader</span><span class="o">.</span><span class="na">setEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">scanner</span><span class="o">.</span><span class="na">setEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Apply any relevant post processing the {@link ApplicationContext}. Subclasses can
 * apply additional processing as required.
 * 应用相关的后处理应用上下文. 子类可以根据需要应用额外的处理
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">postProcessApplicationContext</span><span class="o">(</span><span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//如果应用中存在beanNameGenerator则注册internalConfigurationBeanNameGenerator bean定义</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">beanNameGenerator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">.</span><span class="na">getBeanFactory</span><span class="o">().</span><span class="na">registerSingleton</span><span class="o">(</span><span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">CONFIGURATION_BEAN_NAME_GENERATOR</span><span class="o">,</span>
                <span class="k">this</span><span class="o">.</span><span class="na">beanNameGenerator</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//如果存在资源加载器则设置到上下文中</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">context</span> <span class="k">instanceof</span> <span class="nc">GenericApplicationContext</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">((</span><span class="nc">GenericApplicationContext</span><span class="o">)</span> <span class="n">context</span><span class="o">).</span><span class="na">setResourceLoader</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">context</span> <span class="k">instanceof</span> <span class="nc">DefaultResourceLoader</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">((</span><span class="nc">DefaultResourceLoader</span><span class="o">)</span> <span class="n">context</span><span class="o">).</span><span class="na">setClassLoader</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//如果addConversionService为true表明需要设置类型转换服务</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">addConversionService</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">.</span><span class="na">getBeanFactory</span><span class="o">().</span><span class="na">setConversionService</span><span class="o">(</span><span class="nc">ApplicationConversionService</span><span class="o">.</span><span class="na">getSharedInstance</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>首先看 <strong>setEnvironment</strong> 方法,其中两个成员是不是很熟悉, 就是在初始化 <strong>AnnotationConfigServletWebServerApplicationContext</strong> 上下文时创建的成员类,那么本方法也比较通俗易懂了,无非就是设置环境信息.<br />
然后我们再看 <strong>postProcessApplicationContext</strong> ,它的主要作用就是设置了 <strong>ConversionService</strong> 服务.</p>

<p>5.2 第二步就是应用所有 <strong>ApplicationContextInitializer</strong> ,相关源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Apply any {@link ApplicationContextInitializer}s to the context before it is
 * refreshed.
 * 在应用刷新前应用所有ApplicationContextInitializer到上下文中
 */</span>
<span class="nd">@SuppressWarnings</span><span class="o">({</span> <span class="s">"rawtypes"</span><span class="o">,</span> <span class="s">"unchecked"</span> <span class="o">})</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">applyInitializers</span><span class="o">(</span><span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">ApplicationContextInitializer</span> <span class="n">initializer</span> <span class="o">:</span> <span class="n">getInitializers</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">requiredType</span> <span class="o">=</span> <span class="nc">GenericTypeResolver</span><span class="o">.</span><span class="na">resolveTypeArgument</span><span class="o">(</span><span class="n">initializer</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span>
                <span class="nc">ApplicationContextInitializer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">Assert</span><span class="o">.</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="n">requiredType</span><span class="o">,</span> <span class="n">context</span><span class="o">,</span> <span class="s">"Unable to call initializer."</span><span class="o">);</span>
        <span class="n">initializer</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>第二步就是在获取所有在 <strong>SpringApplication</strong> 构造函数中初始化的 <strong>ApplicationContextInitializer</strong> ,并执行他们各自实现的 <strong>initialize()</strong> 方法,如果我们自定义 <strong>ApplicationContextInitializer</strong> 的话,也是在此处执行我们的类.</p>

<p>5.3 第三步发布上下文准备完成事件</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">contextPrepared</span><span class="o">(</span><span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">SpringApplicationRunListener</span> <span class="n">listener</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">listeners</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">listener</span><span class="o">.</span><span class="na">contextPrepared</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>5.4 第四步主要是执行一些上下文的准备动作,打印日志以及注册相关bean定义等.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">logStartupInfo</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">logStartupInfo</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getParent</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">);</span>
    <span class="n">logStartupProfileInfo</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// Add boot specific singleton beans</span>
<span class="c1">//向bean工厂中注册springApplicationArguments和springBootBanner 两个单例</span>
<span class="nc">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBeanFactory</span><span class="o">();</span>
<span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="s">"springApplicationArguments"</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">printedBanner</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">beanFactory</span><span class="o">.</span><span class="na">registerSingleton</span><span class="o">(</span><span class="s">"springBootBanner"</span><span class="o">,</span> <span class="n">printedBanner</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">//设置是否允许bean定义被覆盖,默认为false</span>
<span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span> <span class="k">instanceof</span> <span class="nc">DefaultListableBeanFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">((</span><span class="nc">DefaultListableBeanFactory</span><span class="o">)</span> <span class="n">beanFactory</span><span class="o">)</span>
            <span class="o">.</span><span class="na">setAllowBeanDefinitionOverriding</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">allowBeanDefinitionOverriding</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">//如果应用设置为懒加载则添加懒加载后置处理器, 默认为false不用添加</span>
<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">lazyInitialization</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">context</span><span class="o">.</span><span class="na">addBeanFactoryPostProcessor</span><span class="o">(</span><span class="k">new</span> <span class="nc">LazyInitializationBeanFactoryPostProcessor</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>主要就是向bean工厂中注册 <strong>springApplicationArguments、springBootBanner</strong> bean定义以及设置 <strong>allowBeanDefinitionOverriding</strong> 属性.</p>

<p>5.5 第五步是本章最重要的部分,即以主函数创建bean定义并注册到bean工厂中</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Load the sources</span>
<span class="c1">//5.5加载资源,这里其实就是换的启动函数,并将它注册为bean</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">sources</span> <span class="o">=</span> <span class="n">getAllSources</span><span class="o">();</span>
<span class="nc">Assert</span><span class="o">.</span><span class="na">notEmpty</span><span class="o">(</span><span class="n">sources</span><span class="o">,</span> <span class="s">"Sources must not be empty"</span><span class="o">);</span>
<span class="n">load</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">sources</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
</code></pre></div></div>

<p>第五步其实就分为两个方法,获取主函数 <strong>getAllSources</strong> 并加载该主函数 <strong>load</strong> . 
5.5.1 首先我们来看一下获取主函数 <strong>getAllSources</strong>:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Return an immutable set of all the sources that will be added to an
 * ApplicationContext when {@link #run(String...)} is called. This method combines any
 * primary sources specified in the constructor with any additional ones that have
 * been {@link #setSources(Set) explicitly set}.
 * 当调用run时, 返回将应用上下文的所有源的不可变集合. 
 * 此方法将构造函数中指定的任何主要来源与已显示设置的任何其他来源结合起来
 */</span>
<span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">getAllSources</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">allSources</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//这个primarySources就是我们的主函数</span>
    <span class="k">if</span> <span class="o">(!</span><span class="nc">CollectionUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">primarySources</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">allSources</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">primarySources</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(!</span><span class="nc">CollectionUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">sources</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">allSources</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">sources</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">allSources</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>该方法作用就是返回主函数的不可变集合.</p>

<p>5.5.2接下来我们再看看最核心的加载方法 <strong>load</strong> :</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Load beans into the application context.
 * 加载bean到应用上下文中
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">load</span><span class="o">(</span><span class="nc">ApplicationContext</span> <span class="n">context</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">sources</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Loading source "</span> <span class="o">+</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">arrayToCommaDelimitedString</span><span class="o">(</span><span class="n">sources</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="c1">//根据主函数常创建BeanDefinitionLoader,BeanDefinitionLoader的作用是注册bean定义</span>
    <span class="nc">BeanDefinitionLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">createBeanDefinitionLoader</span><span class="o">(</span><span class="n">getBeanDefinitionRegistry</span><span class="o">(</span><span class="n">context</span><span class="o">),</span> <span class="n">sources</span><span class="o">);</span>
    <span class="c1">//设置loader相关的属性</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">beanNameGenerator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">loader</span><span class="o">.</span><span class="na">setBeanNameGenerator</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">beanNameGenerator</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">loader</span><span class="o">.</span><span class="na">setResourceLoader</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">loader</span><span class="o">.</span><span class="na">setEnvironment</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//注册bean定义</span>
    <span class="n">loader</span><span class="o">.</span><span class="na">load</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>可见load方法中又可以分为两步,根据主函数创建BeanDefinitionLoader和调用该BeanDefinitionLoader的load方法加载bean.<br />
先看创建BeanDefinitionLoader的方法:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Factory method used to create the {@link BeanDefinitionLoader}.
 * 创建BeanDefinitionLoader的工厂方法
 */</span>
<span class="kd">protected</span> <span class="nc">BeanDefinitionLoader</span> <span class="nf">createBeanDefinitionLoader</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">sources</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">BeanDefinitionLoader</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">sources</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Create a new {@link BeanDefinitionLoader} that will load beans into the specified
 * {@link BeanDefinitionRegistry}.
 * 创建一个新的BeanDefinitionLoader, 它将bean加载到指定的BeanDefinitionRegistry
 */</span>
<span class="nc">BeanDefinitionLoader</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">sources</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="s">"Registry must not be null"</span><span class="o">);</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notEmpty</span><span class="o">(</span><span class="n">sources</span><span class="o">,</span> <span class="s">"Sources must not be empty"</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">sources</span> <span class="o">=</span> <span class="n">sources</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">annotatedReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotatedBeanDefinitionReader</span><span class="o">(</span><span class="n">registry</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">xmlReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlBeanDefinitionReader</span><span class="o">(</span><span class="n">registry</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isGroovyPresent</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">groovyReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GroovyBeanDefinitionReader</span><span class="o">(</span><span class="n">registry</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathBeanDefinitionScanner</span><span class="o">(</span><span class="n">registry</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">scanner</span><span class="o">.</span><span class="na">addExcludeFilter</span><span class="o">(</span><span class="k">new</span> <span class="nc">ClassExcludeFilter</span><span class="o">(</span><span class="n">sources</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>根据主函数和注册表进行创建BeanDefinitionLoader,并初始化AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner</p>

<p>最后我们来下最重要的load方法:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//加载主资源</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="nf">load</span><span class="o">(</span><span class="nc">Object</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="s">"Source must not be null"</span><span class="o">);</span>
    <span class="c1">//我们的主函数肯定是个类  所以走load类的方法</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">source</span> <span class="k">instanceof</span> <span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">load</span><span class="o">((</span><span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="n">source</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Invalid source type "</span> <span class="o">+</span> <span class="n">source</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">load</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//查看是否支持 groovy.lang.MetaClass 且 source是否为GroovyBeanDefinitionSource类或者是他的超类或接口</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isGroovyPresent</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="nc">GroovyBeanDefinitionSource</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">source</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Any GroovyLoaders added in beans{} DSL can contribute beans here</span>
        <span class="nc">GroovyBeanDefinitionSource</span> <span class="n">loader</span> <span class="o">=</span> <span class="nc">BeanUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="nc">GroovyBeanDefinitionSource</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">load</span><span class="o">(</span><span class="n">loader</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//判断当前类是否被@Component修饰,如果是则注册该资源</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isComponent</span><span class="o">(</span><span class="n">source</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">annotatedReader</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isComponent</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This has to be a bit of a guess. The only way to be sure that this type is</span>
    <span class="c1">// eligible is to make a bean definition out of it and try to instantiate it.</span>
    <span class="c1">//这不得不有点猜测, 确保此类型符合条件的唯一方法就是从中创建bean定义并尝试实例化他</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">MergedAnnotations</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="nc">SearchStrategy</span><span class="o">.</span><span class="na">TYPE_HIERARCHY</span><span class="o">).</span><span class="na">isPresent</span><span class="o">(</span><span class="nc">Component</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// Nested anonymous classes are not eligible for registration, nor are groovy</span>
    <span class="c1">// closures</span>
    <span class="c1">// 嵌套匿名类不符合注册条件, groovy闭包也不符合注册条件</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">matches</span><span class="o">(</span><span class="s">".*\\$_.*closure.*"</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">type</span><span class="o">.</span><span class="na">isAnonymousClass</span><span class="o">()</span>
            <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">().</span><span class="na">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>由上可见, <strong>doRegisterBean</strong> 之前都是进行类检测作用,主函数是否由 <strong>@Component</strong> 修饰,且它是否支持 <strong>groovy</strong> 语义.<br />
接下来我们继续看看它真正的 <strong>doRegisterBean</strong> 方法.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Register a bean from the given bean class, deriving its metadata from
 * class-declared annotations.
 * 从给定的bean类注册bean, 从类声明的注释中获取其元数据
 */</span>
<span class="kd">private</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">doRegisterBean</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">beanClass</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span>
        <span class="nd">@Nullable</span> <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;[]</span> <span class="n">qualifiers</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span>
        <span class="nd">@Nullable</span> <span class="nc">BeanDefinitionCustomizer</span><span class="o">[]</span> <span class="n">customizers</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//定义注解类型的bean定义,来看下它的构造方法:</span>
    <span class="c1">//所以它的主要作用就是解析指定类的所有注解</span>
    <span class="nc">AnnotatedGenericBeanDefinition</span> <span class="n">abd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotatedGenericBeanDefinition</span><span class="o">(</span><span class="n">beanClass</span><span class="o">);</span>
    <span class="c1">//检查当前bean定义是包含@Conditional且是否满足条件</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">conditionEvaluator</span><span class="o">.</span><span class="na">shouldSkip</span><span class="o">(</span><span class="n">abd</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">()))</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">abd</span><span class="o">.</span><span class="na">setInstanceSupplier</span><span class="o">(</span><span class="n">supplier</span><span class="o">);</span>
    <span class="c1">//解析适用于abd的 ScopeMetadata 并设置到 bean定义中</span>
    <span class="nc">ScopeMetadata</span> <span class="n">scopeMetadata</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">scopeMetadataResolver</span><span class="o">.</span><span class="na">resolveScopeMetadata</span><span class="o">(</span><span class="n">abd</span><span class="o">);</span>
    <span class="n">abd</span><span class="o">.</span><span class="na">setScope</span><span class="o">(</span><span class="n">scopeMetadata</span><span class="o">.</span><span class="na">getScopeName</span><span class="o">());</span>
    <span class="c1">//生成bean名称</span>
    <span class="nc">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="o">(</span><span class="n">name</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">name</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">beanNameGenerator</span><span class="o">.</span><span class="na">generateBeanName</span><span class="o">(</span><span class="n">abd</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">));</span>

    <span class="c1">//处理通用bea注解 主要处理@Lazy, @Primary, @DependsOn, @Role, @Description等注解</span>
    <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">processCommonDefinitionAnnotations</span><span class="o">(</span><span class="n">abd</span><span class="o">);</span>
    <span class="c1">//存在以上注解则设置bean属性</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">qualifiers</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;</span> <span class="n">qualifier</span> <span class="o">:</span> <span class="n">qualifiers</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Primary</span><span class="o">.</span><span class="na">class</span> <span class="o">==</span> <span class="n">qualifier</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">abd</span><span class="o">.</span><span class="na">setPrimary</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">Lazy</span><span class="o">.</span><span class="na">class</span> <span class="o">==</span> <span class="n">qualifier</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">abd</span><span class="o">.</span><span class="na">setLazyInit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">abd</span><span class="o">.</span><span class="na">addQualifier</span><span class="o">(</span><span class="k">new</span> <span class="nc">AutowireCandidateQualifier</span><span class="o">(</span><span class="n">qualifier</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//是否有自定义器 自定义 bean定义</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">customizers</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">BeanDefinitionCustomizer</span> <span class="n">customizer</span> <span class="o">:</span> <span class="n">customizers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">customizer</span><span class="o">.</span><span class="na">customize</span><span class="o">(</span><span class="n">abd</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//创建该bean 定义持有器</span>
    <span class="nc">BeanDefinitionHolder</span> <span class="n">definitionHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BeanDefinitionHolder</span><span class="o">(</span><span class="n">abd</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="c1">//设置当前bean定义的代理模式 根据proxyBeanMethods字段</span>
    <span class="n">definitionHolder</span> <span class="o">=</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">applyScopedProxyMode</span><span class="o">(</span><span class="n">scopeMetadata</span><span class="o">,</span> <span class="n">definitionHolder</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
    <span class="c1">//注册bean定义</span>
    <span class="nc">BeanDefinitionReaderUtils</span><span class="o">.</span><span class="na">registerBeanDefinition</span><span class="o">(</span><span class="n">definitionHolder</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Create a new AnnotatedGenericBeanDefinition for the given bean class.
 * 为给定的类创建一个新的 AnnotatedGenericBeanDefinition
 */</span>
<span class="kd">public</span> <span class="nf">AnnotatedGenericBeanDefinition</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanClass</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">setBeanClass</span><span class="o">(</span><span class="n">beanClass</span><span class="o">);</span>
    <span class="c1">//核心就是这步,它将解析给定的类的所有注解</span>
    <span class="k">this</span><span class="o">.</span><span class="na">metadata</span> <span class="o">=</span> <span class="nc">AnnotationMetadata</span><span class="o">.</span><span class="na">introspect</span><span class="o">(</span><span class="n">beanClass</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Determine if an item should be skipped based on {@code @Conditional} annotations.
 * 根据 @Conditional注解确定是否应跳过项目
 */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">shouldSkip</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">AnnotatedTypeMetadata</span> <span class="n">metadata</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">ConfigurationPhase</span> <span class="n">phase</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//判断该类的元注解是否包含 @Conditional  不包含直接返回false</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">metadata</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">metadata</span><span class="o">.</span><span class="na">isAnnotated</span><span class="o">(</span><span class="nc">Conditional</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//当parse为null时, 尝试使用@Conditional解析@Configuration类 和 非@Configuration修饰的bean</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">phase</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">metadata</span> <span class="k">instanceof</span> <span class="nc">AnnotationMetadata</span> <span class="o">&amp;&amp;</span>
                <span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">isConfigurationCandidate</span><span class="o">((</span><span class="nc">AnnotationMetadata</span><span class="o">)</span> <span class="n">metadata</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">shouldSkip</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">PARSE_CONFIGURATION</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">shouldSkip</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">REGISTER_BEAN</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Condition</span><span class="o">&gt;</span> <span class="n">conditions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">conditionClasses</span> <span class="o">:</span> <span class="n">getConditionClasses</span><span class="o">(</span><span class="n">metadata</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">conditionClass</span> <span class="o">:</span> <span class="n">conditionClasses</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Condition</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">getCondition</span><span class="o">(</span><span class="n">conditionClass</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">());</span>
            <span class="n">conditions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">condition</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nc">AnnotationAwareOrderComparator</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">conditions</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">Condition</span> <span class="n">condition</span> <span class="o">:</span> <span class="n">conditions</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ConfigurationPhase</span> <span class="n">requiredPhase</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="nc">ConfigurationCondition</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">requiredPhase</span> <span class="o">=</span> <span class="o">((</span><span class="nc">ConfigurationCondition</span><span class="o">)</span> <span class="n">condition</span><span class="o">).</span><span class="na">getConfigurationPhase</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">requiredPhase</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">requiredPhase</span> <span class="o">==</span> <span class="n">phase</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">condition</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">context</span><span class="o">,</span> <span class="n">metadata</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//处理通用bean定义注解 </span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">processCommonDefinitionAnnotations</span><span class="o">(</span><span class="nc">AnnotatedBeanDefinition</span> <span class="n">abd</span><span class="o">,</span> <span class="nc">AnnotatedTypeMetadata</span> <span class="n">metadata</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//首先检查 @Lazy注解</span>
    <span class="nc">AnnotationAttributes</span> <span class="n">lazy</span> <span class="o">=</span> <span class="n">attributesFor</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">Lazy</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lazy</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">abd</span><span class="o">.</span><span class="na">setLazyInit</span><span class="o">(</span><span class="n">lazy</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"value"</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="c1">//判断当前bean定义的元注解中是否还有 @Lazy注解</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">abd</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">()</span> <span class="o">!=</span> <span class="n">metadata</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lazy</span> <span class="o">=</span> <span class="n">attributesFor</span><span class="o">(</span><span class="n">abd</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">Lazy</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lazy</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">abd</span><span class="o">.</span><span class="na">setLazyInit</span><span class="o">(</span><span class="n">lazy</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"value"</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//元数据是否以 @Primary为注解</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">metadata</span><span class="o">.</span><span class="na">isAnnotated</span><span class="o">(</span><span class="nc">Primary</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
        <span class="n">abd</span><span class="o">.</span><span class="na">setPrimary</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//元数据是否以 @DependsOn为注解</span>
    <span class="nc">AnnotationAttributes</span> <span class="n">dependsOn</span> <span class="o">=</span> <span class="n">attributesFor</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">DependsOn</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dependsOn</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">abd</span><span class="o">.</span><span class="na">setDependsOn</span><span class="o">(</span><span class="n">dependsOn</span><span class="o">.</span><span class="na">getStringArray</span><span class="o">(</span><span class="s">"value"</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">//元数据是否以 @Role为注解</span>
    <span class="nc">AnnotationAttributes</span> <span class="n">role</span> <span class="o">=</span> <span class="n">attributesFor</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">Role</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">role</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">abd</span><span class="o">.</span><span class="na">setRole</span><span class="o">(</span><span class="n">role</span><span class="o">.</span><span class="na">getNumber</span><span class="o">(</span><span class="s">"value"</span><span class="o">).</span><span class="na">intValue</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">//元数据是否以 @Description为注解</span>
    <span class="nc">AnnotationAttributes</span> <span class="n">description</span> <span class="o">=</span> <span class="n">attributesFor</span><span class="o">(</span><span class="n">metadata</span><span class="o">,</span> <span class="nc">Description</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">description</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">abd</span><span class="o">.</span><span class="na">setDescription</span><span class="o">(</span><span class="n">description</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"value"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>由此可见, <strong>doRegisterBean</strong> 的作用就是解析主函数的相关源注解,并将其作为bean定义注册到bean工厂中,以供后续进行真正解析这个类.</p>
<hr />

<h3 id="preparecontext总结">prepareContext总结</h3>
<hr />
<p>可以大约分为6步:</p>
<ol>
  <li>设置 <strong>environment</strong> 到上下文中,并执行相关的后置处理,设置类型装换服务</li>
  <li>应用在构造函数阶段实例化的所有 <strong>ApplicationContextInitializer</strong> 初始化器到上下文</li>
  <li>此时上下文已经准备就绪,发布 <strong>contextPrepared</strong> 事件</li>
  <li>打印启动信息,并注册 <strong>springApplicationArguments、springBootBanner</strong> bean定义,并设置上下文的是否允许bean定义覆盖属性 <strong>allowBeanDefinitionOverriding</strong></li>
  <li>第五步就是最重要的一步了,这里将进行对主函数注解的解析并校验,校验通过则注册到bean工厂中,供后面解析配置类处理</li>
  <li>最后一步就是发布上下文已加载事件
    <hr />
  </li>
</ol>

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">September 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000004" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SpringBoot启动源码解析(四)</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-anastasia-pavlova-8692301.jpg" class="img-responsive img-centered" alt="SpringBoot4">

                            
                                <h3>SpringBootApplication Run方法解析(二):createApplicationContext</h3>
                            
                            </div>

                            <p><h3 id="run方法入口">Run方法入口</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Run the Spring application, creating and refreshing a new
 * {@link ApplicationContext}.
 * 运行Spring应用，创建和刷新一个新的应用上下文
 * @param args the application arguments (usually passed from a Java main method)
 * @return a running {@link ApplicationContext}
 */</span>
<span class="kd">public</span> <span class="nc">ConfigurableApplicationContext</span> <span class="nf">run</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//1.创建启动计时器</span>
    <span class="nc">StopWatch</span> <span class="n">stopWatch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StopWatch</span><span class="o">();</span>
    <span class="n">stopWatch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="c1">//创建启动上下文并初始化相应的Bootstrapper 目前暂未使用</span>
    <span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SpringBootExceptionReporter</span><span class="o">&gt;</span> <span class="n">exceptionReporters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//设置系统的配置模式，一般用于服务端开发 默认为true</span>
    <span class="n">configureHeadlessProperty</span><span class="o">();</span>
    <span class="c1">//获取spring上下文启动监听者  从META-INF/spring.factories中获取SpringApplicationRunListener的实现类并加载</span>
    <span class="nc">SpringApplicationRunListeners</span> <span class="n">listeners</span> <span class="o">=</span> <span class="n">getRunListeners</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
    <span class="c1">//发布启动中事件</span>
    <span class="n">listeners</span><span class="o">.</span><span class="na">starting</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//2.创建默认上下文参数</span>
        <span class="nc">ApplicationArguments</span> <span class="n">applicationArguments</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultApplicationArguments</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
        <span class="c1">//3.准备环境，将资源属性添加到环境中并与上下文绑定</span>
        <span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span> <span class="o">=</span> <span class="n">prepareEnvironment</span><span class="o">(</span><span class="n">listeners</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
        <span class="c1">//设置spring.beaninfo.ignore中过滤的bean</span>
        <span class="n">configureIgnoreBeanInfo</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
        <span class="c1">//打印spring标记</span>
        <span class="nc">Banner</span> <span class="n">printedBanner</span> <span class="o">=</span> <span class="n">printBanner</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
        <span class="c1">//4.根据web应用类型创建指定的应用上下文</span>
        <span class="c1">//注意:这里反射创建AnnotationConfigServletWebServerApplicationContext时,构造中创建AnnotatedBeanDefinitionReader中的AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)方法很重要</span>
        <span class="c1">//它将几个常见的BeanPostProcessor和BeanFactoryPostProcessor注册到注册表中  最重要的是internalConfigurationAnnotationProcessor来解析Configuration的配置类</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">createApplicationContext</span><span class="o">();</span>
        <span class="n">exceptionReporters</span> <span class="o">=</span> <span class="n">getSpringFactoriesInstances</span><span class="o">(</span><span class="nc">SpringBootExceptionReporter</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
                <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">ConfigurableApplicationContext</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span> <span class="n">context</span><span class="o">);</span>
        <span class="c1">//5.准备上下文</span>
        <span class="c1">//主要做了两件事:</span>
        <span class="c1">// 1.调用前面实例化的ApplicationContextInitializer的initialize方式初始化上下文</span>
        <span class="c1">// 2.在其中的load方法中将启动主函数bean定义注册到注册表中 beanDefinitionMap</span>
        <span class="n">prepareContext</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">environment</span><span class="o">,</span> <span class="n">listeners</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">,</span> <span class="n">printedBanner</span><span class="o">);</span>
        <span class="c1">//6.刷新上下文</span>
        <span class="n">refreshContext</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="n">afterRefresh</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
        <span class="n">stopWatch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">logStartupInfo</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">StartupInfoLogger</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mainApplicationClass</span><span class="o">).</span><span class="na">logStarted</span><span class="o">(</span><span class="n">getApplicationLog</span><span class="o">(),</span> <span class="n">stopWatch</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//监听者发布已启动事件</span>
        <span class="n">listeners</span><span class="o">.</span><span class="na">started</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="c1">//7.调用所有的ApplicationRunner和CommandLineRunner的实现类</span>
        <span class="n">callRunners</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleRunFailure</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">exceptionReporters</span><span class="o">,</span> <span class="n">listeners</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//监听者发布运行中事件</span>
        <span class="n">listeners</span><span class="o">.</span><span class="na">running</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleRunFailure</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">exceptionReporters</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />

<h3 id="createapplicationcontext">createApplicationContext</h3>
<hr />
<p>本章我们主要看下createApplicationContext:
第四步就是通过反射创建 <strong>ApplicationContext</strong> ,相关源码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * The class name of application context that will be used by default for non-web
 * environments.
 * 默认情况下将用于非web环境的应用程序上下文的类名
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">DEFAULT_CONTEXT_CLASS</span> <span class="o">=</span> <span class="s">"org.springframework.context."</span>
        <span class="o">+</span> <span class="s">"annotation.AnnotationConfigApplicationContext"</span><span class="o">;</span>

<span class="cm">/**
 * The class name of application context that will be used by default for web
 * environments.
 * 默认情况下将用于web环境的应用程序上下文的类名
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">DEFAULT_SERVLET_WEB_CONTEXT_CLASS</span> <span class="o">=</span> <span class="s">"org.springframework.boot."</span>
        <span class="o">+</span> <span class="s">"web.servlet.context.AnnotationConfigServletWebServerApplicationContext"</span><span class="o">;</span>

<span class="cm">/**
 * The class name of application context that will be used by default for reactive web
 * environments.
 * 默认情况下将用于reactive web环境的应用程序上下文的类名
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">DEFAULT_REACTIVE_WEB_CONTEXT_CLASS</span> <span class="o">=</span> <span class="s">"org.springframework."</span>
        <span class="o">+</span> <span class="s">"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext"</span><span class="o">;</span>

<span class="cm">/**
 * Strategy method used to create the {@link ApplicationContext}. By default this
 * method will respect any explicitly set application context or application context
 * class before falling back to a suitable default.
 * 创建应用上下文使用的策略方法.默认情况下,此方法将在回退到合适的默认值之前尊重任何显示设置的应用程序上下文或类.
 */</span>
<span class="kd">protected</span> <span class="nc">ConfigurableApplicationContext</span> <span class="nf">createApplicationContext</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">contextClass</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">applicationContextClass</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">contextClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">switch</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">webApplicationType</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//通常我们的上下文默认是Servlet类型,实例化AnnotationConfigServletWebServerApplicationContext</span>
            <span class="k">case</span> <span class="nl">SERVLET:</span>
                <span class="n">contextClass</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="no">DEFAULT_SERVLET_WEB_CONTEXT_CLASS</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nl">REACTIVE:</span>
                <span class="n">contextClass</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="no">DEFAULT_REACTIVE_WEB_CONTEXT_CLASS</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="n">contextClass</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="no">DEFAULT_CONTEXT_CLASS</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span>
                    <span class="s">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//真正的实例化位置</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">ConfigurableApplicationContext</span><span class="o">)</span> <span class="nc">BeanUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">contextClass</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因为我们的应用类型为 <strong>SERVLET</strong> ,所以应该初始化 <strong>AnnotationConfigServletWebServerApplicationContext</strong> , 下面我们继续看下实例化 <strong>AnnotationConfigServletWebServerApplicationContext</strong> 的源码:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Create a new {@link AnnotationConfigServletWebServerApplicationContext} that needs
 * to be populated through {@link #register} calls and then manually
 * {@linkplain #refresh refreshed}.
 * 创建新的AnnotationConfigServletWebServerApplicationContext, 他需要通过通过register调用填充然后手动refreshed
 */</span>
<span class="kd">public</span> <span class="nf">AnnotationConfigServletWebServerApplicationContext</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotatedBeanDefinitionReader</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathBeanDefinitionScanner</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>我们首先来看下 <strong>AnnotationConfigServletWebServerApplicationContext</strong> 的作用:接受带有 <strong>@Configuration</strong> 、 <strong>@Component</strong> 和 <strong>inject</strong> 注解的类,可以指定类进行注册同样可以根据类路径扫描来注册.<br />
在它的无参构造中,它又创建了 <strong>AnnotatedBeanDefinitionReader</strong> 和 <strong>ClassPathBeanDefinitionScanner</strong> .<br />
其中 <strong>AnnotatedBeanDefinitionReader</strong> 的作用是以编程方式注册Bean类; <strong>ClassPathBeanDefinitionScanner</strong> 的作用是扫描类路径下所有以 <strong>@Component、@Repository、@Service、@Controller、ManagedBean、Named</strong> 等注解修饰的类,并注册相关的bean定义.</p>

<p>4.1 首先我们先看下 <strong>AnnotatedBeanDefinitionReader</strong> 的源码:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">AnnotatedBeanDefinitionReader</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">getOrCreateEnvironment</span><span class="o">(</span><span class="n">registry</span><span class="o">));</span>
<span class="o">}</span>

<span class="cm">/**
 * Create a new {@code AnnotatedBeanDefinitionReader} for the given registry,
 * using the given {@link Environment}.
 * 使用给定的注册表和环境创建AnnotatedBeanDefinitionReader
 */</span>
<span class="kd">public</span> <span class="nf">AnnotatedBeanDefinitionReader</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">,</span> <span class="nc">Environment</span> <span class="n">environment</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="s">"BeanDefinitionRegistry must not be null"</span><span class="o">);</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">environment</span><span class="o">,</span> <span class="s">"Environment must not be null"</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">registry</span> <span class="o">=</span> <span class="n">registry</span><span class="o">;</span>
    <span class="c1">//创建用于处理@Conditional注解的内部类</span>
    <span class="k">this</span><span class="o">.</span><span class="na">conditionEvaluator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConditionEvaluator</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">environment</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="c1">//这里是最重要的地方,注册了多个后置处理器,供后面创建bean的时候调用</span>
    <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">registerAnnotationConfigProcessors</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>可见 <strong>AnnotatedBeanDefinitionReader</strong> 主构造中最重要的就是 <strong>AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)</strong> 这个方法,我们继续往下看看:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * The bean name of the internally managed Configuration annotation processor.
 * 内部管理的配置注解处理器的bean名称
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME</span> <span class="o">=</span>
        <span class="s">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span><span class="o">;</span>

<span class="cm">/**
 * The bean name of the internally managed Autowired annotation processor.
 * 内部管理的自动注入注解处理器的bean名称
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME</span> <span class="o">=</span>
        <span class="s">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span><span class="o">;</span>

<span class="cm">/**
 * The bean name of the internally managed JSR-250 annotation processor.
 * 内部管理的JSR-250注解处理器的bean名称
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">COMMON_ANNOTATION_PROCESSOR_BEAN_NAME</span> <span class="o">=</span>
        <span class="s">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span><span class="o">;</span>

<span class="cm">/**
 * The bean name of the internally managed JPA annotation processor.
 * 内部处理的JPA注解处理器的bean名称
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME</span> <span class="o">=</span>
        <span class="s">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span><span class="o">;</span>

<span class="cm">/**
 * The bean name of the internally managed @EventListener annotation processor.
 * 内部处理的@EventListener注解处理器的bean名称
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">EVENT_LISTENER_PROCESSOR_BEAN_NAME</span> <span class="o">=</span>
        <span class="s">"org.springframework.context.event.internalEventListenerProcessor"</span><span class="o">;</span>

<span class="cm">/**
 * The bean name of the internally managed EventListenerFactory.
 * 内部处理的EventListenerFactory的bean名称
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">EVENT_LISTENER_FACTORY_BEAN_NAME</span> <span class="o">=</span>
        <span class="s">"org.springframework.context.event.internalEventListenerFactory"</span><span class="o">;</span>

<span class="cm">/**
 * Register all relevant annotation post processors in the given registry.
 * 在给定的注册表中注册所有相关注解的后置处理器
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="nf">registerAnnotationConfigProcessors</span><span class="o">(</span>
        <span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//获取最原始的bean工厂</span>
    <span class="nc">DefaultListableBeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="n">unwrapDefaultListableBeanFactory</span><span class="o">(</span><span class="n">registry</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//设置AnnotationAwareOrderComparator,主要用于 @Order和@Priority的排序功能</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getDependencyComparator</span><span class="o">()</span> <span class="k">instanceof</span> <span class="nc">AnnotationAwareOrderComparator</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">beanFactory</span><span class="o">.</span><span class="na">setDependencyComparator</span><span class="o">(</span><span class="nc">AnnotationAwareOrderComparator</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//设置ContextAnnotationAutowireCandidateResolver,主要提供对限定符注解以及@Lazy注解的懒加载</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">getAutowireCandidateResolver</span><span class="o">()</span> <span class="k">instanceof</span> <span class="nc">ContextAnnotationAutowireCandidateResolver</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">beanFactory</span><span class="o">.</span><span class="na">setAutowireCandidateResolver</span><span class="o">(</span><span class="k">new</span> <span class="nc">ContextAnnotationAutowireCandidateResolver</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">beanDefs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="mi">8</span><span class="o">);</span>
    <span class="c1">//创建ConfigurationClassPostProcessor后置处理器bean定义,并注册到bean工厂中</span>
    <span class="c1">//ConfigurationClassPostProcessor的主要作用就是在启动时处理@Configuration修饰的类,其实就是我们的主函数对应的类</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">registry</span><span class="o">.</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="no">CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">RootBeanDefinition</span> <span class="n">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RootBeanDefinition</span><span class="o">(</span><span class="nc">ConfigurationClassPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">def</span><span class="o">.</span><span class="na">setSource</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="n">beanDefs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registerPostProcessor</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">def</span><span class="o">,</span> <span class="no">CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="c1">//创建AutowiredAnnotationBeanPostProcessor后置处理器Bean定义,并注册到bean工厂中</span>
    <span class="c1">//AutowiredAnnotationBeanPostProcessor的主要作用是自动装配注解的字段、set方法和任何配置方法,默认通过@Autowired和@Value</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">registry</span><span class="o">.</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="no">AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">RootBeanDefinition</span> <span class="n">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RootBeanDefinition</span><span class="o">(</span><span class="nc">AutowiredAnnotationBeanPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">def</span><span class="o">.</span><span class="na">setSource</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="n">beanDefs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registerPostProcessor</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">def</span><span class="o">,</span> <span class="no">AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span>
    <span class="c1">//检查是否支持JSR-250,支持则创建CommonAnnotationBeanPostProcessor后置处理器并注册到bean工厂中</span>
    <span class="c1">//CommonAnnotationBeanPostProcessor的主要作用是支持开箱即用的java注解,主要是annotation中的注解,一般是@PostConstruct、@PreDestroy,最主要是@Resources</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">jsr250Present</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">registry</span><span class="o">.</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="no">COMMON_ANNOTATION_PROCESSOR_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">RootBeanDefinition</span> <span class="n">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RootBeanDefinition</span><span class="o">(</span><span class="nc">CommonAnnotationBeanPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">def</span><span class="o">.</span><span class="na">setSource</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="n">beanDefs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registerPostProcessor</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">def</span><span class="o">,</span> <span class="no">COMMON_ANNOTATION_PROCESSOR_BEAN_NAME</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span>
    <span class="c1">//检查是否支持JPA,支持则创建PersistenceAnnotationBeanPostProcessor后置处理器并注册到bean工厂中</span>
    <span class="c1">//PersistenceAnnotationBeanPostProcessor的主要作用是为了注入相关EntityManagerFactory和EntityManager资源处理PersistenceUnit和PersistenceContext注解</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">jpaPresent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">registry</span><span class="o">.</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="no">PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">RootBeanDefinition</span> <span class="n">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RootBeanDefinition</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">def</span><span class="o">.</span><span class="na">setBeanClass</span><span class="o">(</span><span class="nc">ClassUtils</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="no">PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME</span><span class="o">,</span>
                    <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">()));</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span>
                    <span class="s">"Cannot load optional framework class: "</span> <span class="o">+</span> <span class="no">PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">def</span><span class="o">.</span><span class="na">setSource</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="n">beanDefs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registerPostProcessor</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">def</span><span class="o">,</span> <span class="no">PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">//创建EventListenerMethodProcessor后置处理器并注册到bean工厂中</span>
    <span class="c1">//EventListenerMethodProcessor的主要作用是作为单独的ApplicationListener实例,主要用于早期检索,避免对其处理器bean和他的EventListenerFactory委托者进行aop检查</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">registry</span><span class="o">.</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="no">EVENT_LISTENER_PROCESSOR_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">RootBeanDefinition</span> <span class="n">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RootBeanDefinition</span><span class="o">(</span><span class="nc">EventListenerMethodProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">def</span><span class="o">.</span><span class="na">setSource</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="n">beanDefs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registerPostProcessor</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">def</span><span class="o">,</span> <span class="no">EVENT_LISTENER_PROCESSOR_BEAN_NAME</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="c1">//创建DefaultEventListenerFactory bean定义并注册到bean工厂</span>
    <span class="c1">//DefaultEventListenerFactory主要是为了常规的EventListener注解</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">registry</span><span class="o">.</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="no">EVENT_LISTENER_FACTORY_BEAN_NAME</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">RootBeanDefinition</span> <span class="n">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RootBeanDefinition</span><span class="o">(</span><span class="nc">DefaultEventListenerFactory</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">def</span><span class="o">.</span><span class="na">setSource</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="n">beanDefs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registerPostProcessor</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">def</span><span class="o">,</span> <span class="no">EVENT_LISTENER_FACTORY_BEAN_NAME</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">beanDefs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>可见 <strong>AnnotatedBeanDefinitionReader</strong> 的作用就是注册了多个后置处理器.我们来看这几个后置处理器,先看他们的类图:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/AnnotationConfigProcessors.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="AnnotationConfigProcessors" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/AnnotationConfigProcessors.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">AnnotationConfigProcessors</div>
    </a>
</center>

<p>其中最重要的就是 <strong>ConfigurationClassPostProcessor</strong> 从类图中也可以看到它继承的父类更多,其中最重要的父类就是 <strong>BeanDefinitionRegistryPostProcessor</strong> ,它就是处理主函数的核心,具体后面再介绍.<br />
我们一一介绍下这几个类的大概作用:</p>
<ul>
  <li>ConfigurationClassPostProcessor:最为重要,在启动时处理 <strong>@Configuration</strong> 修饰的类,主要就是我们启动时使用 <strong>@SpringBootApplication</strong> 修饰的主函数</li>
  <li>AutowiredAnnotationBeanPostProcessor:主要作用是通过 <strong>@Autowired、@Value</strong> 等注解自动装配字段、set方法和任何配置方法</li>
  <li>CommonAnnotationBeanPostProcessor:主要作用是支持开箱即用的方法,例如 <strong>@PostConstruct、@PreDestroy、@Resources</strong> 等</li>
  <li>PersistenceAnnotationBeanPostProcessor:主要作用是为了注入相关EntityManagerFactory和EntityManager资源处理PersistenceUnit和PersistenceContext注解</li>
  <li>EventListenerMethodProcessor:主要作用是作为单独的ApplicationListener实例,主要用于早期检索,避免对其处理器bean和他的EventListenerFactory委托者进行aop检查</li>
  <li>DefaultEventListenerFactory:主要是为了常规的EventListener注解</li>
</ul>

<blockquote>
  <p>综上所述: <strong>AnnotatedBeanDefinitionReader</strong> 的主要作用就是注册多个后置处理器到bean工厂中,为后面解析主函数做准备</p>
</blockquote>

<p>4.2 接下来我们再看下 <strong>ClassPathBeanDefinitionScanner</strong> 的源码:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory and
 * using the given {@link Environment} when evaluating bean definition profile metadata.
 * 为给定的bean工厂创建ClassPathBeanDefinitionScanner,并在评估bean定义配置元数据时使用给定的Environment
 */</span>
<span class="kd">public</span> <span class="nf">ClassPathBeanDefinitionScanner</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">useDefaultFilters</span><span class="o">,</span>
        <span class="nc">Environment</span> <span class="n">environment</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">ResourceLoader</span> <span class="n">resourceLoader</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="s">"BeanDefinitionRegistry must not be null"</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">registry</span> <span class="o">=</span> <span class="n">registry</span><span class="o">;</span>
    <span class="c1">//注册默认过滤器 主要是@Component、ManagedBean、Named</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">useDefaultFilters</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">registerDefaultFilters</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">//设置environment</span>
    <span class="n">setEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="c1">//设置类加载器</span>
    <span class="n">setResourceLoader</span><span class="o">(</span><span class="n">resourceLoader</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>我们先来看下 <strong>registerDefaultFilters()</strong> 方法具体做了什么:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Register the default filter for {@link Component @Component}.
 * &lt;p&gt;This will implicitly register all annotations that have the
 * {@link Component @Component} meta-annotation including the
 * {@link Repository @Repository}, {@link Service @Service}, and
 * {@link Controller @Controller} stereotype annotations.
 * &lt;p&gt;Also supports Java EE 6's {@link javax.annotation.ManagedBean} and
 * JSR-330's {@link javax.inject.Named} annotations, if available.
 * 为@Component注册默认过滤器.他可以注册所有隐式含有@Component元注解,包括@Repository、@Service、@Controller
 * 同时还可以支持 ManagedBean和Named
 */</span>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">registerDefaultFilters</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">includeFilters</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">AnnotationTypeFilter</span><span class="o">(</span><span class="nc">Component</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="nc">ClassLoader</span> <span class="n">cl</span> <span class="o">=</span> <span class="nc">ClassPathScanningCandidateComponentProvider</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">includeFilters</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">AnnotationTypeFilter</span><span class="o">(</span>
                <span class="o">((</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;)</span> <span class="nc">ClassUtils</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"javax.annotation.ManagedBean"</span><span class="o">,</span> <span class="n">cl</span><span class="o">)),</span> <span class="kc">false</span><span class="o">));</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span>
    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">includeFilters</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">AnnotationTypeFilter</span><span class="o">(</span>
                <span class="o">((</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;)</span> <span class="nc">ClassUtils</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"javax.inject.Named"</span><span class="o">,</span> <span class="n">cl</span><span class="o">)),</span> <span class="kc">false</span><span class="o">));</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"JSR-330 'javax.inject.Named' annotation found and supported for component scanning"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// JSR-330 API not available - simply skip.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>下面还有一个方法比较有意思,那就是 <strong>setResourceLoader(resourceLoader)</strong> 方法,乍一眼看上去它就是设置了资源加载器,并没有什么特别的作用,我们翻翻的源码看看:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Set the {@link ResourceLoader} to use for resource locations.
 * This will typically be a {@link ResourcePatternResolver} implementation.
 * &lt;p&gt;Default is a {@code PathMatchingResourcePatternResolver}, also capable of
 * resource pattern resolving through the {@code ResourcePatternResolver} interface.
 * 设置资源加载器以用于资源位置. 通常是ResourcePatternResolver的实现.
 */</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setResourceLoader</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">ResourceLoader</span> <span class="n">resourceLoader</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">resourcePatternResolver</span> <span class="o">=</span> <span class="nc">ResourcePatternUtils</span><span class="o">.</span><span class="na">getResourcePatternResolver</span><span class="o">(</span><span class="n">resourceLoader</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CachingMetadataReaderFactory</span><span class="o">(</span><span class="n">resourceLoader</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">componentsIndex</span> <span class="o">=</span> <span class="nc">CandidateComponentsIndexLoader</span><span class="o">.</span><span class="na">loadIndex</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resourcePatternResolver</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">());</span>
<span class="o">}</span>

<span class="cm">/**
 * The location to look for components.
 * &lt;p&gt;Can be present in multiple JAR files.
 * 为了寻找组件的位置.可以出现在多个jar文件中
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">COMPONENTS_RESOURCE_LOCATION</span> <span class="o">=</span> <span class="s">"META-INF/spring.components"</span><span class="o">;</span>

<span class="cm">/**
 * Load and instantiate the {@link CandidateComponentsIndex} from
 * {@value #COMPONENTS_RESOURCE_LOCATION}, using the given class loader. If no
 * index is available, return {@code null}.
 * 使用给定的类加载器加载和实例化来自META-INF/spring.components的CandidateComponentsIndex.没有则返回null
 */</span>
<span class="nd">@Nullable</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">CandidateComponentsIndex</span> <span class="nf">loadIndex</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ClassLoader</span> <span class="n">classLoaderToUse</span> <span class="o">=</span> <span class="n">classLoader</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">classLoaderToUse</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">classLoaderToUse</span> <span class="o">=</span> <span class="nc">CandidateComponentsIndexLoader</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">//主要就是通过doLoadIndex这个方法 那这里我们其实也可以用于扩展</span>
    <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">classLoaderToUse</span><span class="o">,</span> <span class="nl">CandidateComponentsIndexLoader:</span><span class="o">:</span><span class="n">doLoadIndex</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">//这段代码就比较好理解了,尝试从META-INF/spring.components中读取配置,没有则返回,有则加载指定位置的文件,同时返回候选者的数量</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="nc">CandidateComponentsIndex</span> <span class="nf">doLoadIndex</span><span class="o">(</span><span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">shouldIgnoreIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Enumeration</span><span class="o">&lt;</span><span class="no">URL</span><span class="o">&gt;</span> <span class="n">urls</span> <span class="o">=</span> <span class="n">classLoader</span><span class="o">.</span><span class="na">getResources</span><span class="o">(</span><span class="no">COMPONENTS_RESOURCE_LOCATION</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">urls</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Properties</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">urls</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
            <span class="no">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="n">urls</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
            <span class="nc">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="nc">PropertiesLoaderUtils</span><span class="o">.</span><span class="na">loadProperties</span><span class="o">(</span><span class="k">new</span> <span class="nc">UrlResource</span><span class="o">(</span><span class="n">url</span><span class="o">));</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">properties</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Loaded "</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="s">"] index(es)"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">totalCount</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Properties:</span><span class="o">:</span><span class="n">size</span><span class="o">).</span><span class="na">sum</span><span class="o">();</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">totalCount</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="k">new</span> <span class="nc">CandidateComponentsIndex</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">:</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Unable to load indexes from location ["</span> <span class="o">+</span>
                <span class="no">COMPONENTS_RESOURCE_LOCATION</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>综上所述: <strong>ClassPathBeanDefinitionScanner</strong> 的作用就是扫描所有类路径下所有被@Component、@Repository、@Service、@Controller以及ManagedBean和Named注解的类,并将它们注册为bean定义.</p>
</blockquote>

<hr />

<h3 id="createapplicationcontext总结">createApplicationContext总结</h3>
<blockquote>
  <p>第四步主要就是创建AnnotationConfigServletWebServerApplicationContext上下文,在构造AnnotationConfigServletWebServerApplicationContext的同时又创建用于注册所有bean的AnnotatedBeanDefinitionReader和扫描所有指定注解类的ClassPathBeanDefinitionScanner.
其中AnnotatedBeanDefinitionReader又注册了多个后置处理器为后续做准备,最重要的就是ConfigurationClassPostProcessor.</p>
</blockquote>

<h3 id="组件扫描扩展">组件扫描扩展</h3>
<hr />
<p>背景:虽然类路径扫描速度非常快,但是可以通过在编译时创建一个静态候选列表来提高应用程序的启动性能.</p>

<p>首先需要先添加maven</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">dependencies</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">spring</span><span class="o">-</span><span class="n">context</span><span class="o">-</span><span class="n">indexer</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="mf">5.1</span><span class="o">.</span><span class="mi">8</span><span class="o">.</span><span class="na">RELEASE</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">optional</span><span class="o">&gt;</span><span class="kc">true</span><span class="o">&lt;/</span><span class="n">optional</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">dependencies</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>他的作用就是在编译过程中生成一个包含jar文件的META-INF/spring.components文件.此文件中就包含应用中所有以 <strong>@Component以及以@Component为元注解</strong> 的类.
如下图所示:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/spring.components示例.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="spring.components示例" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/spring.components示例.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">spring.components示例</div>
    </a>
</center>

<p>那我们可以这样使用:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">DemoApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="c1">//"META-INF/spring.components"</span>
    <span class="nc">CandidateComponentsIndex</span> <span class="n">candidateComponentsIndex</span> <span class="o">=</span> <span class="nc">CandidateComponentsIndexLoader</span><span class="o">.</span><span class="na">loadIndex</span><span class="o">(</span><span class="nc">DemoApplication</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">candidateComponentsIndex</span><span class="o">)){</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="n">candidateComponentsIndex</span><span class="o">.</span><span class="na">getCandidateTypes</span><span class="o">(</span><span class="s">"com.hcc.example"</span><span class="o">,</span> <span class="s">"org.springframework.stereotype.Component"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="nl">candidate:</span><span class="n">candidates</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"MyComponent"</span><span class="o">)){</span>
                <span class="nc">MyComponent</span> <span class="n">myComponent</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyComponent</span><span class="o">)</span><span class="n">context</span><span class="o">.</span><span class="na">getBeanFactory</span><span class="o">().</span><span class="na">getBean</span><span class="o">(</span><span class="s">"myComponent"</span><span class="o">);</span>
                <span class="n">myComponent</span><span class="o">.</span><span class="na">test</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>具体如果扩展就可以根据我们的需要进行了.<br />
当在类路径上找到META-INF/Spring.components时,索引将自动启用.如果某个索引部分可用于某些库(或用例),但无法为整个应用程序生成,则可以通过将spring.index.ignore设置为true(作为系统属性或类路径根目录下的spring.properties文件)来回滚到常规类路径安排(就像根本没有索引一样).</p>
<hr />
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">Septemper 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000003" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SpringBoot启动源码解析(三)</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-rachel-claire-5490361.jpg" class="img-responsive img-centered" alt="SpringBoot3">

                            
                                <h3>SpringBootApplication Run方法解析(一):prepareEnvironment</h3>
                            
                            </div>

                            <p><h3 id="run方法流程图">Run方法流程图</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/run流程图.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="run流程图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/run流程图.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">run流程图</div>
    </a>
</center>
<hr />

<h3 id="run方法入口主要分析prepareenvironment">Run方法入口:主要分析prepareEnvironment</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Run the Spring application, creating and refreshing a new
 * {@link ApplicationContext}.
 * 运行Spring应用，创建和刷新一个新的应用上下文
 * @param args the application arguments (usually passed from a Java main method)
 * @return a running {@link ApplicationContext}
 */</span>
<span class="kd">public</span> <span class="nc">ConfigurableApplicationContext</span> <span class="nf">run</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//1.创建启动计时器</span>
    <span class="nc">StopWatch</span> <span class="n">stopWatch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StopWatch</span><span class="o">();</span>
    <span class="n">stopWatch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="c1">//创建启动上下文并初始化相应的Bootstrapper 目前暂未使用</span>
    <span class="nc">ConfigurableApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SpringBootExceptionReporter</span><span class="o">&gt;</span> <span class="n">exceptionReporters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//设置系统的配置模式，一般用于服务端开发 默认为true</span>
    <span class="n">configureHeadlessProperty</span><span class="o">();</span>
    <span class="c1">//获取spring上下文启动监听者  从META-INF/spring.factories中获取SpringApplicationRunListener的实现类并加载</span>
    <span class="nc">SpringApplicationRunListeners</span> <span class="n">listeners</span> <span class="o">=</span> <span class="n">getRunListeners</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
    <span class="c1">//发布启动中事件</span>
    <span class="n">listeners</span><span class="o">.</span><span class="na">starting</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//2.创建默认上下文参数</span>
        <span class="nc">ApplicationArguments</span> <span class="n">applicationArguments</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultApplicationArguments</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
        <span class="c1">//3.准备环境，将资源属性添加到环境中并与上下文绑定</span>
        <span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span> <span class="o">=</span> <span class="n">prepareEnvironment</span><span class="o">(</span><span class="n">listeners</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
        <span class="c1">//设置spring.beaninfo.ignore中过滤的bean</span>
        <span class="n">configureIgnoreBeanInfo</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
        <span class="c1">//打印spring标记</span>
        <span class="nc">Banner</span> <span class="n">printedBanner</span> <span class="o">=</span> <span class="n">printBanner</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
        <span class="c1">//4.根据web应用类型创建指定的应用上下文</span>
        <span class="c1">//注意:这里反射创建AnnotationConfigServletWebServerApplicationContext时,构造中创建AnnotatedBeanDefinitionReader中的AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)方法很重要</span>
        <span class="c1">//它将几个常见的BeanPostProcessor和BeanFactoryPostProcessor注册到注册表中  最重要的是internalConfigurationAnnotationProcessor来解析Configuration的配置类</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">createApplicationContext</span><span class="o">();</span>
        <span class="n">exceptionReporters</span> <span class="o">=</span> <span class="n">getSpringFactoriesInstances</span><span class="o">(</span><span class="nc">SpringBootExceptionReporter</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
                <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">ConfigurableApplicationContext</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span> <span class="n">context</span><span class="o">);</span>
        <span class="c1">//5.准备上下文</span>
        <span class="c1">//主要做了两件事:</span>
        <span class="c1">// 1.调用前面实例化的ApplicationContextInitializer的initialize方式初始化上下文</span>
        <span class="c1">// 2.在其中的load方法中将启动主函数bean定义注册到注册表中 beanDefinitionMap</span>
        <span class="n">prepareContext</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">environment</span><span class="o">,</span> <span class="n">listeners</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">,</span> <span class="n">printedBanner</span><span class="o">);</span>
        <span class="c1">//6.刷新上下文</span>
        <span class="n">refreshContext</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="n">afterRefresh</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
        <span class="n">stopWatch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">logStartupInfo</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">StartupInfoLogger</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mainApplicationClass</span><span class="o">).</span><span class="na">logStarted</span><span class="o">(</span><span class="n">getApplicationLog</span><span class="o">(),</span> <span class="n">stopWatch</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//监听者发布已启动事件</span>
        <span class="n">listeners</span><span class="o">.</span><span class="na">started</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="c1">//7.调用所有的ApplicationRunner和CommandLineRunner的实现类</span>
        <span class="n">callRunners</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleRunFailure</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">exceptionReporters</span><span class="o">,</span> <span class="n">listeners</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//监听者发布运行中事件</span>
        <span class="n">listeners</span><span class="o">.</span><span class="na">running</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleRunFailure</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">exceptionReporters</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>本章我们主要分析 <strong>prepareEnvironment</strong> 及其之前的步骤.</p>
<ol>
  <li>第一步比较好理解,创建定时器统计启动时间,并获取的事件发布者 <strong>SpringApplicationRunListener</strong> 来发布启动过程中的各个事件,首先发布的就是 <strong>starting</strong> 事件.</li>
  <li>第二步创建应用参数,默认传入的是空集合</li>
  <li>第三步创建环境实例,首先看下 <strong>ConfigurableEnvironment</strong> 相关类图</li>
</ol>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/ConfigurableEnvironment.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="ConfigurableEnvironment" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/ConfigurableEnvironment.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">ConfigurableEnvironment</div>
    </a>
</center>

<ul>
  <li>PropertyResolver: 用于针对任何基础源解析属性的接口. 主要提供解析属性和获取属性的方法.</li>
  <li>ConfigurablePropertyResolver: 提供用于访问和自定义将属性值从一种类型转换为另一种类型时使用的ConversionService的设置.</li>
  <li>Environment: 应用中表明环境的接口,主要有两个属性: <strong>profile</strong> 和 <strong>properties</strong></li>
  <li>ConfigurableEnvironment: 继承自 <strong>ConfigurablePropertyResolver</strong> 和 <strong>Environment</strong> ,所以它提供了设置profile和操作底层属性的能力.</li>
  <li>StandardEnvironment: 继承自 <strong>AbstractEnvironment</strong> 不仅提供了 <strong>ConfigurableEnvironment</strong> 的能力还提供了设置 <strong>systemEnvironment</strong> 和 <strong>systemProperties</strong> 属性源的能力.</li>
  <li>StandardServletEnvironment: 主要用于 <strong>Servlet</strong> 应用的环境,默认基本都是它.</li>
  <li>StandardReactiveWebEnvironment: 主要用于 <strong>Reactive</strong> 应用的环境,SpringBoot中是空实现.</li>
</ul>

<p>相关类及其主要功能了解后,我们在回过头来看看这个 <strong>prepareEnvironment</strong> 方法:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">ConfigurableEnvironment</span> <span class="nf">prepareEnvironment</span><span class="o">(</span><span class="nc">SpringApplicationRunListeners</span> <span class="n">listeners</span><span class="o">,</span>
        <span class="nc">ApplicationArguments</span> <span class="n">applicationArguments</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Create and configure the environment</span>
    <span class="c1">//3.1根据当前应用类型创建并且配置environment 通常是StandardServletEnvironment</span>
    <span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span> <span class="o">=</span> <span class="n">getOrCreateEnvironment</span><span class="o">();</span>
    <span class="c1">//3.2为环境设置属性资源和配置文件</span>
    <span class="n">configureEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">,</span> <span class="n">applicationArguments</span><span class="o">.</span><span class="na">getSourceArgs</span><span class="o">());</span>
    <span class="c1">//3.3将已有属性以key为 configurationProperties的形式添加到属性中</span>
    <span class="nc">ConfigurationPropertySources</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="c1">//3.4发布环境准备完成通知</span>
    <span class="n">listeners</span><span class="o">.</span><span class="na">environmentPrepared</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="c1">//3.5将environmrnt绑定到应用中</span>
    <span class="n">bindToSpringApplication</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">isCustomEnvironment</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">environment</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EnvironmentConverter</span><span class="o">(</span><span class="n">getClassLoader</span><span class="o">()).</span><span class="na">convertEnvironmentIfNecessary</span><span class="o">(</span><span class="n">environment</span><span class="o">,</span>
                <span class="n">deduceEnvironmentClass</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">//3.6 再次将已有属性以key为 configurationProperties的形式添加到属性中</span>
    <span class="nc">ConfigurationPropertySources</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">environment</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>3.1 首先是创建并获取环境实例,源码如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">ConfigurableEnvironment</span> <span class="nf">getOrCreateEnvironment</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">switch</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">webApplicationType</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nl">SERVLET:</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">StandardServletEnvironment</span><span class="o">();</span>
    <span class="k">case</span> <span class="nl">REACTIVE:</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">StandardReactiveWebEnvironment</span><span class="o">();</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">StandardEnvironment</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因为我们当前应用类型是 <strong>Servlet</strong> ,所以我们需要对应就是创建 <strong>StandardServletEnvironment</strong> 实例.我们继续看下对应的构造方法:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//因为 StandardServletEnvironment extends StandardEnvironment 且 StandardEnvironment extends AbstractEnvironment</span>
<span class="c1">//我们看下父类AbstractEnvironment的构造</span>
<span class="cm">/**
 * Create a new {@code Environment} instance, calling back to
 * {@link #customizePropertySources(MutablePropertySources)} during construction to
 * allow subclasses to contribute or manipulate {@link PropertySource} instances as
 * appropriate.
 * 创建一个新的Environment实例, 在构造期间回调customizePropertySources方法以允许子类根据需要贡献或操作 PropertySource实例
 */</span>
<span class="kd">public</span> <span class="nf">AbstractEnvironment</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">customizePropertySources</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">propertySources</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">//StandardServletEnvironment中重写的customizePropertySourcesf方法</span>
<span class="cm">/** Servlet context init parameters property source name: {@value}. */</span>
<span class="c1">//Servlet上下文初始化参数属性源名称</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVLET_CONTEXT_PROPERTY_SOURCE_NAME</span> <span class="o">=</span> <span class="s">"servletContextInitParams"</span><span class="o">;</span>

<span class="cm">/** Servlet config init parameters property source name: {@value}. */</span>
<span class="c1">//Serlet配置初始化参数属性源名称</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVLET_CONFIG_PROPERTY_SOURCE_NAME</span> <span class="o">=</span> <span class="s">"servletConfigInitParams"</span><span class="o">;</span>

<span class="cm">/** JNDI property source name: {@value}. */</span>
<span class="c1">//JNDI属性源名称</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">JNDI_PROPERTY_SOURCE_NAME</span> <span class="o">=</span> <span class="s">"jndiProperties"</span><span class="o">;</span>

<span class="cm">/**
 * Customize the set of property sources with those contributed by superclasses as
 * well as those appropriate for standard servlet-based environments:
 * 使用超类提供的属性源以及适用于基于servlet的标准环境的属性源自定义一组属性源:
 * &lt;ul&gt;
 * &lt;li&gt;{@value #SERVLET_CONFIG_PROPERTY_SOURCE_NAME}
 * &lt;li&gt;{@value #SERVLET_CONTEXT_PROPERTY_SOURCE_NAME}
 * &lt;li&gt;{@value #JNDI_PROPERTY_SOURCE_NAME}
 * &lt;/ul&gt;
 */</span>
<span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">customizePropertySources</span><span class="o">(</span><span class="nc">MutablePropertySources</span> <span class="n">propertySources</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">propertySources</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">StubPropertySource</span><span class="o">(</span><span class="no">SERVLET_CONFIG_PROPERTY_SOURCE_NAME</span><span class="o">));</span>
    <span class="n">propertySources</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">StubPropertySource</span><span class="o">(</span><span class="no">SERVLET_CONTEXT_PROPERTY_SOURCE_NAME</span><span class="o">));</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">JndiLocatorDelegate</span><span class="o">.</span><span class="na">isDefaultJndiEnvironmentAvailable</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">propertySources</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">JndiPropertySource</span><span class="o">(</span><span class="no">JNDI_PROPERTY_SOURCE_NAME</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">customizePropertySources</span><span class="o">(</span><span class="n">propertySources</span><span class="o">);</span>
<span class="o">}</span>


<span class="c1">//StandardEnvironment中重写的customizePropertySources方法</span>
<span class="cm">/** System environment property source name: {@value}. */</span>
<span class="c1">//系统环境属性源名称</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME</span> <span class="o">=</span> <span class="s">"systemEnvironment"</span><span class="o">;</span>

<span class="cm">/** JVM system properties property source name: {@value}. */</span>
<span class="c1">//JVM系统属性源名称</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME</span> <span class="o">=</span> <span class="s">"systemProperties"</span><span class="o">;</span>

<span class="cm">/**
 * Customize the set of property sources with those appropriate for any standard
 * Java environment:
 * 使用适用于任何java标准环境的自定义属性源集合
 * &lt;ul&gt;
 * &lt;li&gt;{@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME}
 * &lt;li&gt;{@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}
 * &lt;/ul&gt;
 */</span>
<span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">customizePropertySources</span><span class="o">(</span><span class="nc">MutablePropertySources</span> <span class="n">propertySources</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">propertySources</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span>
            <span class="k">new</span> <span class="nf">PropertiesPropertySource</span><span class="o">(</span><span class="no">SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME</span><span class="o">,</span> <span class="n">getSystemProperties</span><span class="o">()));</span>
    <span class="n">propertySources</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span>
            <span class="k">new</span> <span class="nf">SystemEnvironmentPropertySource</span><span class="o">(</span><span class="no">SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME</span><span class="o">,</span> <span class="n">getSystemEnvironment</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>可见在创建 <strong>StandardServletEnvironment</strong> 实例时根据子类重写的 <strong>customizePropertySources</strong> 方法将 <strong>servletContextInitParams</strong> 、 <strong>servletConfigInitParams</strong> 、<strong>systemEnvironment</strong> 和 <strong>systemProperties</strong> 四种属性添加到环境实例中.</p>

<p>3.2 设置环境属性资源和配置文件,源码如下</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Template method delegating to
 * {@link #configurePropertySources(ConfigurableEnvironment, String[])} and
 * {@link #configureProfiles(ConfigurableEnvironment, String[])} in that order.
 * Override this method for complete control over Environment customization, or one of
 * the above for fine-grained control over property sources or profiles, respectively.
 * 按照configurePropertySources和configureProfiles的顺序委托给他们的模板方法.
 * 覆盖此方法以完全控制环境自定义,或上述方法之一以分别对属性源或配置文件进行细粒度控制
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configureEnvironment</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//添加类型装换服务</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">addConversionService</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//使用双层检查创建类型转换服务单例</span>
        <span class="nc">ConversionService</span> <span class="n">conversionService</span> <span class="o">=</span> <span class="nc">ApplicationConversionService</span><span class="o">.</span><span class="na">getSharedInstance</span><span class="o">();</span>
        <span class="n">environment</span><span class="o">.</span><span class="na">setConversionService</span><span class="o">((</span><span class="nc">ConfigurableConversionService</span><span class="o">)</span> <span class="n">conversionService</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//配置属性源</span>
    <span class="n">configurePropertySources</span><span class="o">(</span><span class="n">environment</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="c1">//配置配置文件</span>
    <span class="n">configureProfiles</span><span class="o">(</span><span class="n">environment</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Return a shared default application {@code ConversionService} instance, lazily
 * building it once needed.
 * 使用懒加载的方式创建并返回一个共享的默认应用转换实例
 * 双重检查锁
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ConversionService</span> <span class="nf">getSharedInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">ApplicationConversionService</span> <span class="n">sharedInstance</span> <span class="o">=</span> <span class="nc">ApplicationConversionService</span><span class="o">.</span><span class="na">sharedInstance</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sharedInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">ApplicationConversionService</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sharedInstance</span> <span class="o">=</span> <span class="nc">ApplicationConversionService</span><span class="o">.</span><span class="na">sharedInstance</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sharedInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sharedInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ApplicationConversionService</span><span class="o">();</span>
                <span class="nc">ApplicationConversionService</span><span class="o">.</span><span class="na">sharedInstance</span> <span class="o">=</span> <span class="n">sharedInstance</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sharedInstance</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
 * Add, remove or re-order any {@link PropertySource}s in this application's
 * environment.
 * 在应用环境中 添加、删除或重排序任何 PropertySources
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configurePropertySources</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//获取当前环境实例已有的属性源</span>
    <span class="nc">MutablePropertySources</span> <span class="n">sources</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="na">getPropertySources</span><span class="o">();</span>
    <span class="c1">//若存在defaultProperties且不为空则添加到当前环境实例中  默认为空 直接跳过</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">defaultProperties</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">defaultProperties</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">sources</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">MapPropertySource</span><span class="o">(</span><span class="s">"defaultProperties"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">defaultProperties</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="c1">//是否打开添加命令行属性  且 存在输入的参数  默认无入参 直接跳过</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">addCommandLineProperties</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">CommandLinePropertySource</span><span class="o">.</span><span class="na">COMMAND_LINE_PROPERTY_SOURCE_NAME</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sources</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">PropertySource</span><span class="o">&lt;?&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="nc">CompositePropertySource</span> <span class="n">composite</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CompositePropertySource</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="n">composite</span><span class="o">.</span><span class="na">addPropertySource</span><span class="o">(</span>
                    <span class="k">new</span> <span class="nf">SimpleCommandLinePropertySource</span><span class="o">(</span><span class="s">"springApplicationCommandLineArgs"</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
            <span class="n">composite</span><span class="o">.</span><span class="na">addPropertySource</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
            <span class="n">sources</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">composite</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">sources</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="k">new</span> <span class="nc">SimpleCommandLinePropertySource</span><span class="o">(</span><span class="n">args</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Configure which profiles are active (or active by default) for this application
 * environment. Additional profiles may be activated during configuration file
 * processing via the {@code spring.profiles.active} property.
 * 为该应用程序配置哪些配置文件是活动的(默认是活动的).
 * 在配置文件处理期间可以通过spring.profiles.active属性来激活其他配置文件
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configureProfiles</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//默认additionalProfiles 为空</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">profiles</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">.</span><span class="na">additionalProfiles</span><span class="o">);</span>
    <span class="n">profiles</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">environment</span><span class="o">.</span><span class="na">getActiveProfiles</span><span class="o">()));</span>
    <span class="n">environment</span><span class="o">.</span><span class="na">setActiveProfiles</span><span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">toStringArray</span><span class="o">(</span><span class="n">profiles</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>由上可见,第二步主要就是为环境实例添加转换服务 <strong>conversionService</strong> 、检查是否需要配置默认属性源和是否需要根据命令行参数配置、设置profiles.</p>

<p>3.3 第三步的源码如下:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * The name of the {@link PropertySource} {@link #attach(Environment) adapter}.
 * 属性源适配器的名称
 */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">ATTACHED_PROPERTY_SOURCE_NAME</span> <span class="o">=</span> <span class="s">"configurationProperties"</span><span class="o">;</span>

<span class="cm">/**
 * Attach a {@link ConfigurationPropertySource} support to the specified
 * {@link Environment}. Adapts each {@link PropertySource} managed by the environment
 * to a {@link ConfigurationPropertySource} and allows classic
 * {@link PropertySourcesPropertyResolver} calls to resolve using
 * {@link ConfigurationPropertyName configuration property names}.
 * 将ConfigurationPropertySource支持附加到指定的环境中.
 * 使由环境管理的每个PropertySource适应ConfigurationPropertySource, 并允许经典的PropertySourcesPropertyResolver调用使用名称解析
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">attach</span><span class="o">(</span><span class="nc">Environment</span> <span class="n">environment</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">environment</span><span class="o">);</span>
    <span class="c1">//判断当前环境实例中 是否存在configurationProperties属性源</span>
    <span class="c1">//若存在且环境中属性源不等于他本身,则清除configurationProperties属性源, 并将configurationProperties属性源再次添加到sources中</span>
    <span class="c1">//如果不存在的话直接直接将configurationProperties属性源添加到sources中</span>
    <span class="nc">MutablePropertySources</span> <span class="n">sources</span> <span class="o">=</span> <span class="o">((</span><span class="nc">ConfigurableEnvironment</span><span class="o">)</span> <span class="n">environment</span><span class="o">).</span><span class="na">getPropertySources</span><span class="o">();</span>
    <span class="nc">PropertySource</span><span class="o">&lt;?&gt;</span> <span class="n">attached</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">ATTACHED_PROPERTY_SOURCE_NAME</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">attached</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">attached</span><span class="o">.</span><span class="na">getSource</span><span class="o">()</span> <span class="o">!=</span> <span class="n">sources</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sources</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="no">ATTACHED_PROPERTY_SOURCE_NAME</span><span class="o">);</span>
        <span class="n">attached</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">attached</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sources</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="k">new</span> <span class="nc">ConfigurationPropertySourcesPropertySource</span><span class="o">(</span><span class="no">ATTACHED_PROPERTY_SOURCE_NAME</span><span class="o">,</span>
                <span class="k">new</span> <span class="nf">SpringConfigurationPropertySources</span><span class="o">(</span><span class="n">sources</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>由上可见,第三步的主要作用就是为 <strong>Environment</strong> 实例配置 <strong>configurationProperties</strong> 属性源,为后面的绑定到 <strong>SpringApplication</strong> 而准备.</p>

<p>3.4 第四步就是发布环境准备就绪事件,这里有个监听器比较重要: <strong>ConfigFileApplicationListener</strong> ,我们来看下源码</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered {</span>
<span class="c1">//先看下它的类关系, 它实现自EnvironmentPostProcessor, 即它重写的postProcessEnvironment方法</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onApplicationEvent</span><span class="o">(</span><span class="nc">ApplicationEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//当前发布的事件属于ApplicationEnvironmentPreparedEvent 继续往下周</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">event</span> <span class="k">instanceof</span> <span class="nc">ApplicationEnvironmentPreparedEvent</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">onApplicationEnvironmentPreparedEvent</span><span class="o">((</span><span class="nc">ApplicationEnvironmentPreparedEvent</span><span class="o">)</span> <span class="n">event</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">event</span> <span class="k">instanceof</span> <span class="nc">ApplicationPreparedEvent</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">onApplicationPreparedEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//可见获取的是/META-INF/spring.factories中的所有EnvironmentPostProcessor的实现类, 所以此类ConfigFileApplicationListener也在其中</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">EnvironmentPostProcessor</span><span class="o">&gt;</span> <span class="nf">loadPostProcessors</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">SpringFactoriesLoader</span><span class="o">.</span><span class="na">loadFactories</span><span class="o">(</span><span class="nc">EnvironmentPostProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">onApplicationEnvironmentPreparedEvent</span><span class="o">(</span><span class="nc">ApplicationEnvironmentPreparedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//这段就比较好理解了就是使用所有EnvironmentPostProcessor的后置处理器来处理环境实例</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">EnvironmentPostProcessor</span><span class="o">&gt;</span> <span class="n">postProcessors</span> <span class="o">=</span> <span class="n">loadPostProcessors</span><span class="o">();</span>
    <span class="n">postProcessors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="nc">AnnotationAwareOrderComparator</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">postProcessors</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">EnvironmentPostProcessor</span> <span class="n">postProcessor</span> <span class="o">:</span> <span class="n">postProcessors</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">postProcessor</span><span class="o">.</span><span class="na">postProcessEnvironment</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getEnvironment</span><span class="o">(),</span> <span class="n">event</span><span class="o">.</span><span class="na">getSpringApplication</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//具体后置处理器逻辑 其中最重要的就是加载了application.properties属性源</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postProcessEnvironment</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">,</span> <span class="nc">SpringApplication</span> <span class="n">application</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">addPropertySources</span><span class="o">(</span><span class="n">environment</span><span class="o">,</span> <span class="n">application</span><span class="o">.</span><span class="na">getResourceLoader</span><span class="o">());</span>
<span class="o">}</span>

<span class="cm">/**
 * Add config file property sources to the specified environment.
 * 添加配置文件属性源到指定的环境实例中 其实这里就加载了random和applcation.properties两个属性源
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">addPropertySources</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">,</span> <span class="nc">ResourceLoader</span> <span class="n">resourceLoader</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//添加random属性源</span>
    <span class="nc">RandomValuePropertySource</span><span class="o">.</span><span class="na">addToEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="c1">//创建Loader加载器并加载属性</span>
    <span class="k">new</span> <span class="nf">Loader</span><span class="o">(</span><span class="n">environment</span><span class="o">,</span> <span class="n">resourceLoader</span><span class="o">).</span><span class="na">load</span><span class="o">();</span>
<span class="o">}</span>

<span class="nc">Loader</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">,</span> <span class="nc">ResourceLoader</span> <span class="n">resourceLoader</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">=</span> <span class="n">environment</span><span class="o">;</span>
    <span class="c1">//创建属性解析器 解析 ${}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">placeholdersResolver</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PropertySourcesPlaceholdersResolver</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span> <span class="o">=</span> <span class="o">(</span><span class="n">resourceLoader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">resourceLoader</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">DefaultResourceLoader</span><span class="o">();</span>
    <span class="c1">//这里最重要,加载/META-INF/spring.factories中的PropertySourceLoader的实现类</span>
    <span class="c1">//默认是org.springframework.boot.env.PropertiesPropertySourceLoader,org.springframework.boot.env.YamlPropertySourceLoader 其实就是我们应用种配置的 .properties和 .yml配置文件</span>
    <span class="k">this</span><span class="o">.</span><span class="na">propertySourceLoaders</span> <span class="o">=</span> <span class="nc">SpringFactoriesLoader</span><span class="o">.</span><span class="na">loadFactories</span><span class="o">(</span><span class="nc">PropertySourceLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
            <span class="n">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">//再来看下真正的load方法</span>
<span class="kt">void</span> <span class="nf">load</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">FilteredPropertySource</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span> <span class="no">DEFAULT_PROPERTIES</span><span class="o">,</span> <span class="no">LOAD_FILTERED_PROPERTY</span><span class="o">,</span>
            <span class="o">(</span><span class="n">defaultProperties</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">profiles</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
                <span class="k">this</span><span class="o">.</span><span class="na">processedProfiles</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
                <span class="k">this</span><span class="o">.</span><span class="na">activatedProfiles</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">this</span><span class="o">.</span><span class="na">loaded</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                <span class="c1">//初始化Profiles 默认初始化 active-profiles 和 spring.profiles.* 包含的所有profile</span>
                <span class="n">initializeProfiles</span><span class="o">();</span>
                <span class="c1">//解析所有的profiles 这里至少有两个 null和default</span>
                <span class="k">while</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">profiles</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="nc">Profile</span> <span class="n">profile</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">profiles</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">isDefaultProfile</span><span class="o">(</span><span class="n">profile</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">addProfileToEnvironment</span><span class="o">(</span><span class="n">profile</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
                    <span class="o">}</span>
                    <span class="c1">//根据指定的profile加载资源 第一次解析null 第二次解析default</span>
                    <span class="n">load</span><span class="o">(</span><span class="n">profile</span><span class="o">,</span> <span class="k">this</span><span class="o">::</span><span class="n">getPositiveProfileFilter</span><span class="o">,</span>
                            <span class="n">addToLoaded</span><span class="o">(</span><span class="nl">MutablePropertySources:</span><span class="o">:</span><span class="n">addLast</span><span class="o">,</span> <span class="kc">false</span><span class="o">));</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">processedProfiles</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">profile</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">load</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="k">this</span><span class="o">::</span><span class="n">getNegativeProfileFilter</span><span class="o">,</span> <span class="n">addToLoaded</span><span class="o">(</span><span class="nl">MutablePropertySources:</span><span class="o">:</span><span class="n">addFirst</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
                <span class="c1">//将加载过的资源添加到环境中</span>
                <span class="n">addLoadedPropertySources</span><span class="o">();</span>
                <span class="c1">//应用激活的profiles</span>
                <span class="n">applyActiveProfiles</span><span class="o">(</span><span class="n">defaultProperties</span><span class="o">);</span>
            <span class="o">});</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">load</span><span class="o">(</span><span class="nc">Profile</span> <span class="n">profile</span><span class="o">,</span> <span class="nc">DocumentFilterFactory</span> <span class="n">filterFactory</span><span class="o">,</span> <span class="nc">DocumentConsumer</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//getSearchLocations()是获取搜索路径,默认是这个四个classpath:/,classpath:/config/,file:./,file:./config/</span>
    <span class="n">getSearchLocations</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">location</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">//判断是否文件夹</span>
        <span class="kt">boolean</span> <span class="n">isFolder</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="n">isFolder</span> <span class="o">?</span> <span class="n">getSearchNames</span><span class="o">()</span> <span class="o">:</span> <span class="no">NO_SEARCH_NAMES</span><span class="o">;</span>
        <span class="c1">//具体的加载动作</span>
        <span class="n">names</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">name</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">load</span><span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">profile</span><span class="o">,</span> <span class="n">filterFactory</span><span class="o">,</span> <span class="n">consumer</span><span class="o">));</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">load</span><span class="o">(</span><span class="nc">String</span> <span class="n">location</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Profile</span> <span class="n">profile</span><span class="o">,</span> <span class="nc">DocumentFilterFactory</span> <span class="n">filterFactory</span><span class="o">,</span>
            <span class="nc">DocumentConsumer</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasText</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">PropertySourceLoader</span> <span class="n">loader</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">propertySourceLoaders</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">canLoadFileExtension</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">location</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">load</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">location</span><span class="o">,</span> <span class="n">profile</span><span class="o">,</span> <span class="n">filterFactory</span><span class="o">.</span><span class="na">getDocumentFilter</span><span class="o">(</span><span class="n">profile</span><span class="o">),</span> <span class="n">consumer</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"File extension of config file location '"</span> <span class="o">+</span> <span class="n">location</span>
                    <span class="o">+</span> <span class="s">"' is not known to any PropertySourceLoader. If the location is meant to reference "</span>
                    <span class="o">+</span> <span class="s">"a directory, it must end in '/'"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">processed</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//这里的propertySourceLoaders就是前面加载的 PropertiesPropertySourceLoader和YamlPropertySourceLoader两个解析器</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">PropertySourceLoader</span> <span class="n">loader</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">propertySourceLoaders</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//每个解析器都有自己的文件后缀并解析</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">fileExtension</span> <span class="o">:</span> <span class="n">loader</span><span class="o">.</span><span class="na">getFileExtensions</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">processed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">fileExtension</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">//获得具体路径后在解析成properties 下面就不继续往下看了</span>
                    <span class="n">loadForFileExtension</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">location</span> <span class="o">+</span> <span class="n">name</span><span class="o">,</span> <span class="s">"."</span> <span class="o">+</span> <span class="n">fileExtension</span><span class="o">,</span> <span class="n">profile</span><span class="o">,</span> <span class="n">filterFactory</span><span class="o">,</span>
                            <span class="n">consumer</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>可见第四步通过发布环境准备就绪事件,所有的监听器中,最终要的就是 <strong>ConfigFileApplicationListener</strong>,通过 <strong>ConfigFileApplicationListener</strong> 来执行所有环境相关的后置处理器, 他自己本身实现了 <strong>EnvironmentPostProcessor</strong> ,通过 <strong>postProcessEnvironment</strong> 来调用 <strong>addPropertySources</strong> 方法通过 <strong>Loader</strong> 来加载配置文件属性源.
在构造 <strong>Loader</strong> 中初始化 <strong>PropertySourceLoader</strong> 的两个实现类 <strong>PropertiesPropertySourceLoader</strong> 和 <strong>YamlPropertySourceLoader</strong> 来加载 <strong>“properties”,”xml”</strong> 和 <strong>“yml”,”yaml”__的配置文件,主要通过 __getFileExtensions()</strong> 方法指定的文件扩展名分别拼接默认路径 <strong>classpath:/,classpath:/config/,file:./,file:./config/</strong> ,找到存在的路径则进行解析属性.</p>

<p>3.5 第五步将环境绑定到当前应用中</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Bind the environment to the {@link SpringApplication}.
 * 将环境实例绑定到应用中
 */</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">bindToSpringApplication</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//首先看这个Binder.get(environment):根据给定环境实例创建Binder</span>
        <span class="nc">Binder</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">environment</span><span class="o">).</span><span class="na">bind</span><span class="o">(</span><span class="s">"spring.main"</span><span class="o">,</span> <span class="nc">Bindable</span><span class="o">.</span><span class="na">ofInstance</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Cannot bind to SpringApplication"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Binder</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Environment</span> <span class="n">environment</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">environment</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Binder</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Environment</span> <span class="n">environment</span><span class="o">,</span> <span class="nc">BindHandler</span> <span class="n">defaultBindHandler</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//获取前面通过attach附加到环境实例中的ConfigurationPropertySource</span>
    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">ConfigurationPropertySource</span><span class="o">&gt;</span> <span class="n">sources</span> <span class="o">=</span> <span class="nc">ConfigurationPropertySources</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="c1">//根据环境创建属性源占位符解析器 即解析 ${}</span>
    <span class="nc">PropertySourcesPlaceholdersResolver</span> <span class="n">placeholdersResolver</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PropertySourcesPlaceholdersResolver</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
    <span class="c1">//创建Binder</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Binder</span><span class="o">(</span><span class="n">sources</span><span class="o">,</span> <span class="n">placeholdersResolver</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">defaultBindHandler</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Return a set of {@link ConfigurationPropertySource} instances that have previously
 * been {@link #attach(Environment) attached} to the {@link Environment}.
 * 返回之前通过attached附加到环境实例中的ConfigurationPropertySource集合
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">ConfigurationPropertySource</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Environment</span> <span class="n">environment</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">ConfigurableEnvironment</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">environment</span><span class="o">);</span>
    <span class="nc">MutablePropertySources</span> <span class="n">sources</span> <span class="o">=</span> <span class="o">((</span><span class="nc">ConfigurableEnvironment</span><span class="o">)</span> <span class="n">environment</span><span class="o">).</span><span class="na">getPropertySources</span><span class="o">();</span>
    <span class="nc">ConfigurationPropertySourcesPropertySource</span> <span class="n">attached</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ConfigurationPropertySourcesPropertySource</span><span class="o">)</span> <span class="n">sources</span>
            <span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">ATTACHED_PROPERTY_SOURCE_NAME</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">attached</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">from</span><span class="o">(</span><span class="n">sources</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">attached</span><span class="o">.</span><span class="na">getSource</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">//通过其中的PropertyPlaceholderHelper</span>
<span class="kd">public</span> <span class="nf">PropertySourcesPlaceholdersResolver</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">PropertySource</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">sources</span><span class="o">,</span> <span class="nc">PropertyPlaceholderHelper</span> <span class="n">helper</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">sources</span> <span class="o">=</span> <span class="n">sources</span><span class="o">;</span>
    <span class="c1">//创建PropertyPlaceholderHelper来解析 ${}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">helper</span> <span class="o">=</span> <span class="o">(</span><span class="n">helper</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">helper</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">PropertyPlaceholderHelper</span><span class="o">(</span><span class="nc">SystemPropertyUtils</span><span class="o">.</span><span class="na">PLACEHOLDER_PREFIX</span><span class="o">,</span>
            <span class="nc">SystemPropertyUtils</span><span class="o">.</span><span class="na">PLACEHOLDER_SUFFIX</span><span class="o">,</span> <span class="nc">SystemPropertyUtils</span><span class="o">.</span><span class="na">VALUE_SEPARATOR</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Create a new {@link Binder} instance for the specified sources.
 * 通过指定的资源中创建一个新的Binder实例
 */</span>
<span class="kd">public</span> <span class="nf">Binder</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">ConfigurationPropertySource</span><span class="o">&gt;</span> <span class="n">sources</span><span class="o">,</span> <span class="nc">PlaceholdersResolver</span> <span class="n">placeholdersResolver</span><span class="o">,</span>
        <span class="nc">ConversionService</span> <span class="n">conversionService</span><span class="o">,</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">PropertyEditorRegistry</span><span class="o">&gt;</span> <span class="n">propertyEditorInitializer</span><span class="o">,</span>
        <span class="nc">BindHandler</span> <span class="n">defaultBindHandler</span><span class="o">,</span> <span class="nc">BindConstructorProvider</span> <span class="n">constructorProvider</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">sources</span><span class="o">,</span> <span class="s">"Sources must not be null"</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">sources</span> <span class="o">=</span> <span class="n">sources</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">placeholdersResolver</span> <span class="o">=</span> <span class="o">(</span><span class="n">placeholdersResolver</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">placeholdersResolver</span> <span class="o">:</span> <span class="nc">PlaceholdersResolver</span><span class="o">.</span><span class="na">NONE</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">conversionService</span> <span class="o">=</span> <span class="o">(</span><span class="n">conversionService</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">conversionService</span>
            <span class="o">:</span> <span class="nc">ApplicationConversionService</span><span class="o">.</span><span class="na">getSharedInstance</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">propertyEditorInitializer</span> <span class="o">=</span> <span class="n">propertyEditorInitializer</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">defaultBindHandler</span> <span class="o">=</span> <span class="o">(</span><span class="n">defaultBindHandler</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">defaultBindHandler</span> <span class="o">:</span> <span class="nc">BindHandler</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">constructorProvider</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">constructorProvider</span> <span class="o">=</span> <span class="nc">BindConstructorProvider</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">ValueObjectBinder</span> <span class="n">valueObjectBinder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ValueObjectBinder</span><span class="o">(</span><span class="n">constructorProvider</span><span class="o">);</span>
    <span class="nc">JavaBeanBinder</span> <span class="n">javaBeanBinder</span> <span class="o">=</span> <span class="nc">JavaBeanBinder</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">dataObjectBinders</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableList</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">valueObjectBinder</span><span class="o">,</span> <span class="n">javaBeanBinder</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">//具体绑定代码不贴了,嵌套层数太深后期有时间在详细分析</span>
</code></pre></div></div>
<p>可见第五步就是使用3.3新加入的 <strong>configurationProperties</strong> 属性源和 <strong>${}</strong> 占位符解析器 <strong>PropertySourcesPlaceholdersResolver</strong> 来创建 <strong>Binder</strong> .
最后在通过 <strong>Binder</strong> 来将 <strong>“spring.main”</strong> 封装的 <strong>ConfigurationProperty</strong> 和主函数 <strong>SpringApplication</strong> 进行绑定.</p>

<p>3.6 最后一步是再次将已有属性以key为 configurationProperties的形式添加到属性中</p>
<hr />

<h3 id="prepareenvironment总结">prepareEnvironment总结</h3>
<blockquote>
  <p>prepareEnvironment的作用就是将创建 Environment实例,并将各种属性资源添加到Environment中其中包括configurationProperties、servletConfigInitParams、servletContextInitParams、systemProperties、systemEnvironment、以及最重要的applicationConfig: [classpath:/application.properties],最后在通过Environment创建Binder将”spring.main”的属性源与应用SpringApplicaiton进行绑定.</p>
</blockquote>

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">September 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000002" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SpringBoot启动源码解析(二)</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-irina-iriser-1122625.jpg" class="img-responsive img-centered" alt="SpringBoot2">

                            
                                <h3>SpringBootApplication构造方法分析</h3>
                            
                            </div>

                            <p><h3 id="主函数流程图">主函数流程图</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/SpringApplication构造流程图.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="SpringApplication构造流程图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/SpringApplication构造流程图.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">SpringApplication构造流程图</div>
    </a>
</center>
<hr />
<h3 id="主函数入口">主函数入口</h3>
<hr />
<p>我们首先从主函数入口一步一步往下看.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//程序主函数</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">DemoApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Static helper that can be used to run a {@link SpringApplication} from the
 * specified source using default settings.
 * 用于在一个使用默认配置的指定资源中运行 SpringApplication 的静态工具类
 * @param primarySource the primary source to load
 * @param args the application arguments (usually passed from a Java main method)
 * @return the running {@link ApplicationContext}
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ConfigurableApplicationContext</span> <span class="nf">run</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">primarySource</span><span class="o">,</span> <span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">run</span><span class="o">(</span><span class="k">new</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="o">{</span> <span class="n">primarySource</span> <span class="o">},</span> <span class="n">args</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * Static helper that can be used to run a {@link SpringApplication} from the
 * specified sources using default settings and user supplied arguments.
 * @param primarySources the primary sources to load
 * @param args the application arguments (usually passed from a Java main method)
 * @return the running {@link ApplicationContext}
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ConfigurableApplicationContext</span> <span class="nf">run</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">primarySources</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">SpringApplication</span><span class="o">(</span><span class="n">primarySources</span><span class="o">).</span><span class="na">run</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>核心就是 <strong>new SpringApplication(primarySources).run(args)</strong> 这一行.<br />
我们首先分析一下  <strong>new SpringApplication(primarySources)</strong>.</p>

<h3 id="new-springapplicationprimarysources主构造">new SpringApplication(primarySources)主构造</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Create a new {@link SpringApplication} instance. The application context will load
 * beans from the specified primary sources (see {@link SpringApplication class-level}
 * documentation for details. The instance can be customized before calling
 * {@link #run(String...)}.
 * 创建一个SpringApplication实例. 应用上下文将从指定主函数中加载bean. (这个实例可以在调用run方法前自定义)
 * @param resourceLoader the resource loader to use
 * @param primarySources the primary bean sources
 * @see #run(Class, String[])
 * @see #setSources(Set)
 */</span>
<span class="nd">@SuppressWarnings</span><span class="o">({</span> <span class="s">"unchecked"</span><span class="o">,</span> <span class="s">"rawtypes"</span> <span class="o">})</span>
<span class="kd">public</span> <span class="nf">SpringApplication</span><span class="o">(</span><span class="nc">ResourceLoader</span> <span class="n">resourceLoader</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;...</span> <span class="n">primarySources</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//1.设置类加载器</span>
    <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span> <span class="o">=</span> <span class="n">resourceLoader</span><span class="o">;</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">primarySources</span><span class="o">,</span> <span class="s">"PrimarySources must not be null"</span><span class="o">);</span>
    <span class="c1">//2.将主函数封装成集合设置到primarySources中 可以设置多个主类</span>
    <span class="k">this</span><span class="o">.</span><span class="na">primarySources</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">primarySources</span><span class="o">));</span>
    <span class="c1">//3.判断当前应用类型 通常使用的都是WebApplicationType.SERVLET</span>
    <span class="k">this</span><span class="o">.</span><span class="na">webApplicationType</span> <span class="o">=</span> <span class="nc">WebApplicationType</span><span class="o">.</span><span class="na">deduceFromClasspath</span><span class="o">();</span>
    <span class="c1">//4.获取并实例化所有的ApplicationContextInitializer实现 主要用于在上下文刷新前进行初始化上下文</span>
    <span class="n">setInitializers</span><span class="o">((</span><span class="nc">Collection</span><span class="o">)</span> <span class="n">getSpringFactoriesInstances</span><span class="o">(</span><span class="nc">ApplicationContextInitializer</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="c1">//5.获取并实例化所有的ApplicationListener实现 主要用于监听启动过程中发布的各种事件</span>
    <span class="n">setListeners</span><span class="o">((</span><span class="nc">Collection</span><span class="o">)</span> <span class="n">getSpringFactoriesInstances</span><span class="o">(</span><span class="nc">ApplicationListener</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="c1">//6.生成main对应主函数的类</span>
    <span class="k">this</span><span class="o">.</span><span class="na">mainApplicationClass</span> <span class="o">=</span> <span class="n">deduceMainApplicationClass</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在SpringApplication构造函数中,最重要就是步骤4和步骤5,再看下这两步其实是一样的实现,只不过加载的类不同而已.<br />
我们再仔细看看这个方法到底做了什么事情:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">getSpringFactoriesInstances</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">parameterTypes</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ClassLoader</span> <span class="n">classLoader</span> <span class="o">=</span> <span class="n">getClassLoader</span><span class="o">();</span>
    <span class="c1">// Use names and ensure unique to protect against duplicates</span>
    <span class="c1">//获取指定类型的实现类名称集合</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="nc">SpringFactoriesLoader</span><span class="o">.</span><span class="na">loadFactoryNames</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">classLoader</span><span class="o">));</span>
    <span class="c1">//实例化上面找到的所有实现类</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">instances</span> <span class="o">=</span> <span class="n">createSpringFactoriesInstances</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">parameterTypes</span><span class="o">,</span> <span class="n">classLoader</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">names</span><span class="o">);</span>
    <span class="c1">//根据实例的order进行排序</span>
    <span class="nc">AnnotationAwareOrderComparator</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">instances</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">instances</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>此方法主要做的就是找到指定类型的实现类并将这些类都进行实例化.我们再来看看它是如何找到这个类的.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Load the fully qualified class names of factory implementations of the
 * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given
 * class loader.
 * 使用给定的类加载器,从 META-INF/spring.factories中加载给定类型的工厂实现的完全限定名
 * @param factoryType the interface or abstract class representing the factory
 * @param classLoader the ClassLoader to use for loading resources; can be
 * {@code null} to use the default
 * @throws IllegalArgumentException if an error occurs while loading factory names
 * @see #loadFactories
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">loadFactoryNames</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">factoryType</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">factoryTypeName</span> <span class="o">=</span> <span class="n">factoryType</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
    <span class="k">return</span> <span class="nf">loadSpringFactories</span><span class="o">(</span><span class="n">classLoader</span><span class="o">).</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">factoryTypeName</span><span class="o">,</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">());</span>
<span class="o">}</span>

<span class="cm">/**
 * The location to look for factories.
 * 用于查询工厂的位置
 * &lt;p&gt;Can be present in multiple JAR files.
 * 可以存在于多个jar文件中
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">FACTORIES_RESOURCE_LOCATION</span> <span class="o">=</span> <span class="s">"META-INF/spring.factories"</span><span class="o">;</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">loadSpringFactories</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//首先尝试从缓存中读取,因为该方法执行结束后会将配置文件中所有的信息放到缓存中,如果缓存中有直接返回</span>
    <span class="nc">MultiValueMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">classLoader</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//读取项目中所有存在 META-INF/spring.factories的URL</span>
        <span class="nc">Enumeration</span><span class="o">&lt;</span><span class="no">URL</span><span class="o">&gt;</span> <span class="n">urls</span> <span class="o">=</span> <span class="o">(</span><span class="n">classLoader</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span>
                <span class="n">classLoader</span><span class="o">.</span><span class="na">getResources</span><span class="o">(</span><span class="no">FACTORIES_RESOURCE_LOCATION</span><span class="o">)</span> <span class="o">:</span>
                <span class="nc">ClassLoader</span><span class="o">.</span><span class="na">getSystemResources</span><span class="o">(</span><span class="no">FACTORIES_RESOURCE_LOCATION</span><span class="o">));</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedMultiValueMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//读取每一个URL并将属性以K-V的形式保存到Properties中, 再将所有属性保存在result中</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">urls</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
            <span class="no">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="n">urls</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
            <span class="nc">UrlResource</span> <span class="n">resource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UrlResource</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
            <span class="nc">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="nc">PropertiesLoaderUtils</span><span class="o">.</span><span class="na">loadProperties</span><span class="o">(</span><span class="n">resource</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,</span> <span class="o">?&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">properties</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">factoryTypeName</span> <span class="o">=</span> <span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()).</span><span class="na">trim</span><span class="o">();</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">factoryImplementationName</span> <span class="o">:</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">commaDelimitedListToStringArray</span><span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()))</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">factoryTypeName</span><span class="o">,</span> <span class="n">factoryImplementationName</span><span class="o">.</span><span class="na">trim</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//将result保存到缓存中</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">classLoader</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Unable to load factories from location ["</span> <span class="o">+</span>
                <span class="no">FACTORIES_RESOURCE_LOCATION</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>通过代码分析发现, <strong>loadSpringFactories</strong> 的主要作用就是读取所有 <strong>META-INF/spring.factories</strong> 中的所有配置信息并保存到缓存中, 并返回指定类型的集合.<br />
现在我们已经找到指定类的所有实现类了,接下来我们就应该实例化它们.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">createSpringFactoriesInstances</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">parameterTypes</span><span class="o">,</span>
        <span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">instances</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">names</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//加载每一个class类</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">instanceClass</span> <span class="o">=</span> <span class="nc">ClassUtils</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">classLoader</span><span class="o">);</span>
            <span class="nc">Assert</span><span class="o">.</span><span class="na">isAssignable</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">instanceClass</span><span class="o">);</span>
            <span class="nc">Constructor</span><span class="o">&lt;?&gt;</span> <span class="n">constructor</span> <span class="o">=</span> <span class="n">instanceClass</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="n">parameterTypes</span><span class="o">);</span>
            <span class="c1">//使用反射构造该类实例 通常采用默认构造</span>
            <span class="no">T</span> <span class="n">instance</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="nc">BeanUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">constructor</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
            <span class="n">instances</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Cannot instantiate "</span> <span class="o">+</span> <span class="n">type</span> <span class="o">+</span> <span class="s">" : "</span> <span class="o">+</span> <span class="n">name</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">instances</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果你经常使用反射的话,这段代码就比较容易理解了,无非就是使用反射创建类实例.</p>

<h3 id="总结">总结</h3>
<hr />
<p>由上可知,在 <strong>SpringApplication</strong> 构造中主要是做了设置主函数资源、判断当前应用类型和加载并实例化所有 <strong>ApplicationContextInitializer</strong> 和 <strong>ApplicationListener</strong> 的实现类.</p>
<hr />

<h3 id="扩展">扩展</h3>
<hr />
<p>主要就是针对 <strong>ApplicationListener</strong> 和 <strong>ApplicationContextInitializer</strong> 进行扩展.两者扩展类似,那我就以 <strong>ApplicationListener</strong> 为例.</p>

<p>1.第一步肯定是自己创建一个测试类 <strong>MyApplicationListener</strong> 实现 <strong>ApplicationListener</strong> ,这里需要注意下我们需要指定需要监听的事件类型,主要类图见下<br />
2.第二步就是实现需要重写的接口,在接口中添加自己的实现,我们就简单打一行日志</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/MyApplicationListener.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="MyApplicationListener" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/MyApplicationListener.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">MyApplicationListener</div>
    </a>
</center>

<p>3.第三步也就是最重要的一步,你想想我们现在已经自己新建了类,但是应用还是无法找你的类,那么我们就应该让应用扫描到新类,这样才能在调用的时候调用我们自己重写的方法.<br />
那么就需要我们在 <strong>resources</strong> 目录下新建 <strong>META-INF/spring.factories</strong> 文件,并在该文件中指定你的实现类,这样就能让应用加载到你的类</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/spring.factories.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="spring.factories" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/spring.factories.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">spring.factories</div>
    </a>
</center>

<hr />
<p><strong>ApplicationEvent</strong> 对应子类类图如下:</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/ApplicationEvent.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="ApplicationEvent" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/ApplicationEvent.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">ApplicationEvent</div>
    </a>
</center>

<h3 id="spi机制">SPI机制</h3>
<hr />
<h4 id="概念">概念</h4>
<hr />
<p>其实上面的加载过程就是SPI机制,SpringBoot加以改造了一下.<br />
SPI的全名为 Service Provider Interface, 目的是提供接口,让第三方提供自定义实现的服务功能.目前不少框架使用它来做服务的扩展.</p>
<hr />

<h4 id="实现">实现</h4>
<hr />
<p>1.自定义已经接口以及其实现类</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/spi基类.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="spi基类" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/spi基类.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">spi基类</div>
    </a>
</center>

<p>2.在 <strong>META-INF/services</strong> 目录中创建以接口全限定名命名的文件,文件内容为接口具体实现的全限定名</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/services.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="META-INF/services" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/services.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">META-INF/services</div>
    </a>
</center>

<p>3.使用 __ServiceLoader.load(Class<T>)__ 类动态加载目录下的实现类</T></p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/main.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="main" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/main.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">main</div>
    </a>
</center>

<p>4.具体实现类必须有一个不带参数的构造方法</p>

<hr />

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">September 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000010" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>BinarySearch</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-victoria-borodinova-9201864.jpg" class="img-responsive img-centered" alt="BinarySearch">

                            
                                <h3>二分查找</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />
<p>二分查找也称为折半查找,它是一种效率较高的查找方法.但是它要求是线性表必须采用顺序存储结构,而且表中的元素是有序的.</p>
<hr />

<h3 id="思路">思路</h3>
<hr />
<p>例如:查找 <strong>nums</strong> 有序数组中, <strong>target</strong> 在nums中的位置</p>
<ol>
  <li>首先定义左右指针 <strong>left=0</strong> 和 <strong>right=nums.length-1</strong></li>
  <li>遍历数组,退出条件为 <strong>left&lt;=right</strong></li>
  <li>找到中间位置 <strong>mid=left+(right-left)/2</strong> ,此时 <strong>nums[0…mid-1]</strong> 的值都小于 <strong>nums[mid]</strong> , <strong>nums[mid+1…len]</strong> 的值都大于 <strong>nums[mid]</strong></li>
  <li>比较中间位置的值 <strong>nums[mid]</strong> 和 <strong>target</strong> 的值,有三种情况:
    <ul>
      <li>若 <strong>nums[mid]=target</strong> ,直接返回 <strong>mid</strong></li>
      <li>若 <strong>nums[mid]&lt;target</strong> ,中间值小于目标值,那么接下来应该在区间 <strong>[mid+1,len]</strong> 中查找,即 <strong>left=mid+1</strong></li>
      <li>若 <strong>nums[mid]&gt;target</strong> ,中间值大于目标值,那么接下来应该在区间 <strong>[0,mid-1]</strong> 中查找,即 <strong>right=mid-1</strong></li>
    </ul>
  </li>
  <li>若按步骤4没有找到,说明数组中不存在等于 <strong>target</strong> 的索引
    <hr />
  </li>
</ol>

<h3 id="遍历图解">遍历图解</h3>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearch/二分查找.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二分查找" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearch/二分查找.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">二分查找</div>
    </a>
</center>

<h3 id="代码">代码</h3>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(logn)<br />
空间复杂度为:O(1)</p>
</blockquote>

<h3 id="扩展">扩展</h3>
<hr />
<p>正常遇到的二分查找一般不会这么简单.我们还需要了解一些二分查找的扩展.<br />
例如给定的数组中有多个重复元素,那么我们如何找出给定 <strong>target</strong> 的最左或最右索引位置.<br />
整体逻辑同二分查找类似, 不同点在于:</p>
<ol>
  <li>退出循环条件, <strong>left&lt;right</strong></li>
  <li>当 <strong>nums[mid]&gt;target</strong> ,直接将 <strong>mid</strong> 赋值给 <strong>right</strong></li>
  <li>当 <strong>nums[mid]==target</strong> 时,有两种情况:
    <ul>
      <li>若取最左位置,则继续向左搜索,即限制右指针, <strong>right=mid</strong></li>
      <li>若取最右位置,则继续向右搜索,即限制左指针, <strong>left=mid+1</strong></li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>java代码</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearchLeft</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearchRight</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">?</span> <span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="o">:-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">public:</span>
	<span class="kt">int</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">==</span><span class="n">target</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="err">}</span><span class="p">;</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span><span class="nb">int</span><span class="p">:</span>
    <span class="n">left</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">right</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span><span class="o">+</span><span class="p">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">==</span><span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span><span class="p">:</span>
            <span class="n">right</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">left</span><span class="o">:=</span><span class="m">0</span>
	<span class="n">right</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="m">1</span>
	<span class="k">for</span> <span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">:=</span><span class="n">left</span><span class="o">+</span><span class="p">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="p">)</span><span class="o">/</span><span class="m">2</span>
		<span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">==</span><span class="n">target</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">mid</span>
		<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span> <span class="p">{</span>
			<span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="m">1</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="m">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Search</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000011" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>BinarySearchTree</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-julia-volk-5273316.jpg" class="img-responsive img-centered" alt="BinarySearchTree">

                            
                                <h3>二叉查找树</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />
<p>二叉查找树(BinarySearchTree,简称BST)又称为二叉排序树(BinarySortTree).<br />
一棵二叉查找树是一棵二叉树,其中每个节点都含有一个 <strong>Comparable</strong> 的键(以及相关联的值)且每个节点的键都大于等于其左子树中的任意节点而小于右子树的任意节点.</p>
<hr />

<h3 id="基本实现">基本实现</h3>
<hr />
<ol>
  <li>
    <p>数据表示</p>

    <p>和链表一样,我们嵌套定义了一个所有类来表示二叉查找树上的一个节点.每个节点都含有一个键、一个值、一条左链接、一条右链接和一个节点计数器.左链接指向一棵由小于该节点的所有键组成的二叉树,右链接指向一棵由大于该节点的所有键组成的二叉查找树.变量 <strong>N</strong> 给出了以该节点为根的子树的节点总数.<br />
 一棵二叉查找树代表了一组键(及其相应的值)的集合,而同一个集合可以用多棵不同的二叉查找树表示.如果我们将一棵二叉查找树的所有键投影到一条直线上,保证一个节点的左子树中的键出现在它的左边,右子树中的键出现在它的右边,那么我们一定可以得到一条有序的键列.</p>
    <center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/两棵能够表示同一组键的二叉查找树.png">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="两棵能够表示同一组键的二叉查找树" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/两棵能够表示同一组键的二叉查找树.png" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
     display: inline-block;
     color: #999;
     padding: 2px;">两棵能够表示同一组键的二叉查找树</div>
     </a>
 </center>
  </li>
  <li>
    <p>查找 <br />
 在二叉查找树中查找一个键的递归算法:如果树是空的,则查找未命中;如果被查找的键和根节点的键相等,则查找命中,否则我们就递归的在适当的子树中继续查找.如果被查找的键较小就选择左子树,较大则选择右子树.</p>

    <center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树中的查找命中(左)和未命中(右).png">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉查找树中的查找命中(左)和未命中(右)" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树中的查找命中(左)和未命中(右).png" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
     display: inline-block;
     color: #999;
     padding: 2px;">二叉查找树中的查找命中(左)和未命中(右)</div>
     </a>
 </center>
  </li>
  <li>
    <p>插入 <br />
 如果树是空的,就返回一个含有该键值对的新节点;如果被查找的键小于根节点的键,会继续在左子树中插入该键,否则在右子树中插入该键.</p>

    <center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树的插入操作.png">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉查找树的插入操作" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树的插入操作.png" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
     display: inline-block;
     color: #999;
     padding: 2px;">二叉查找树的插入操作</div>
     </a>
 </center>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BST</span><span class="o">&lt;</span><span class="nc">Key</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;,</span> <span class="nc">Value</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">{</span>
        <span class="kd">private</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Value</span> <span class="n">value</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Node</span> <span class="n">left</span><span class="o">,</span><span class="n">right</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="no">N</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">=</span><span class="n">value</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="no">N</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nf">size</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">N</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Value</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">){</span>
        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Value</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span><span class="nc">Key</span> <span class="n">key</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">value</span><span class="o">){</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">value</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />
<h3 id="分析">分析</h3>
<hr />
<p>使用二叉查找树的算法运行时间取决于树的形状,而树的形状取决于键被插入的先后顺序.在最好的情况下,一棵含有 <strong>N</strong> 个节点的树是完全平衡的,每条空链接和根节点的距离都为 <strong>lgN</strong> .在最坏的情况下,搜索路径上可能有 <strong>N</strong> 个节点.</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树的可能形状.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉查找树的可能形状" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树的可能形状.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">二叉查找树的可能形状</div>
    </a>
</center>
<hr />

<h3 id="有序性相关的方法与删除操作">有序性相关的方法与删除操作</h3>
<hr />
<p>二叉查找树得以广泛应用的一个重要原因就是它能够保持键的有序性,因此它可以作为实现有序符号表API中众多方法的基础.</p>

<ol>
  <li>
    <p>最大键和最小键<br />
 最小键:如果根节点的左链接为空,那么一棵二叉查找树中最小的键就是根节点;如果左链接非空,那么树中最小键就是左子树中的最小键.见下方min()方法的递归实现<br />
 最大键:如果根节点的右链接为空,那么一棵二叉查找树中最大的键就是根节点;如果右链接非空,那么树中最大键就是右子树中的最大键.见下方max()方法的递归实现</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">min</span><span class="o">()</span>
 <span class="o">{</span>
     <span class="k">return</span> <span class="nf">min</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">key</span><span class="o">;</span>
 <span class="o">}</span>
    
 <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">min</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span>
 <span class="o">{</span>
     <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
     <span class="k">return</span> <span class="nf">min</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
 <span class="o">}</span>
    
 <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">max</span><span class="o">()</span>
 <span class="o">{</span>
     <span class="k">return</span> <span class="nf">max</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">key</span><span class="o">;</span>
 <span class="o">}</span>
    
 <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span>
 <span class="o">{</span>
     <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
     <span class="k">return</span> <span class="nf">max</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>向上取整和向下取整<br />
 向下取整: 如果给定的键 <strong>key</strong> 小于二叉查找树的根节点的键,那么小于等于 <strong>key</strong> 的最大键 <strong>floor(key)</strong> 一定在根节点的左子树中;如果给定的键 <strong>key</strong> 大于二叉查找树的根节点,那么只有当根节点右子树中存在小于等于 <strong>key</strong> 的节点时,小于等于 <strong>key</strong> 的最大键才会出现在右子树中,否则根节点就是小于等于 <strong>key</strong> 的最大键.<br />
 向上取整: 将向下取整中的 左变为右(同时将小于变为大于)就能得到 <strong>ceiling()</strong> 的算法.</p>

    <center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/向下取整图解.png">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="向下取整图解" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/向下取整图解.png" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
     display: inline-block;
     color: #999;
     padding: 2px;">向下取整图解</div>
     </a>
 </center>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">floor</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span>
 <span class="o">{</span>
     <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">floor</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
     <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
 <span class="o">}</span>
    
 <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">floor</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span>
 <span class="o">{</span>
     <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
     <span class="k">if</span><span class="o">(</span><span class="n">cmp</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
     <span class="k">if</span><span class="o">(</span><span class="n">cmp</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">floot</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
     <span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">floot</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
     <span class="k">if</span><span class="o">(</span><span class="n">t</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
         <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
     <span class="o">}</span><span class="k">else</span><span class="o">{</span>
         <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
     <span class="o">}</span> 
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>选择操作<br />
 在二叉查找树的每个节点中维护的子树节点计数器变量N就是用来支持此操作的.<br />
 假设我们想找到排名为k的键(即树中正好有k个小于它的键).有如下三种情况:
    <ul>
      <li>如果左子树中的节点数t大于k,那么我们就继续递归在左子树中查找排名为k的键;</li>
      <li>如果t等于k,就返回根节点中的键;</li>
      <li>如果t小于k,就递归的在右子树中查找排名为 <strong>k-t-1</strong> 的键.</li>
    </ul>

    <center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树中的select()操作.png">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉查找树中的select()操作" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树中的select()操作.png" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
     display: inline-block;
     color: #999;
     padding: 2px;">二叉查找树中的select()操作</div>
     </a>
 </center>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">select</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
     <span class="k">return</span> <span class="nf">select</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">k</span><span class="o">).</span><span class="na">key</span><span class="o">;</span>
 <span class="o">}</span>
    
 <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">select</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
     <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
     <span class="k">if</span><span class="o">(</span><span class="n">t</span><span class="o">&gt;</span><span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="n">select</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
     <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">t</span><span class="o">&lt;</span><span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="n">select</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">k</span><span class="o">-</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
     <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>排名<br />
 rank()是select()的逆方法,它会返回给定键的排名.它的实现和select()类似.<br />
 如果给定的键和根节点的键相等,我们返回左子树中的节点总数t;<br />
 如果给定的键小于根节点,我们会返回该键在左子树中的排名;<br />
 如果给定的键大于根节点,我们会返回t+1(根节点)加上它在右子树中的排名.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rank</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
     <span class="k">return</span> <span class="nf">rank</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
 <span class="o">}</span>
    
 <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rank</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
     <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
     <span class="k">if</span><span class="o">(</span><span class="n">cmp</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">rank</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
     <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">k</span><span class="o">)+</span><span class="n">rank</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
     <span class="k">else</span> <span class="k">return</span> <span class="nf">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>删除最大键和删除最小键<br />
 我们要不断深入根节点的左子树直到遇到一个空链接,然后将指向该节点的连接指向该节点的右子树(只需要在递归调用中返回它的右链接即可).<br />
 此时已经没有任何链接指向要被删除的节点,因此它会被垃圾收集器清理掉.然后在更新它到根节点的路径上所有计数器的值.<br />
 deleteMax()方法的实现和deleteMin()完全类似.</p>

    <center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/删除二叉查找树中的最小结点.png">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="删除二叉查找树中的最小结点" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/删除二叉查找树中的最小结点.png" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
     display: inline-block;
     color: #999;
     padding: 2px;">删除二叉查找树中的最小结点</div>
     </a>
 </center>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMin</span><span class="o">(){</span>
     <span class="n">root</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">deleteMin</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">){</span>
     <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
     <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
     <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)+</span><span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>
     <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>删除操作<br />
 我们可以用类似的方式删除任意只有一个子节点或者没有子节点的节点,但应该如何删除一个拥有两个子节点的节点呢?<br />
 删除之后我们要处理两棵子树,但被删除节点的父节点只有一条空出来的链接.<br />
 在删除节点x后用它的后继节点填补它的位置.因为x有一个右节点,因此它的后继节点就是其右子树的最小节点.这样的替换仍然能够保证树的有序性,因为x.key和它的后继节点的键之间不存在其他的键.<br />
 我们能够用4个简单的步骤完成将x替换为它的后继节点的任务.
    <ul>
      <li>将指向即将被删除的节点的链接保存为t</li>
      <li>将x指向它的后继节点 <strong>min(t.right)</strong></li>
      <li>将x的右链接(原本指向一棵所有节点都大于x.key的二叉查找树)指向 <strong>deleteMin(t.right)</strong> ,也就是在删除后所有节点仍然大于x.key的子二叉查找树</li>
      <li>将x的左链接(本为空)设为t.left(其下所有的键都小于被删除节点和它的后继节点)</li>
    </ul>

    <center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树中的删除操作.png">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉查找树中的删除操作" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树中的删除操作.png" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
     display: inline-block;
     color: #999;
     padding: 2px;">二叉查找树中的删除操作</div>
     </a>
 </center>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">){</span>
     <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
 <span class="o">}</span>
    
 <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">){</span>
     <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
     <span class="k">if</span><span class="o">(</span><span class="n">cmp</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
     <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
     <span class="k">else</span><span class="o">{</span>
         <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
         <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
         <span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
         <span class="n">x</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
         <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
         <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)+</span><span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>
     <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>范围查找</p>

    <p>首先需要一个遍历二叉查找树的基本方法,叫做中序遍历.即左-&gt;根-&gt;右。
 使用队列Queue,将所有落在给定范围内的键加入一个队列Queue并跳过那些不可能含有所查找键的子树.<br />
 为了确保以给定节点为根的子树中所有在指定范围内的键加入队列,我们会递归地查找根节点的左子树,然后查找根节点,然后递归地查找根节点的右子树.</p>

    <center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树的范围查找.png">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉查找树的范围查找" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/二叉查找树的范围查找.png" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
     display: inline-block;
     color: #999;
     padding: 2px;">二叉查找树的范围查找</div>
     </a>
 </center>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">(){</span>
     <span class="k">return</span> <span class="nf">keys</span><span class="o">(</span><span class="n">min</span><span class="o">(),</span> <span class="n">max</span><span class="o">());</span>
 <span class="o">}</span>
    
 <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">(</span><span class="nc">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">hi</span><span class="o">){</span>
     <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;();</span>
     <span class="n">keys</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
     <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
 <span class="o">}</span>
    
 <span class="kd">private</span> <span class="kt">void</span> <span class="nf">keys</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">hi</span><span class="o">){</span>
     <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">cmplo</span> <span class="o">=</span> <span class="n">lo</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
     <span class="kt">int</span> <span class="n">cmphi</span> <span class="o">=</span> <span class="n">hi</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
     <span class="k">if</span><span class="o">(</span><span class="n">cmp</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">keys</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
     <span class="k">if</span><span class="o">(</span><span class="n">cmplo</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span><span class="n">cmphi</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
     <span class="k">if</span><span class="o">(</span><span class="n">cmphi</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">keys</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   - - -
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="总结">总结</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/简单的符号表实现的成本总结.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="简单的符号表实现的成本总结" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binarySearchTree/简单的符号表实现的成本总结.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">简单的符号表实现的成本总结</div>
    </a>
</center>
<hr />
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Tree</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">September 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000009" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>BinaryTree</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-karina-zhukovskaya-7260333.jpg" class="img-responsive img-centered" alt="binaryTree">

                            
                                <h3>二叉树基本概念</h3>
                            
                            </div>

                            <p><h3 id="定义">定义</h3>
<hr />
<p>二叉树是指树中节点的度不大于2的有序树,他是一种最简单且最重要的树.二叉树的递归定义为:二叉树是一棵空树,或者是一棵由一个根节点和两棵互不相交的,分别称作根的左子树和右子树组成的非空树;左子树和右子树又同样都是二叉树.</p>
<hr />

<h3 id="相关术语">相关术语</h3>
<hr />
<ol>
  <li>节点:包含一个数据元素及若干指向子树分支的信息</li>
  <li>节点的度:一个节点拥有子树的数目称为节点的度</li>
  <li>叶子节点:也成为终端节点,没有子树的节点或者度为零的节点</li>
  <li>分支节点:也称为非终端节点,度不为零的节点称为非终端节点</li>
  <li>树的度:树中所有节点的度的最大值</li>
  <li>节点的层次:从根节点开始,假设根节点为第1层,根节点的子节点为第2层,以此类推,如果第一个节点位于第L层,则其子节点位于第L+1层</li>
  <li>树的深度:也称为树的高度,树中所有节点的层次最大值称为树的深度</li>
  <li>有序树:如果树中各棵树的次序是有先后次序的,则称该树为有序树</li>
  <li>无序树:如果树中各棵子树的次序没有先后次序,则称该树为无序树</li>
  <li>森林:由m(m&gt;=0)棵互不相交的树构成一片森林.如果把一棵非空的树的根节点删除,则该树就变成了一片森林,森林中的树由原来根节点的各棵子树构成</li>
</ol>

<hr />
<h3 id="常见的树类型">常见的树类型</h3>
<hr />
<ol>
  <li>满二叉树:如果一棵二叉树只有度为0的节点和度为2的节点,并且度为0的节点在同一层上,则这棵二叉树为满二叉树</li>
  <li>完全二叉树:深度为k,有n个节点的二叉树当且仅当其每一个节点都与深度为k的满二叉树中编号从1到n的节点一一对应时,称为完全二叉树</li>
</ol>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/相关二叉树图解.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="相关二叉树图解" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/相关二叉树图解.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">相关二叉树图解</div>
    </a>
</center>

<h3 id="二叉树性质">二叉树性质</h3>
<hr />
<ol>
  <li>二叉树的第 <strong>i</strong> 层上最多有 <strong>2^i-1</strong> (i&gt;=1)个节点</li>
  <li>深度为 <strong>h</strong> 的二叉树中至多含有 <strong>2^h -1</strong> 个节点</li>
  <li>若在任意一棵二叉树中,有 <strong>n0</strong> 个叶子节点,有 <strong>n2</strong> 个度为2的节点,则必有 <strong>n0=n2+1</strong></li>
  <li>具有 <strong>n</strong> 个节点的完全二叉树深为 <strong>log2x+1</strong></li>
  <li>若对一棵有 <strong>n</strong> 个节点的完全二叉树进行顺序编号(1&lt;=i&lt;=n),那么对于编号为 <strong>i</strong> (i&gt;=1)的节点:
    <ul>
      <li>当 <strong>i=1</strong> 时,该节点为根,它无双亲节点</li>
      <li>当 <strong>i&gt;1</strong> 时,该节点的双亲节点的编号为 <strong>i/2</strong></li>
      <li>若 <strong>2i&lt;=n</strong> ,则有编号为 <strong>2i</strong> 的左节点,否则没有左节点</li>
      <li>若 <strong>2i+1&lt;=n</strong> ,则有编号为 <strong>2i+1</strong> 的右节点,否则没有右节点</li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="二叉树的存储方式">二叉树的存储方式</h3>
<hr />
<p>一般我们使用TreeNode对象来表示一个节点, <strong>val</strong> 代表该节点额值, <strong>left</strong> 代表该节点的左子节点, <strong>right</strong> 代表该节点的右子节点</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">TreeNode</span> <span class="n">left</span><span class="o">;</span>
    <span class="nc">TreeNode</span> <span class="n">right</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="二叉树的遍历方式">二叉树的遍历方式</h3>
<hr />
<p>二叉树可以使用深度优先遍历(DFS)或广度优先遍历(BFS).<br />
深度优先遍历又可以分为先序遍历、中序遍历、后序遍历三种方式.每种方式只是访问节点的顺序不同.</p>
<ul>
  <li>先序遍历:根节点-&gt;左子节点-&gt;右子节点</li>
  <li>中序遍历:左子节点-&gt;根节点-&gt;右子节点</li>
  <li>后序遍历:左子节点-&gt;右子节点-&gt;根节点
深度优先遍历又可以分为递归和迭代两种方法，递归使用的是虚拟机栈，而迭代则使用的是显示声明的栈。</li>
</ul>

<p>广度优先遍历又被称为层序遍历,即按照二叉树的每一层进行遍历</p>

<p><strong>特殊性质</strong> :二叉搜索树采用中序遍历,其实就是一个有序数组.</p>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/二叉树的遍历.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉树的遍历" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/二叉树的遍历.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">二叉树的遍历</div>
    </a>
</center>

<h3 id="遍历图解">遍历图解</h3>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/二叉树遍历图解.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉树遍历图解" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/二叉树遍历图解.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">二叉树遍历图解</div>
    </a>
</center>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/二叉树先序遍历迭代流程.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉树先序遍历迭代流程" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/二叉树先序遍历迭代流程.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">二叉树先序遍历迭代流程</div>
    </a>
</center>

<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/二叉树后序遍历迭代流程.png">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="二叉树后序遍历迭代流程" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/binaryTree/二叉树后序遍历迭代流程.png" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">二叉树后序遍历迭代流程</div>
    </a>
</center>

<h3 id="代码">代码</h3>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="c1">//递归</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
        <span class="c1">//1.先序遍历</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="c1">//一直遍历左节点  直到左节点为空</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="c1">//2.中序遍历</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="c1">//当某一节点的左节点遍历结束后开始遍历右节点,重复上述遍历过程</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="c1">//3.后序遍历</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 先序、中序遍历  迭代的方式 使用栈
 * @param root
 * @return
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">preOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="c1">//当前节点一直向左遍历,直到没有左节点</span>
        <span class="k">while</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//先序遍历</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//弹出最近的左节点</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="c1">//中序遍历</span>
<span class="c1">//      res.add(root.val);</span>
        <span class="c1">//即左节点遍历完开始遍历右节点</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
 * 后序遍历 迭代方式
 * @param root
 * @return
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">postOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//用于记录上一次遍历的节点,保证右节点遍历完后可以回到根节点</span>
    <span class="nc">TreeNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
        <span class="c1">//一直向左遍历直到没有节点</span>
        <span class="k">while</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//弹出最近遍历的节点</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="c1">//若当前节点的右节点为null(说明此节点是子节点无须继续遍历) 或 当前的节点的右节点指向pre节点(说明刚遍历完右子节点回到了根节点)</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">pre</span><span class="o">){</span>
            <span class="c1">//将值加入集合中,并将当前节点赋值给pre节点说明已经遍历过了,并置为null，方便后续继续弹出他的根节点遍历</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="c1">//若不满足上面两种情况说明右节点还没到头，压栈继续遍历右节点</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">){</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="nc">TreeNode</span> <span class="n">poll</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">poll</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">poll</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">poll</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">poll</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">poll</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>DFS时间复杂度:O(logn)  BFS时间复杂度:O(n)<br />
空间复杂度都为:O(1)</p>
</blockquote>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sort</span><span class="p">(</span><span class="k">struct</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">//1.先序遍历</span>
			<span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
			<span class="c1">//2.中序遍历</span>
			<span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
			<span class="c1">//3.后序遍历</span>
			<span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sortBFS</span><span class="p">(</span><span class="k">struct</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">queue</span><span class="p">;</span>
		<span class="n">queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">TreeNode</span><span class="o">*</span> <span class="n">pop</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
				<span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
				<span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pop</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pop</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pop</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pop</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span><span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">:</span><span class="n">TreeNode</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="c1">#1.先序遍历
</span>                <span class="c1">#res.append(node.val)
</span>                <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="c1">#2.中序遍历
</span>                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="c1">#3.后序遍历
</span>                <span class="c1">#res.append(node.val)
</span>        <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">traverseBSF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">:</span><span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">temp</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">temp</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">traverse</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="c">//1.先序遍历</span>
			<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
			<span class="c">//2.中序遍历</span>
			<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
			<span class="c">//3.后序遍历</span>
			<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BFS</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="n">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="n">TreeNode</span> <span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="n">queue</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="o">!=</span><span class="m">0</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">:=</span> <span class="n">queue</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
		<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">temp</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">temp</span><span class="o">.</span><span class="n">Left</span><span class="o">!=</span><span class="no">nil</span> <span class="p">{</span>
			<span class="n">queue</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">temp</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">temp</span><span class="o">.</span><span class="n">Right</span><span class="o">!=</span><span class="no">nil</span> <span class="p">{</span>
			<span class="n">queue</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">temp</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Sort</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000008" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>RadixSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-roman-odintsov-5327786.jpg" class="img-responsive img-centered" alt="radixSort">

                            
                                <h3>基数排序</h3>
                            
                            </div>

                            <p><h3 id="前置概念">前置概念</h3>
<hr />

<p>最高位优先(Most Significant Digit First)</p>
<ul>
  <li>简称MSD法,先按 <strong>k1</strong> 排序分组,同一组中记录,关键码 <strong>k1</strong> 相等,再对各组按 <strong>k2</strong> 排序分成子组,之后,对后面的关键码继续这样的排序分组,直到按最次位关键码 <strong>kd</strong> 对各子组排序后,再将各组连接起来,便得到一个有序序列.</li>
</ul>

<p>最低位优先(Least Significant Digit First)</p>
<ul>
  <li>简称LSD法,先从 <strong>kd</strong> 开始排序,再对 <strong>kd-1</strong> 进行排序,依次重复,直到对 <strong>k1</strong> 排序后便得到一个有序序列</li>
</ul>

<hr />

<h3 id="基本思想">基本思想</h3>
<hr />
<p>基数排序又称为桶排序(bucket sort).他是通过键值的部分信息,将要排序的元素分配到某些桶中,再从从小到大的桶中取出数据放回到原数组中,直到所有情况的桶都排序完成后,整个数组有序.</p>
<hr />

<h3 id="思路">思路</h3>
<hr />
<p>以最低位优先为例:</p>
<ol>
  <li>首先将给定的nums根据个位数的数值,将他们分配值编号0到9的桶中,使用temp来记录第 <strong>i</strong> 号桶内存放的nums元素,使用order来记录第 <strong>i</strong> 号桶内有多少个元素</li>
  <li>接着将temp中的元素按照桶从0到9的顺序在放回数组nums中,并记得重置对应的order值</li>
  <li>最后将位数不断上升,重复以上步骤,最高位处理完即数组有序
    <hr />
  </li>
</ol>

<h3 id="图解">图解</h3>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/radixSort/基数排序.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="基数排序" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/radixSort/基数排序.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">RadixSort</div>
    </a>
</center>

<h3 id="代码">代码</h3>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">radixSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">){</span>
    <span class="c1">//每次排序使用的索引</span>
    <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="c1">//表明取的第几位数</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
    <span class="c1">//表明当前正在排序第几位数</span>
    <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

    <span class="c1">//temp i存放0-9 j存放对应的值</span>
    <span class="c1">//例如 给定 nums[20] 那么 temp[0][1] = 20</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">][</span><span class="n">len</span><span class="o">];</span>
    <span class="c1">//存放0-9每个位置有多少个值 用于temp找到nums中的元素</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>

    <span class="c1">//m从1开始一直处理到d</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">m</span><span class="o">&lt;=</span><span class="n">d</span><span class="o">){</span>
        <span class="c1">//首轮遍历 填充temp和order</span>
        <span class="c1">//1. 首先先计算出最低位 lsd</span>
        <span class="c1">//2. 然后根据lsd的值将nums填充到temp指定的位置,并将order对应lsd位置加一</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">lsd</span> <span class="o">=</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]/</span><span class="n">n</span><span class="o">)%</span><span class="mi">10</span><span class="o">;</span>
            <span class="n">temp</span><span class="o">[</span><span class="n">lsd</span><span class="o">][</span><span class="n">order</span><span class="o">[</span><span class="n">lsd</span><span class="o">]++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">//经过第一轮遍历 我们已经按照lsd将数组赋值到 temp中, 接下来进行排序</span>
        <span class="c1">//因为数字最多就是9位,所以第二轮遍历就是从0-9</span>
        <span class="c1">//只要order[i]还存在元素,即order[i]!=0, 那么我们就要遍历order[i],从temp中取到对应值即temp[i][j],并赋值到原始数组nums中. 最后要把order[i]置为0即尾数为i的全都处理完毕</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">order</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">order</span><span class="o">[</span><span class="n">i</span><span class="o">];</span><span class="n">j</span><span class="o">++){</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">order</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//最后重置 k为0,即下次排序继续从0开始</span>
        <span class="c1">//n=n*10 表明取下一位数 个位-十位-百位</span>
        <span class="c1">//m+=1 表明处理到了第几位</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="mi">10</span><span class="o">;</span>
        <span class="n">m</span><span class="o">+=</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(NlogN)</p>

  <p>空间复杂度:O(1)</p>
</blockquote>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">radixSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">temp</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">len</span><span class="p">));</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">order</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">&lt;=</span><span class="n">d</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="kt">int</span> <span class="n">lsd</span> <span class="o">=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
				<span class="n">temp</span><span class="p">[</span><span class="n">lsd</span><span class="p">][</span><span class="n">order</span><span class="p">[</span><span class="n">lsd</span><span class="p">]</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
					<span class="p">{</span>
						<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">m</span><span class="o">++</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">radixSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">length</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span>

        <span class="k">while</span> <span class="n">m</span><span class="o">&lt;=</span><span class="n">d</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">length</span><span class="p">):</span>
                <span class="n">lsd</span>  <span class="o">=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">//</span><span class="n">n</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">lsd</span><span class="p">][</span><span class="n">order</span><span class="p">[</span><span class="n">lsd</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">order</span><span class="p">[</span><span class="n">lsd</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                        <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">m</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">n</span><span class="o">*=</span><span class="mi">10</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">radixSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">d</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="n">k</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="m">1</span>
	<span class="n">m</span> <span class="o">:=</span> <span class="m">1</span>
	<span class="nb">len</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="n">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">temp</span><span class="p">{</span>
		<span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>
	<span class="p">}</span>
	
	<span class="n">order</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">m</span><span class="o">&lt;=</span><span class="n">d</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">lsd</span> <span class="o">:=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">n</span><span class="p">)</span><span class="o">%</span><span class="m">10</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">lsd</span><span class="p">][</span><span class="n">order</span><span class="p">[</span><span class="n">lsd</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="n">order</span><span class="p">[</span><span class="n">lsd</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="m">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
				<span class="k">for</span> <span class="n">j</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">j</span><span class="o">++</span> <span class="p">{</span>
					<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
					<span class="n">k</span><span class="o">++</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="m">0</span>
		<span class="p">}</span>
		<span class="n">m</span><span class="o">++</span>
		<span class="n">k</span><span class="o">=</span><span class="m">0</span>
		<span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="m">10</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Sort</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000007" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>ShellSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-alena-beliaeva-8697338.jpg" class="img-responsive img-centered" alt="shellSort">

                            
                                <h3>希尔排序</h3>
                            
                            </div>

                            <p><h3 id="缘由">缘由</h3>
<hr />

<p>对于大规模乱序数组插入排序很慢,因为它只会交换相邻的元素,因此元素只能一点点的从数组的一端移动到另一端.<br />
例如,如果主键最小的元素正好在数组的尽头,要将它挪到正确的位置就需要N-1次移动.<br />
希尔排序为了加速简单地改进了插入排序,交换不相邻的元素以对数组的局部进行排序并最终用插入排序将局域有序的数组排序.</p>

<hr />

<h3 id="基本思想">基本思想</h3>
<hr />
<p>使数组中任意间隔为h的元素都是有序的,这样的数组称为h有序数组.<br />
换句话说,一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组,在进行排序时,如果h很大,我们就能将元素移动到很远的地方,为实现更小的h有序创造方便.<br />
用这种方法,对于任意以1结尾的h序列,我们都能够将数组排序.</p>
<hr />

<h3 id="思路">思路</h3>
<hr />
<p>对于每个h,用插入排序将h个子数组独立的排序.但因为子数组是相互独立的,一个更简单的方法是在h-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）.只需要在插入排序的代码中将移动元素的距离由1改为h即可.这样,希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程.<br />
希尔排序更高效的原因是它权衡了子数组的规模和有序性.排序之初,各个子数组都很短,排序之后子数组都是部分有序的,这两种情况都很适合插入排序.子数组部分有序的程度取决于递增序列的选择.</p>
<hr />

<h3 id="如何选择递增序列">如何选择递增序列</h3>
<hr />
<p>算法的性能不仅取决于h,还取决于h之间的数学性质,比如他们的公因子等.这个需要视情况而定.</p>
<hr />

<h3 id="图解">图解</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/shellSort/shellSort.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="希尔排序" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/shellSort/shellSort.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">ShellSort</div>
    </a>
</center>

<h4 id="代码">代码</h4>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">shellSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">h</span><span class="o">&lt;</span><span class="n">len</span><span class="o">/</span><span class="n">factor</span><span class="o">){</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">factor</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">h</span><span class="o">&gt;=</span><span class="mi">1</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">h</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="o">];</span><span class="n">j</span><span class="o">-=</span><span class="n">h</span><span class="o">){</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">h</span><span class="o">/=</span><span class="n">factor</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(n^3/2)</p>

  <p>空间复杂度:O(1)</p>
</blockquote>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">shellSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
		<span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="n">len</span><span class="o">/</span><span class="n">factor</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">factor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">h</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span><span class="n">h</span><span class="p">;</span> <span class="n">j</span><span class="o">-=</span><span class="n">h</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="p">])</span>
					<span class="p">{</span>
						<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">h</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">h</span> <span class="o">/=</span> <span class="n">factor</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">shellSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">h</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">h</span><span class="o">&lt;</span><span class="n">length</span><span class="o">//</span><span class="n">factor</span><span class="p">:</span>
            <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">factor</span><span class="o">+</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">h</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="p">.</span><span class="n">swap3</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="p">)</span>
            <span class="n">h</span><span class="o">//=</span><span class="n">factor</span>


    <span class="k">def</span> <span class="nf">swap3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">shellSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="nb">len</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="n">factor</span><span class="o">:=</span><span class="m">2</span>
	<span class="n">h</span> <span class="o">:=</span><span class="m">1</span>
	<span class="k">for</span> <span class="n">h</span><span class="o">&lt;</span><span class="nb">len</span><span class="o">/</span><span class="n">factor</span> <span class="p">{</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">factor</span><span class="o">+</span><span class="m">1</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">h</span><span class="o">&gt;=</span><span class="m">1</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="n">h</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">for</span> <span class="n">j</span><span class="o">:=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="p">];</span><span class="n">j</span><span class="o">-=</span><span class="n">h</span> <span class="p">{</span>
				<span class="n">swap3</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">h</span><span class="o">/=</span><span class="n">factor</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">swap3</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="n">temp</span> <span class="o">:=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
	<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000006" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>MergeSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-anete-lusina-5721167.jpg" class="img-responsive img-centered" alt="mergeSort">

                            
                                <h3>归并排序</h3>
                            
                            </div>

                            <p><h3 id="基本思想">基本思想</h3>
<hr />
<p>要将一个数组排序,可以先递归地将它分成两半分别排序,然后将结果归并起来.<br />
归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和 <strong>NlogN</strong> 成正比;它的主要缺点则是它所需的额外空间和 <strong>N</strong> 成正比.</p>
<hr />

<h3 id="原地归并的抽象方法">原地归并的抽象方法</h3>
<hr />
<p>实现的方法很简单,创建一个适当大小的数组然后将两个输入数组中的元素一个个从大到小放入这个数组中.<br />
之所以需要原地归并,是因为当用归并一个大数组排序时,我们需要进行很多次归并,因此在每次归并时都创建一个新数组来存储排序结果会大大增加空间复杂度.<br />
如果使用原地归并的方法,这样就可以先将前半部分排序,再将后半部分排序, 然后在数组中移动元素而不需要使用额外的空间.<br />
原地归并的方法签名为: <strong>merge(a, lo, mid, hi)</strong> ,它会将子数组 <strong>a[lo..mid]</strong> 和 <strong>a[mid+1..hi]</strong> 归并成一个有序的数组并将结果存放在 <strong>a[lo..hi]</strong> 中.</p>
<hr />

<h3 id="代码">代码</h3>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">lo</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">hi</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span>
            <span class="n">temp</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">hi</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">mid</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<h3 id="代码分析">代码分析</h3>
<hr />
<p>该方法先将所有数组复制到temp[]中,然后在归并回a[]中.<br />
方法在归并时(第二个for循环)进行了4个判断:</p>
<ol>
  <li>i&gt;mid:左半边用完(取右半边的元素)</li>
  <li>j&gt;hi:右半边用尽(取左半边的元素)</li>
  <li>temp[j]&lt;temp[i]:右半边的当前元素小于左半边的当前元素(取右半边的元素)</li>
  <li>temp[j]&gt;temp[i]:右半边的放弃元素大于左半边的当前元素(取左半边的元素)</li>
</ol>

<p>仔细观察如上规则,其实就是给你两个有序集合,要把这两个有序集合合并成一个有序集合,使用双指针的方式合并.</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mergeSort/归并排序区间分布图.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="归并排序区间分布图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mergeSort/归并排序区间分布图.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">归并排序区间分布图</div>
    </a>
</center>

<h3 id="自顶向下的归并排序">自顶向下的归并排序</h3>
<hr />
<p>这是应用高效算法设计中分治思想的最典型的一个例子.</p>
<ol>
  <li>首先归并的排序每一个区间,保证区间大小为1的区间全都有序</li>
  <li>其次就是归并合并两个区间保证整个区间有序</li>
  <li>重复以上步骤即整个数组有序</li>
</ol>

<hr />

<h3 id="图解">图解</h3>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mergeSort/归并排序.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="归并排序" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mergeSort/归并排序.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">MergeSort</div>
    </a>
</center>

<h4 id="代码-1">代码</h4>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hi</span><span class="o">&lt;=</span><span class="n">lo</span><span class="o">){</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="o">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
    <span class="n">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">lo</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">hi</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span>
        <span class="n">temp</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">hi</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">mid</span><span class="o">){</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(NlogN)</p>

  <p>空间复杂度:O(1)</p>
</blockquote>

<h3 id="归并排序的缺点及改进方案">归并排序的缺点及改进方案</h3>
<hr />
<ul>
  <li>
    <p>缺点: 辅助数组所使用的额外空间和N的大小成正比.</p>
  </li>
  <li>
    <p>改进点</p>
    <ol>
      <li>对小规模子数组使用插入排序:用不同的方法处理小规模问题能改进大多数递归算法的性能,因为递归会使小规模问题中方法的调用过于频繁,所以改进对它们的处理方法就是改进整个算法.</li>
      <li>测试数组是否已经有序:可以添加一个判断条件,如果 <strong>a[mid]</strong> 小于等于 <strong>a[mid+1]</strong> ,我们就冉伟数组已经有序的并跳过merge()方法.</li>
      <li>不将元素复制到辅助数组:可以节省将数组元素复制到用于归并的辅助数组所用的时间(但空间不行).要做到这一点我们要调用两种排序方法,一种将数据从输入数组排序到辅助数组,一种将数据从辅助数组排序到输入数组.</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="自底向上的归并排序">自底向上的归并排序</h3>
<hr />
<p>同样是分治思想的典型应用.先归并那些微型数组,然后再成对归并得到的数组,如此这般,直到我们将整个数组归并在一起.这种实现方法比标准递归方法所需要的代码量更少.</p>
<ol>
  <li>首先进行的两两归并(把每个元素想象成一个大小为1的数组)</li>
  <li>然后是四四归并(将两个大小为2的数组归并成一个有4个元素的数组)</li>
  <li>然后是八八的归并,一直下去.</li>
  <li>在每一轮归并中,最后一次归并的第二个子数组可能比第一个子数组要小,如果不是的话所有的归并排序中两个数组大小应该都是一样的,而在下一轮中子数组的大小会翻倍.</li>
</ol>

<p>当数组长度为2的幂时,自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同,只是顺序不同.</p>
<hr />

<h3 id="代码-2">代码</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="n">temp</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span><span class="n">sz</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span><span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span><span class="o">+</span><span class="n">sz</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">lo</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">lo</span><span class="o">&lt;</span><span class="n">len</span><span class="o">-</span><span class="n">sz</span><span class="o">;</span><span class="n">lo</span> <span class="o">+=</span> <span class="n">sz</span><span class="o">+</span><span class="n">sz</span><span class="o">){</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lo</span><span class="o">+</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">lo</span><span class="o">+</span><span class="n">sz</span><span class="o">+</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">lo</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">hi</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span>
        <span class="n">temp</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">hi</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">mid</span><span class="o">){</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="代码分析-1">代码分析</h3>
<hr />
<p>仔细看下mergeSort方法,使用两个循环解决了自底向上归并.<br />
第一个循环的作用就是定义归并的子数组,不断递增到数组大小.</p>
<ul>
  <li>其中 <strong>sz</strong> 代表当前要归并的子数组大小,肯定要从1开始慢慢不断乘2扩大子数组,所以sz的大小一定是要小于len的,那递增条件就是不断乘2即 <strong>sz+sz</strong></li>
</ul>

<p>再看第二个循环,他的作用就是将nums中每间隔sz的数组归并排序.</p>
<ul>
  <li>其中 <strong>lo</strong> 代表起始位置,肯定是从 <strong>0</strong> 开始排序,因为排序每隔 <strong>sz</strong> 的区间,那么lo的最大长度就是 <strong>len-sz</strong> ,那最后的递增条件就很容易理解了,要间隔 <strong>2*sz</strong> 的区间嘛,肯定是加上 <strong>sz+sz</strong></li>
</ul>

<p>最后就是将两个有序的子区间合并成一个大的有序子区间, 起点肯定是 <strong>lo</strong> ,因为我们排序是 <strong>sz+sz</strong> 长度的子区间,那么这个子区间的中间节点肯定是 <strong>lo+sz-1</strong> ,那最后就剩下最后区间的末尾了,按理说应该是 <strong>lo+sz+sz-1</strong> ,但是因为不断递增可能会超过数组长度,所以要取 <strong>lo+sz+sz-1</strong> 和 <strong>len-1</strong> 的最小值.</p>
<hr />

<h3 id="自底向上轨迹图">自底向上轨迹图</h3>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mergeSort/自底向上归并轨迹图.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="自底向上归并轨迹图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mergeSort/自底向上归并轨迹图.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">自底向上归并轨迹图</div>
    </a>
</center>

<h3 id="自顶向下归并其他语言">自顶向下归并其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">temp</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
		<span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">temp</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">&lt;=</span><span class="n">lo</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">+</span> <span class="n">lo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="n">merge</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">temp</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span> 
			<span class="p">{</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">hi</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">lo</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hi</span><span class="o">&lt;=</span><span class="n">lo</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
        <span class="n">merge</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">lo</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">mid</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">mid</span> <span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">hi</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//自顶向下归并排序</span>
<span class="k">func</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="n">temp</span> <span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>

	<span class="k">var</span> <span class="n">merge</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">lo</span> <span class="kt">int</span><span class="p">,</span> <span class="n">mid</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hi</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">merge</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">lo</span> <span class="kt">int</span><span class="p">,</span> <span class="n">mid</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hi</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">:=</span><span class="n">lo</span>
		<span class="n">j</span><span class="o">:=</span><span class="n">mid</span><span class="o">+</span><span class="m">1</span>
		<span class="k">for</span> <span class="n">k</span><span class="o">:=</span><span class="n">lo</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">hi</span><span class="p">;</span><span class="n">k</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">k</span><span class="o">:=</span><span class="n">lo</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">hi</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">{</span>
			<span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">mid</span> <span class="p">{</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="n">j</span><span class="o">++</span>
			<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">hi</span> <span class="p">{</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
				<span class="n">i</span><span class="o">++</span>
			<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="n">j</span><span class="o">++</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
				<span class="n">i</span><span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">var</span> <span class="n">sort</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">lo</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hi</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">sort</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">lo</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hi</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">hi</span><span class="o">&lt;=</span><span class="n">lo</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="n">mid</span> <span class="o">:=</span> <span class="n">lo</span><span class="o">+</span><span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="p">)</span><span class="o">/</span><span class="m">2</span>
		<span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
		<span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
		<span class="n">merge</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000005" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SelectSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-8906527.jpg" class="img-responsive img-centered" alt="selectSort">

                            
                                <h3>选择排序</h3>
                            
                            </div>

                            <p><h3 id="基本思想">基本思想</h3>
<hr />
<p>主要就是遍历数组,找到最小值和最前面的元素交换即可.</p>
<hr />

<h3 id="思路">思路</h3>
<hr />
<ol>
  <li>首先找到数组中最小的那个元素</li>
  <li>其次将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)</li>
  <li>再次在剩下的元素中找到最小的元素,将它与数组的第二个元素交换位置</li>
  <li>如此往复,直到整个数组有序
    <hr />
  </li>
</ol>

<h3 id="图解">图解</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/selectSort/selectSort.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="选择排序" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/selectSort/selectSort.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">HeapSort</div>
    </a>
</center>

<h4 id="代码">代码</h4>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">selectSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">min</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                <span class="n">min</span><span class="o">=</span><span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(n^2)</p>

  <p>空间复杂度:O(1)</p>
</blockquote>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">selectSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
				<span class="p">{</span>
					<span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">selectSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="nb">min</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="nb">min</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">selectSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="nb">len</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">min</span><span class="o">:=</span><span class="n">i</span>
		<span class="k">for</span> <span class="n">j</span><span class="o">:=</span><span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">;</span><span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">min</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">min</span> <span class="o">=</span> <span class="n">j</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">swap1</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">swap1</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">i</span> <span class="kt">int</span><span class="p">,</span> <span class="n">j</span> <span class="kt">int</span><span class="p">){</span>
	<span class="n">temp</span> <span class="o">:=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
	<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000004" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>InsertSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-nick-wehrli-6524730.jpg" class="img-responsive img-centered" alt="insertSort">

                            
                                <h3>插入排序</h3>
                            
                            </div>

                            <p><h3 id="基本思想">基本思想</h3>
<hr />
<p>类似于我们打牌时,将每一张牌插入到其他已经有序的牌中的适当位置.<br />
为了要给插入的元素腾出空间,需要将其余所有元素在插入之前都向右移动一位.</p>
<hr />

<h3 id="思路">思路</h3>
<hr />
<ol>
  <li>首先从外层i=1开始遍历数组,保证前i个元素有序</li>
  <li>内层j从i向前遍历,同时比较相邻的两个数,将nums[i]插入到合适位置</li>
  <li>每次内循环保证前i个元素有序</li>
  <li>重复以上步骤直到外层遍历结束即数组有序
    <hr />
  </li>
</ol>

<h3 id="图解">图解</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/insertSort/insertSort.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="插入排序" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/insertSort/insertSort.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">InsertSort</div>
    </a>
</center>

<h4 id="代码">代码</h4>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">insertSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span><span class="n">j</span><span class="o">--){</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(n^2)</p>

  <p>空间复杂度:O(1)</p>
</blockquote>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">insertSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="p">}</span>
				
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insertSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">insertSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="nb">len</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">j</span><span class="o">:=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">];</span><span class="n">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="n">swap2</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">swap2</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="n">temp</span> <span class="o">:=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
	<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000003" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>HeapSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-valeriya-kobzar-8155476.jpg" class="img-responsive img-centered" alt="heapSort">

                            
                                <h3>堆排序</h3>
                            
                            </div>

                            <p><h3 id="前置概念">前置概念</h3>
<hr />
<p>完全二叉树:叶子节点只能出现在最下层或次下层,且最下层的叶子节点集中在树的左部.即除了最后一层其他层的节点个数都是满的而且最后一层的叶子节点必须靠左.</p>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/完全二叉树.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="完全二叉树" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/完全二叉树.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">完全二叉树</div>
    </a>
</center>

<h3 id="二叉堆">二叉堆</h3>
<hr />
<ol>
  <li>必须是完全二叉树</li>
  <li>二叉堆中的每一个节点,都必须大于等于(或小于等于)其子树中每个节点的值<br />
若每个节点大于等于子树中的每个节点,称之为大顶堆.
若每个节点小于等于子树中的每个节点,称之为小顶堆.
    <hr />
  </li>
</ol>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/大小顶堆.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="大小顶堆" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/大小顶堆.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">小顶堆/大顶堆</div>
    </a>
</center>

<p><br /></p>

<p>我们仔细观察下大顶堆和小顶堆,可以发现如果父节点的位置为0,其左子节点的位置1,右子节点的位置为2.<br />
大约可以猜到父节点和左右子节点的关系为:若父节点的位置为1,那么左子节点的位置为 <strong>2×i+1</strong> ,右子节点的位置为 <strong>2×i+2</strong> .可以带入到其他节点验证一下.该属性是二叉堆调整的关键.<br />
注意:我们这里索引是从0开始的,如果索引从1开始的话,那么左右子节点的位置即是 <strong>2×i</strong> 和 <strong>2×i+1</strong> .</p>
<hr />
<h3 id="二叉堆的基本操作">二叉堆的基本操作</h3>
<hr />
<blockquote>
  <p>上浮:由下至上的堆有序化</p>
</blockquote>

<p>如果堆的有序状态因为某个节点的变得比它的父节点更大而打破,那么我们就需要通过交换它和它的父节点来修复堆,直到这个节点向上移动遇到一个更大的节点.<br />
若这个节点位置为k,那他的父节点位置就是 <strong>k/2</strong>,不断和父节点比较并交换位置即可.</p>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/上浮.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="上浮" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/上浮.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">上浮</div>
    </a>
</center>

<h4 id="代码">代码</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
    <span class="k">while</span><span class="o">(</span><span class="n">k</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">]&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]){</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />
<blockquote>
  <p>下沉:由上至下的堆有序化</p>
</blockquote>

<p>如果堆的有序状态因为某个节点变的比它的两个子节点或者其中之一更小而打破了,那么我们可以通过将它和它的两个子节点中的较大者交换来恢复堆,交换知道它的子节点都比他更小或达到堆的底部.<br />
若节点的位置为k,那么它的左右子节点的位置为 <strong>2×k+1</strong> 和 <strong>2×k+2</strong>,不断和这两个节点比较并交换即可.</p>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/下沉.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="下沉" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/下沉.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">下沉</div>
    </a>
</center>

<h4 id="代码-1">代码</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="no">N</span><span class="o">){</span>
    <span class="k">while</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="no">N</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
            <span class="n">j</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]){</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="n">k</span><span class="o">=</span><span class="n">j</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="基本思想">基本思想</h3>
<hr />
<p>主要就是构建堆,利用大顶堆或小顶堆的性质排序</p>
<hr />

<h3 id="思路">思路</h3>
<hr />
<p>堆排序其实就是两步</p>
<ol>
  <li>建堆:利用上浮和下沉构建大顶堆或小顶堆,上浮下沉图解见上方</li>
  <li>排序：
    <ul>
      <li>若为升序排序,那么应该建立大顶堆,然后将根节点和堆的最后一个节点交换,并将新的根节点下沉到合适位置即调整堆为大顶堆,此时数组最后即为最大元素,重复以上步骤,直到处理的数组长度为1.</li>
      <li>若为降序排序,那么就应该建立小顶堆,重复上面的交换流程,整个数据交换后数组有序.</li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="图解">图解</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/堆排序.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="堆排序" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/heapSort/堆排序.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">HeapSort</div>
    </a>
</center>

<h4 id="代码-2">代码</h4>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">heapSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="c1">//1.利用下沉建立大顶堆</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">--){</span>
        <span class="n">sink</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//2.排序</span>
    <span class="k">while</span><span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">){</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span> <span class="o">,--</span><span class="n">len</span><span class="o">);</span>
        <span class="n">sink</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span> 
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//下沉</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">){</span>
    <span class="k">while</span><span class="o">(</span><span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">len</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
            <span class="n">j</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]){</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
        <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(n*logn)</p>

  <p>空间复杂度:O(1)</p>
</blockquote>

<h3 id="扩展点">扩展点</h3>
<hr />
<ol>
  <li>常使用大小堆维护中位数, 左边使用大顶堆, 右边使用小顶堆, 这样左边取最大值右边取最小值即可. 见算法题<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">数据流的中位数</a>
    <hr />
  </li>
</ol>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">heapSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
		<span class="c1">//建堆</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">sink</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="c1">//排序</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">--</span><span class="n">len</span><span class="p">);</span>
			<span class="n">sink</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">nums</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">sink</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">len</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">j</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">heapSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">length</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">length</span><span class="o">-=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">sink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">while</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="nb">len</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">break</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">k</span><span class="o">=</span><span class="n">j</span>

    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">heapSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nb">len</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="nb">len</span><span class="o">/</span><span class="m">2</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">sink</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="o">&gt;</span><span class="m">1</span> <span class="p">{</span>
		<span class="nb">len</span> <span class="o">-=</span><span class="m">1</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>
		<span class="n">sink</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="m">0</span> <span class="p">,</span><span class="nb">len</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nums</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">sink</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">len</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="k">for</span> <span class="m">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="m">1</span><span class="o">&lt;</span><span class="nb">len</span> <span class="p">{</span>
		<span class="n">j</span><span class="o">:=</span><span class="m">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="m">1</span>
		<span class="k">for</span> <span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="o">&lt;</span><span class="nb">len</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">j</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
		<span class="n">k</span><span class="o">=</span><span class="n">j</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000002" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>QuickSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-jo-jesus-4198220.jpg" class="img-responsive img-centered" alt="quickSort">

                            
                                <h3>快速排序</h3>
                            
                            </div>

                            <p><h3 id="基本思想">基本思想</h3>
<hr />
<p>是一种分治的排序算法,他将一个数组分成两个子数组,将两部分独立的排序.</p>
<hr />

<h3 id="思路">思路</h3>
<hr />
<ol>
  <li>首先以 <strong>left=0,right=nums.len-1</strong> 进行排序,最外层需要保证 <strong>left&lt;right</strong></li>
  <li>排序首先以 <strong>nums[left]</strong> 为基准值base</li>
  <li>然后将右指针从右往左遍历,当 <strong>left&lt;right且nums[right]&gt;=base</strong> 时,将右指针右移,否则就将右指针的值替换到左指针处 (此步的意义就是找到最右侧小于基准值base并将右侧值赋值到左指针的值)</li>
  <li>接着将左指针从左往右遍历,当 <strong>left&lt;right且nums[left]&lt;=base</strong> 时,将左指针左移,否则将左指针的值赋值给右指针 (此步同步骤三相反,即找到最左侧大于基准值base的值,并将此值赋值给右指针的值)</li>
  <li>最后当两个指针相交时,将base值赋值给nums[left],并同时将left返回作为下个区间的中间值</li>
  <li>接下来就是递归遍历 <strong>[left,temp-1]和[temp+1,right]</strong> ,遍历结束即数组有序</li>
</ol>

<hr />

<h3 id="图解">图解</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort1.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="quickSort1" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort1.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
        display: inline-block;
        color: #999;
        padding: 2px;">第一层排序[0, 4]</div>
    </a>
</center>
<p><br /></p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort2.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="quickSort1" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort2.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
        display: inline-block;
        color: #999;
        padding: 2px;">第二层排序[0,-1]和[1,4]</div>
    </a>
</center>
<p><br /></p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort3.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="quickSort1" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort3.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
        display: inline-block;
        color: #999;
        padding: 2px;">第三轮排序[1,1]和[3,4]</div>
    </a>
</center>

<h4 id="代码">代码</h4>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//解法一</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort1</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;=</span> <span class="n">left</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">division1</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="n">quickSort1</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">base</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">quickSort1</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">base</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">division1</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">left</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">base</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[++</span><span class="n">i</span><span class="o">]){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">right</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">base</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[--</span><span class="n">j</span><span class="o">]){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span><span class="o">==</span><span class="n">left</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">j</span><span class="o">){</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">exchange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">exchange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">exchange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//解法二</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">division</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">base</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">base</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">division</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="o">){</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]&gt;=</span><span class="n">base</span><span class="o">){</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]&lt;=</span><span class="n">base</span><span class="o">){</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]=</span><span class="n">base</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>时间复杂度:O(nlogn)</p>

  <p>空间复杂度:O(1)</p>
</blockquote>

<h3 id="算法改进">算法改进</h3>
<hr />
<ol>
  <li>切换到插入排序
    <ul>
      <li>对于小数组,快速排序比插入排序慢</li>
      <li>因为递归,快速排序的sort()方法在小数组中也会调用自己</li>
    </ul>
  </li>
  <li>三取样切分
    <ul>
      <li>使用子数组的一小部分元素的中位数来切分数组</li>
    </ul>
  </li>
  <li>熵最优的排序
    <ul>
      <li>在有大量重复元素的情况下,快速排序的递归性会使元素全部重复的子数组经常出现,这就有很大的改进空间,将当前实现的线性对数级的性能提高到线性级别.</li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="三项切分的快速排序">三项切分的快速排序</h3>
<h3 id="基本思想-1">基本思想</h3>
<hr />
<p>将数组切成三部分,分别对应小于、等于和大于切分元素的数组元素.</p>
<hr />

<h3 id="思路-1">思路</h3>
<hr />
<ol>
  <li>他从左到右遍历数组一次,维护一个指针 <strong>lt</strong> 使得 <strong>a[lo..lt-1]</strong> 中的元素都小于 <strong>v</strong> ,一个指针 <strong>gt</strong> 使得 <strong>a[gt+1..hi]</strong> 中的元素都大于 <strong>v</strong> ,一个指针 <strong>i</strong> 使得 <strong>a[lt..i-1]</strong> 中的元素都等于 <strong>v</strong> , <strong>a[i..gt]</strong> 中的元素都还未确定.</li>
  <li>一开始 <strong>i</strong> 和 <strong>lo</strong> 相等,我们使用Comparable接口对 <strong>a[i]</strong> 进行三向比较来处理以下情况:
    <ul>
      <li><strong>a[i]</strong> 小于 <strong>v</strong> ,将 <strong>a[lt]</strong> 和 <strong>a[i]</strong> 交换,将 <strong>lt</strong> 和 <strong>i</strong> 加一</li>
      <li><strong>a[i]</strong> 大于 <strong>v</strong> ,将 <strong>a[gt]</strong> 和 <strong>a[i]</strong> 交换,将 <strong>gt</strong> 减一</li>
      <li><strong>a[i]</strong> 等于 <strong>v</strong> ,将 <strong>i</strong> 加一</li>
    </ul>
  </li>
</ol>

<p>这些操作都会保证数组元素不变且缩小 <strong>gt-i</strong> 的值(这样循环才会结束).另外,除非和切分元素相等,其他元素都会被交换.</p>
<hr />

<h3 id="三向切分示意图">三向切分示意图</h3>

<center>
     <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/三向切分示意图.jpg">
     <img style="border-radius: 0.3125em;
     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="三向切分" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/三向切分示意图.jpg" />
     <div style="color:orange; border-bottom: 1px solid #d9d9d9;
         display: inline-block;
         color: #999;
         padding: 2px;">三向切分示意图</div>
     </a>
 </center>

<h3 id="三向切分代码">三向切分代码</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quick3way</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hi</span><span class="o">&lt;=</span><span class="n">lo</span><span class="o">){</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">lt</span><span class="o">=</span><span class="n">lo</span><span class="o">,</span> <span class="n">i</span><span class="o">=</span><span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">gt</span><span class="o">=</span><span class="n">hi</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">gt</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]&lt;</span><span class="n">v</span><span class="o">){</span>
            <span class="n">exchange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lt</span><span class="o">++,</span><span class="n">i</span><span class="o">++);</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]&gt;</span><span class="n">v</span><span class="o">){</span>
            <span class="n">exchange</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">gt</span><span class="o">--);</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">quick3way</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">quick3way</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">gt</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">exchange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>c++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">quickSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">division</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
			<span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">temp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">temp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="n">division</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">right</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">left</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">left</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">quickSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">left</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">division</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">left</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">base</span><span class="p">:</span>
                    <span class="n">right</span><span class="o">-=</span><span class="mi">1</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                <span class="k">while</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">base</span><span class="p">:</span>
                    <span class="n">left</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">=</span><span class="n">base</span>
            <span class="k">return</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">division</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span> <span class="p">,</span><span class="n">right</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">temp</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">temp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">left</span> <span class="kt">int</span><span class="p">,</span> <span class="n">right</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
		<span class="k">var</span> <span class="n">division</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">left</span> <span class="kt">int</span><span class="p">,</span> <span class="n">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
		<span class="n">division</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">left</span> <span class="kt">int</span><span class="p">,</span> <span class="n">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
			<span class="n">base</span> <span class="o">:=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span> <span class="p">{</span>
				<span class="k">for</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">base</span> <span class="p">{</span>
					<span class="n">right</span><span class="o">--</span>
				<span class="p">}</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
				<span class="k">for</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">base</span> <span class="p">{</span>
					<span class="n">left</span><span class="o">++</span>
				<span class="p">}</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">=</span><span class="n">base</span>
			<span class="k">return</span> <span class="n">left</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span> <span class="p">{</span>
			<span class="n">temp</span><span class="o">:=</span><span class="n">division</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
			<span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">temp</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
			<span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">temp</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-10000001" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>BubbleSort</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-rachel-claire-4846299.jpg" class="img-responsive img-centered" alt="bubbleSort">

                            
                                <h3>冒泡排序</h3>
                            
                            </div>

                            <p><h3 id="基本思想">基本思想</h3>
<hr />
<p>就是两两比较然后交换位置,将较小值不断向前移动</p>
<hr />

<h3 id="思路">思路</h3>
<hr />
<ol>
  <li>首先需要两层循环,外层从 <strong>i=0</strong> 开始</li>
  <li>内层循环的主要作用就根据遍历顺序保证最大值或最小值已经移动到数组的末尾或者开头</li>
</ol>

<p>内层有两者方式：</p>
<ul>
  <li>从前往后:j从0一直遍历到nums.len-1-i 处,同时比较 <strong>nums[j]</strong> 和 <strong>nums[j+1]</strong> 的值,只有 <strong>nums[j]&gt;nums[j+1]</strong> 时才将 <strong>nums[j]</strong> 向后移动,每次循环结束保证最大值在末尾</li>
  <li>从后往前:j从nums.len一直遍历到 i 处,同时比较 <strong>nums[j-1]和nums[j]</strong> 的值,只有 <strong>nums[j-1]&gt;nums[j]</strong> 时才将 <strong>nums[j]</strong> 向前移动,每次循环结束保证最小值在开头</li>
</ul>

<hr />

<h3 id="内层逆序图解">内层逆序图解</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="BubbleSort" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">bubbleSort</div>
    </a>
</center>

<h4 id="代码">代码</h4>
<blockquote>
  <p>java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//内层逆序遍历</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
     <span class="kt">int</span> <span class="n">temp</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++</span> <span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//内层正序遍历</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>   
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>时间复杂度:O(n^2)</p>

  <p>空间复杂度:O(1)</p>
</blockquote>

<h3 id="算法优化">算法优化</h3>
<hr />
<p>没有什么大的优化,主要是若一次遍历过后中间没有移动的动作说明数组已经有序,无需继续往后遍历,直接结束</p>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++</span> <span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">flag</span><span class="o">){</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="其他语言">其他语言</h3>
<hr />
<blockquote>
  <p>C++</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//内部正序</span>
	<span class="kt">void</span> <span class="n">bubbleSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
				<span class="p">{</span>
					<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
					<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
					<span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//内部逆序</span>
	<span class="kt">void</span> <span class="n">bubbleSort1</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span>  <span class="n">j</span> <span class="o">=</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
				<span class="p">{</span>
					<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
					<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
					<span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<blockquote>
  <p>python3</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1">#内部正序
</span>    <span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

    <span class="c1">#内部正序
</span>    <span class="k">def</span> <span class="nf">bubbleSort1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">(</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
</code></pre></div></div>
<blockquote>
  <p>go</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//内部逆序</span>
<span class="k">func</span> <span class="n">bubbleSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">len</span> <span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">j</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="nb">len</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">temp</span><span class="o">:=</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">bubbleSort1</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="nb">len</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">j</span><span class="o">:=</span><span class="nb">len</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">temp</span><span class="o">:=</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
				<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">algorithm</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-20000001" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2>SpringBoot启动源码解析(一)</h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-david-selbert-6468061.jpg" class="img-responsive img-centered" alt="SpringBoot1">

                            
                                <h3>SpringBootApplication注解分析</h3>
                            
                            </div>

                            <p><h3 id="springbootapplication结构图">@SpringBootApplication结构图</h3>
<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/@SpringBootApplication注解.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="@SpringBootApplication注解" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/@SpringBootApplication注解.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">@SpringBootApplication注解</div>
    </a>
</center>

<h3 id="springbootapplication">@SpringBootApplication</h3>
<hr />
<blockquote>
  <p>源码如下</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Indicates a {@link Configuration configuration} class that declares one or more
 * {@link Bean @Bean} methods and also triggers {@link EnableAutoConfiguration
 * auto-configuration} and {@link ComponentScan component scanning}. This is a convenience
 * annotation that is equivalent to declaring {@code @Configuration},
 * {@code @EnableAutoConfiguration} and {@code @ComponentScan}.
 * 声明一个配置类,他声明一个或多个@Bean方法且触发 EnableAutoConfiguration自动配置和 ComponentScan组件扫描.
 * 这是一个便利的注解等同于声明 @Configuration、@EnableAutoConfiguration 和 @ComponentScan
 * @author Phillip Webb
 * @author Stephane Nicoll
 * @author Andy Wilkinson
 * @since 1.2.0
 */</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Inherited</span>
<span class="nd">@SpringBootConfiguration</span>
<span class="c1">//该注解的作用是开启自动配置</span>
<span class="nd">@EnableAutoConfiguration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="n">excludeFilters</span> <span class="o">=</span> <span class="o">{</span> <span class="nd">@Filter</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="nc">FilterType</span><span class="o">.</span><span class="na">CUSTOM</span><span class="o">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="nc">TypeExcludeFilter</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
		<span class="nd">@Filter</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="nc">FilterType</span><span class="o">.</span><span class="na">CUSTOM</span><span class="o">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="nc">AutoConfigurationExcludeFilter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">})</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">SpringBootApplication</span> <span class="o">{</span>

	<span class="nd">@AliasFor</span><span class="o">(</span><span class="n">annotation</span> <span class="o">=</span> <span class="nc">EnableAutoConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">exclude</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

	<span class="nd">@AliasFor</span><span class="o">(</span><span class="n">annotation</span> <span class="o">=</span> <span class="nc">EnableAutoConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="nc">String</span><span class="o">[]</span> <span class="nf">excludeName</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

	<span class="nd">@AliasFor</span><span class="o">(</span><span class="n">annotation</span> <span class="o">=</span> <span class="nc">ComponentScan</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">attribute</span> <span class="o">=</span> <span class="s">"basePackages"</span><span class="o">)</span>
	<span class="nc">String</span><span class="o">[]</span> <span class="nf">scanBasePackages</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

	<span class="nd">@AliasFor</span><span class="o">(</span><span class="n">annotation</span> <span class="o">=</span> <span class="nc">ComponentScan</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">attribute</span> <span class="o">=</span> <span class="s">"basePackageClasses"</span><span class="o">)</span>
	<span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">scanBasePackageClasses</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

	<span class="nd">@AliasFor</span><span class="o">(</span><span class="n">annotation</span> <span class="o">=</span> <span class="nc">Configuration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kt">boolean</span> <span class="nf">proxyBeanMethods</span><span class="o">()</span> <span class="k">default</span> <span class="kc">true</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>
<p><strong>@SpringBootApplication</strong> 是最顶层注解,他主要由 <strong>@SpringBootConfiguration</strong> , <strong>@EnableAutoConfiguration</strong> , <strong>@Component</strong> 这个三个注解组合而成. <br />
接下来我们仔细分析下这三个注解分别做了什么事情.</p>
<hr />

<h3 id="springbootconfiguration">@SpringBootConfiguration</h3>
<hr />
<blockquote>
  <p>源码如下</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Indicates that a class provides Spring Boot application
 * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's
 * standard {@code @Configuration} annotation so that configuration can be found
 * automatically (for example in tests).
 * 表明一个类提供Springboot应用的@Configuration.用来替代Spring标准的@Configuration注解，可以自动发现配置

 * &lt;p&gt;
 * Application should only ever include &lt;em&gt;one&lt;/em&gt; {@code @SpringBootConfiguration} and
 * most idiomatic Spring Boot applications will inherit it from
 * {@code @SpringBootApplication}.
 * 应用应该包含一个@SpringBootConfiguration注解并且大多数惯用的SpringBoot应用将继承@SpringBootConfiguration
 * @author Phillip Webb
 * @author Andy Wilkinson
 * @since 1.4.0
 */</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">SpringBootConfiguration</span> <span class="o">{</span>

	<span class="nd">@AliasFor</span><span class="o">(</span><span class="n">annotation</span> <span class="o">=</span> <span class="nc">Configuration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kt">boolean</span> <span class="nf">proxyBeanMethods</span><span class="o">()</span> <span class="k">default</span> <span class="kc">true</span><span class="o">;</span>

<span class="o">}</span>

<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Configuration</span> <span class="o">{</span>

	<span class="nd">@AliasFor</span><span class="o">(</span><span class="n">annotation</span> <span class="o">=</span> <span class="nc">Component</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>

	<span class="kt">boolean</span> <span class="nf">proxyBeanMethods</span><span class="o">()</span> <span class="k">default</span> <span class="kc">true</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<p>可见 <strong>@SpringBootApplication</strong> 的底层注解就是 <strong>@Configuration</strong> , 而 <strong>@Component</strong> 的底层注解是 <strong>@Component</strong> . <br />
<strong>@SpringBootApplication</strong> 的主要作用就是将目标类标记为配置类,交由Spring管理.在SpingBoot中就对应我们的启动函数.  <br />
下面我们看下这个配置主要用于哪里?</p>
<ul>
  <li>首先用于将主函数添加到 <strong>DefaultListableBeanFactory</strong> 中的 <strong>beanDefinitionMap</strong> 和 <strong>beanDefinitionNames</strong> 中,即将主函数注册为上下文中bean工厂的bean定义.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//代码位置</span>
<span class="o">-&gt;</span>  <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">.</span><span class="na">SpringApplication</span><span class="err">#</span><span class="n">prepareContext</span>   
<span class="o">-&gt;</span>  <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">.</span><span class="na">SpringApplication</span><span class="err">#</span><span class="n">load</span> 
<span class="o">-&gt;</span>  <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">.</span><span class="na">BeanDefinitionLoader</span><span class="err">#</span><span class="n">load</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Class</span><span class="o">&lt;?&gt;)</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">load</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isGroovyPresent</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="nc">GroovyBeanDefinitionSource</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">source</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Any GroovyLoaders added in beans{} DSL can contribute beans here</span>
        <span class="nc">GroovyBeanDefinitionSource</span> <span class="n">loader</span> <span class="o">=</span> <span class="nc">BeanUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="nc">GroovyBeanDefinitionSource</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">load</span><span class="o">(</span><span class="n">loader</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 这里判断source(即主函数)是否被@Component修饰</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isComponent</span><span class="o">(</span><span class="n">source</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">annotatedReader</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isComponent</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This has to be a bit of a guess. The only way to be sure that this type is</span>
    <span class="c1">// eligible is to make a bean definition out of it and try to instantiate it.</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">MergedAnnotations</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="nc">SearchStrategy</span><span class="o">.</span><span class="na">TYPE_HIERARCHY</span><span class="o">).</span><span class="na">isPresent</span><span class="o">(</span><span class="nc">Component</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// Nested anonymous classes are not eligible for registration, nor are groovy</span>
    <span class="c1">// closures</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">matches</span><span class="o">(</span><span class="s">".*\\$_.*closure.*"</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">type</span><span class="o">.</span><span class="na">isAnonymousClass</span><span class="o">()</span>
            <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">().</span><span class="na">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>

<ul>
  <li>最后就是将main方法对应的类解析为配置类, 通过 <strong>ConfigurationClassPostProcessor</strong> 配置类后置处理器解析bean工厂中所有被 <strong>@Configuration</strong> 修饰的bean</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//代码位置</span>
<span class="o">-&gt;</span>  <span class="mi">1</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">.</span><span class="na">SpringApplication</span><span class="err">#</span><span class="n">refreshContext</span>
<span class="o">-&gt;</span>  <span class="mi">2</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">support</span><span class="o">.</span><span class="na">AbstractApplicationContext</span><span class="err">#</span><span class="n">invokeBeanFactoryPostProcessors</span>
<span class="o">-&gt;</span>  <span class="mi">3</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">support</span><span class="o">.</span><span class="na">PostProcessorRegistrationDelegate</span><span class="err">#</span><span class="n">invokeBeanDefinitionRegistryPostProcessors</span>
<span class="o">-&gt;</span>  <span class="mi">4</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ConfigurationClassPostProcessor</span><span class="err">#</span><span class="n">processConfigBeanDefinitions</span>

<span class="cm">/**
 * Build and validate a configuration model based on the registry of
 * {@link Configuration} classes.
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">processConfigBeanDefinitions</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">configCandidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinitionNames</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">candidateNames</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BeanDefinition</span> <span class="n">beanDef</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">beanDef</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">CONFIGURATION_CLASS_ATTRIBUTE</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Bean definition has already been processed as a configuration class: "</span> <span class="o">+</span> <span class="n">beanDef</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//此步就是判断当前类是否</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">checkConfigurationClassCandidate</span><span class="o">(</span><span class="n">beanDef</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">configCandidates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BeanDefinitionHolder</span><span class="o">(</span><span class="n">beanDef</span><span class="o">,</span> <span class="n">beanName</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Return immediately if no @Configuration classes were found</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">configCandidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>综上所述, <strong>@SpringBootApplication</strong> 的作用就是将主函数对应类声明为可以被Spring处理的bean,并解析该bean交由Spring管理.</p>

<hr />

<h3 id="enableautoconfiguration">@EnableAutoConfiguration</h3>
<hr />
<blockquote>
  <p>源码如下</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Inherited</span>
<span class="c1">//将主配置类所在的包及子包里面所有的组件扫描加载到Spring容器中</span>
<span class="nd">@AutoConfigurationPackage</span>
<span class="c1">//通过selectImports将自动配置类xxxAutoConfiguration导入到容器中</span>
<span class="nd">@Import</span><span class="o">(</span><span class="nc">AutoConfigurationImportSelector</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">EnableAutoConfiguration</span> <span class="o">{</span>

	<span class="c1">//	 * 当自动配置开启时可以用于重写的环境属性</span>
	<span class="nc">String</span> <span class="no">ENABLED_OVERRIDE_PROPERTY</span> <span class="o">=</span> <span class="s">"spring.boot.enableautoconfiguration"</span><span class="o">;</span>

	<span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">exclude</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

	<span class="nc">String</span><span class="o">[]</span> <span class="nf">excludeName</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

<span class="o">}</span>

<span class="cm">/**
 * Indicates that the package containing the annotated class should be registered with
 * {@link AutoConfigurationPackages}.
 * 使用AutoConfigurationPackages注册。如果未指定基础包或基础包的类，使用注解的类将被注册
 * @author Phillip Webb
 * @since 1.3.0
 * @see AutoConfigurationPackages
 */</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Inherited</span>
<span class="nd">@Import</span><span class="o">(</span><span class="nc">AutoConfigurationPackages</span><span class="o">.</span><span class="na">Registrar</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">AutoConfigurationPackage</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>

<p>可见 <strong>@EnableAutoConfiguration</strong> 是由 <strong>@AutoConfigurationPackage</strong> 和 <strong>@Import(AutoConfigurationImportSelector.class)</strong> 组成, 而 <strong>@AutoConfigurationPackage</strong> 又是由 <strong>@Import(AutoConfigurationPackages.Registrar.class)</strong> 组成.<br />
所以 <strong>@EnableAutoConfiguration</strong> 其实就是由两个 <strong>@Import</strong> 注解组成的, 顾名思义它的作用就是导入指定类的,即 <strong>AutoConfigurationImportSelector.class</strong> 和 <strong>AutoConfigurationPackages.Registrar.class</strong> . <br />
接下来我们看下这两个类的作用是什么,具体在哪里生效的?  <br />
首先看下这个两个类的类图,供后面使用</p>
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/AutoConfigurationImportSelector.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="AutoConfigurationImportSelector类图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/AutoConfigurationImportSelector.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">AutoConfigurationImportSelector类图</div>
    </a>
</center>

<p>主要看实现的 <strong>DeferredImportSelector</strong> 及其父接口 <strong>ImportSelector</strong> .  <br />
<strong>ImportSelector</strong> :主要作用就是通过 <strong>selectImports</strong> 方法确定要导入的类,在启动过程中对应导入 <strong>/META_INF/factories</strong> 中的 <strong>EnableAutoConfiguration.class</strong> 的子类.<br />
<strong>DeferredImportSelector</strong> :主要作用就是筛选根据父类 <strong>ImportSelector</strong> 中 <strong>selectImports</strong> 方法确定要导入的类.</p>

<hr />
<center>
    <a href="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/Registrar.jpg">
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" class="img-responsive img-centered" alt="Registrar类图" src="https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/springboot/Registrar.jpg" />
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">Registrar类图</div>
    </a>
</center>

<p>主要看下是实现的 <strong>ImportBeanDefinitionRegistrar</strong> 和 <strong>DeterminableImports</strong> 两个类.<br />
<strong>ImportBeanDefinitionRegistrar</strong> :主要作用是在解析 <strong>@Configuration</strong> 类时,注册额外的bean定义,在启动中对应 <strong>AutoConfigurationPackages.class</strong> .<br />
<strong>DeterminableImports</strong> :主要作用确定要导入对象的集合.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//调用路径</span>
<span class="o">-&gt;</span>  <span class="mi">1</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">.</span><span class="na">SpringApplication</span><span class="err">#</span><span class="n">run</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">...)</span>
<span class="o">-&gt;</span>  <span class="mi">2</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">.</span><span class="na">SpringApplication</span><span class="err">#</span><span class="n">refreshContext</span>
<span class="o">-&gt;</span>  <span class="mi">3</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">support</span><span class="o">.</span><span class="na">AbstractApplicationContext</span><span class="err">#</span><span class="n">refresh</span>
<span class="o">-&gt;</span>  <span class="mi">4</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">support</span><span class="o">.</span><span class="na">AbstractApplicationContext</span><span class="err">#</span><span class="n">invokeBeanFactoryPostProcessors</span>
<span class="o">-&gt;</span>  <span class="mi">5</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">support</span><span class="o">.</span><span class="na">PostProcessorRegistrationDelegate</span><span class="err">#</span><span class="n">invokeBeanDefinitionRegistryPostProcessors</span>
<span class="o">-&gt;</span>  <span class="mi">6</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ConfigurationClassPostProcessor</span><span class="err">#</span><span class="n">postProcessBeanDefinitionRegistry</span>
<span class="o">-&gt;</span>  <span class="mi">7</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ConfigurationClassPostProcessor</span><span class="err">#</span><span class="n">processConfigBeanDefinitions</span>
<span class="o">-&gt;</span>  <span class="mi">8</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ConfigurationClassParser</span><span class="err">#</span><span class="n">parse</span><span class="o">(</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">type</span><span class="o">.</span><span class="na">AnnotationMetadata</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">-&gt;</span>  <span class="mi">9</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ConfigurationClassParser</span><span class="err">#</span><span class="n">doProcessConfigurationClass</span>
<span class="o">-&gt;</span>  <span class="mi">10</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ConfigurationClassParser</span><span class="err">#</span><span class="n">processImports</span>  <span class="c1">//核心调用点 获取spring.factories中所有的EnableAutoConfiguration的子类</span>
<span class="o">-&gt;</span>  <span class="mi">11</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ConfigurationClassParser</span><span class="o">.</span><span class="na">DeferredImportSelectorHandler</span><span class="err">#</span><span class="n">process</span>
<span class="o">-&gt;</span>  <span class="mi">12</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">ConfigurationClassParser</span><span class="o">.</span><span class="na">DeferredImportSelectorGroupingHandler</span><span class="err">#</span><span class="n">processGroupImports</span> <span class="c1">//将所有满足条件的EnableAutoConfiguration的子类注册为bean</span>

<span class="c1">//关键代码分析</span>
<span class="nd">@Nullable</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span>
        <span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">,</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">filter</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="c1">// Process any @Import annotations</span>
    <span class="n">processImports</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">,</span> <span class="n">getImports</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">),</span> <span class="n">filter</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    
    <span class="o">...</span>

<span class="o">}</span>

<span class="cm">/**
 * Returns {@code @Import} class, considering all meta-annotations.
 * 返回所有@Import的类, 考虑所有元注解
 */</span>
<span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="nf">getImports</span><span class="o">(</span><span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">imports</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
    <span class="n">collectImports</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">,</span> <span class="n">imports</span><span class="o">,</span> <span class="n">visited</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">imports</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//这个方法就是处理所有@Import的类</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">processImports</span><span class="o">(</span><span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">currentSourceClass</span><span class="o">,</span>
        <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">importCandidates</span><span class="o">,</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">exclusionFilter</span><span class="o">,</span>
        <span class="kt">boolean</span> <span class="n">checkForCircularImports</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">importCandidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">checkForCircularImports</span> <span class="o">&amp;&amp;</span> <span class="n">isChainedImportOnStack</span><span class="o">(</span><span class="n">configClass</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">problemReporter</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="k">new</span> <span class="nc">CircularImportProblem</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">configClass</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">SourceClass</span> <span class="n">candidate</span> <span class="o">:</span> <span class="n">importCandidates</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//候选类是否属于ImportSelector 主要针对AutoConfigurationImportSelector.class</span>
                <span class="c1">//核心流程:</span>
                <span class="c1">//1.this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span>
                <span class="c1">//2.org.springframework.context.annotation.ConfigurationClassParser.DeferredImportSelectorGroupingHandler#processGroupImports</span>
                <span class="c1">//3.org.springframework.context.annotation.ConfigurationClassParser.DeferredImportSelectorGrouping#getImports</span>
                <span class="c1">//4.org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.AutoConfigurationGroup#process</span>
                <span class="c1">//5.org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getAutoConfigurationEntry</span>
                <span class="c1">//6.org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getCandidateConfigurations 最重要的就是这里获得EnableAutoConfiguration的所有子类</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">isAssignable</span><span class="o">(</span><span class="nc">ImportSelector</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span>
                    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">candidateClass</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="na">loadClass</span><span class="o">();</span>
                    <span class="nc">ImportSelector</span> <span class="n">selector</span> <span class="o">=</span> <span class="nc">ParserStrategyUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">candidateClass</span><span class="o">,</span> <span class="nc">ImportSelector</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
                            <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
                    <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">selectorFilter</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="na">getExclusionFilter</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">selectorFilter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">exclusionFilter</span> <span class="o">=</span> <span class="n">exclusionFilter</span><span class="o">.</span><span class="na">or</span><span class="o">(</span><span class="n">selectorFilter</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">selector</span> <span class="k">instanceof</span> <span class="nc">DeferredImportSelector</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">this</span><span class="o">.</span><span class="na">deferredImportSelectorHandler</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="o">(</span><span class="nc">DeferredImportSelector</span><span class="o">)</span> <span class="n">selector</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="nc">String</span><span class="o">[]</span> <span class="n">importClassNames</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="na">selectImports</span><span class="o">(</span><span class="n">currentSourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">());</span>
                        <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">SourceClass</span><span class="o">&gt;</span> <span class="n">importSourceClasses</span> <span class="o">=</span> <span class="n">asSourceClasses</span><span class="o">(</span><span class="n">importClassNames</span><span class="o">,</span> <span class="n">exclusionFilter</span><span class="o">);</span>
                        <span class="n">processImports</span><span class="o">(</span><span class="n">configClass</span><span class="o">,</span> <span class="n">currentSourceClass</span><span class="o">,</span> <span class="n">importSourceClasses</span><span class="o">,</span> <span class="n">exclusionFilter</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">//候选类是否属于ImportBeanDefinitionRegistrar  主要针对 AutoConfigurationPackages.Registrar.class</span>
                <span class="c1">//将AutoConfigurationPackages.Registrar.class实例化,并通过解析后的org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions方法</span>
                <span class="c1">//中的org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromRegistrars方法注册为bean实例</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">isAssignable</span><span class="o">(</span><span class="nc">ImportBeanDefinitionRegistrar</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span>
                    <span class="c1">// delegate to it to register additional bean definitions</span>
                    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">candidateClass</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="na">loadClass</span><span class="o">();</span>
                    <span class="nc">ImportBeanDefinitionRegistrar</span> <span class="n">registrar</span> <span class="o">=</span>
                            <span class="nc">ParserStrategyUtils</span><span class="o">.</span><span class="na">instantiateClass</span><span class="o">(</span><span class="n">candidateClass</span><span class="o">,</span> <span class="nc">ImportBeanDefinitionRegistrar</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
                                    <span class="k">this</span><span class="o">.</span><span class="na">environment</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">resourceLoader</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">registry</span><span class="o">);</span>
                    <span class="n">configClass</span><span class="o">.</span><span class="na">addImportBeanDefinitionRegistrar</span><span class="o">(</span><span class="n">registrar</span><span class="o">,</span> <span class="n">currentSourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="c1">//候选类不属于以上两个父类  直接进行配置类解析逻辑</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span>
                    <span class="c1">// process it as an @Configuration class</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">registerImport</span><span class="o">(</span>
                            <span class="n">currentSourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="n">candidate</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
                    <span class="n">processConfigurationClass</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">asConfigClass</span><span class="o">(</span><span class="n">configClass</span><span class="o">),</span> <span class="n">exclusionFilter</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">BeanDefinitionStoreException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanDefinitionStoreException</span><span class="o">(</span>
                    <span class="s">"Failed to process import candidates for configuration class ["</span> <span class="o">+</span>
                    <span class="n">configClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">finally</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">importStack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>综上所述, <strong>AutoConfigurationImportSelector.class</strong> 的作用就是找到所有 <strong>EnableAutoConfiguration</strong> 的自动配置子类,并注册为bean定义.<br />
而 <strong>AutoConfigurationPackages.Registrar.class</strong> 的作用就是扫描主配置类同级目录以及子包将所有组件到Spring中</p>

<hr />

<h3 id="componentscan">@ComponentScan</h3>
<blockquote>
  <p>源码</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Nullable</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="nc">SourceClass</span> <span class="nf">doProcessConfigurationClass</span><span class="o">(</span>
        <span class="nc">ConfigurationClass</span> <span class="n">configClass</span><span class="o">,</span> <span class="nc">SourceClass</span> <span class="n">sourceClass</span><span class="o">,</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">filter</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="o">...</span>

	    <span class="c1">// Process any @ComponentScan annotations</span>
        <span class="c1">//处理所有@ComponentScan注解  默认扫描主配置类同级目录及子包</span>
		<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">AnnotationAttributes</span><span class="o">&gt;</span> <span class="n">componentScans</span> <span class="o">=</span> <span class="nc">AnnotationConfigUtils</span><span class="o">.</span><span class="na">attributesForRepeatable</span><span class="o">(</span>
				<span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ComponentScans</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">ComponentScan</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(!</span><span class="n">componentScans</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">conditionEvaluator</span><span class="o">.</span><span class="na">shouldSkip</span><span class="o">(</span><span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">(),</span> <span class="nc">ConfigurationPhase</span><span class="o">.</span><span class="na">REGISTER_BEAN</span><span class="o">))</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">AnnotationAttributes</span> <span class="n">componentScan</span> <span class="o">:</span> <span class="n">componentScans</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span>
				<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">scannedBeanDefinitions</span> <span class="o">=</span>
						<span class="k">this</span><span class="o">.</span><span class="na">componentScanParser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">componentScan</span><span class="o">,</span> <span class="n">sourceClass</span><span class="o">.</span><span class="na">getMetadata</span><span class="o">().</span><span class="na">getClassName</span><span class="o">());</span>
				<span class="c1">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span>
				<span class="k">for</span> <span class="o">(</span><span class="nc">BeanDefinitionHolder</span> <span class="n">holder</span> <span class="o">:</span> <span class="n">scannedBeanDefinitions</span><span class="o">)</span> <span class="o">{</span>
					<span class="nc">BeanDefinition</span> <span class="n">bdCand</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">().</span><span class="na">getOriginatingBeanDefinition</span><span class="o">();</span>
					<span class="k">if</span> <span class="o">(</span><span class="n">bdCand</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
						<span class="n">bdCand</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">();</span>
					<span class="o">}</span>
					<span class="k">if</span> <span class="o">(</span><span class="nc">ConfigurationClassUtils</span><span class="o">.</span><span class="na">checkConfigurationClassCandidate</span><span class="o">(</span><span class="n">bdCand</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">metadataReaderFactory</span><span class="o">))</span> <span class="o">{</span>
						<span class="n">parse</span><span class="o">(</span><span class="n">bdCand</span><span class="o">.</span><span class="na">getBeanClassName</span><span class="o">(),</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanName</span><span class="o">());</span>
					<span class="o">}</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>

        <span class="o">...</span>

<span class="o">}</span>
</code></pre></div></div>
<p>综上所述: <strong>@ComponentScan</strong> 的作用就是扫描主配置目录及子包,并将扫描到的配置类进行解析.</p>

<hr />

<h3 id="总结">总结</h3>
<ol>
  <li>@SpringBootApplication:将主函数声明为可以被Spring管理的bean,并交给Spring解析处理.</li>
  <li>@ComponentScan:扫描主配置目录及子包,并将扫描到的配置类进行解析</li>
  <li>@EnableAutoConfiguration:自动注册所有自动配置的配置类
    <ul>
      <li>@Import(AutoConfigurationImportSelector.class):找到spring.factories中所有EnableAutoConfiguration的子类并按条件过滤注册为bean</li>
      <li>@Import(AutoConfigurationPackages.Registrar.class):将主配置及子包下的所有组件扫描到Spring中</li>
    </ul>
  </li>
</ol>

</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">July 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">SpringBoot</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-9" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-8802433.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>spring</h3>
                            
                            </div>

                            <p><h1 id="spring2">spring2</h1>
<p>spring test2</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test2
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">spring</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-7" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/pexels-luizclas-556666.jpg" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>spring</h3>
                            
                            </div>

                            <p><h1 id="spring">spring</h1>
<p>spring test</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test
</code></pre></div></div>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2021</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">spring</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-1" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/cabin.png" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</h3>
                            
                            </div>

                            <p><p>###　test</p>
<ul>
  <li>
    <啊实打实>
</啊实打实>
  </li>
</ul>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2014</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">Web Development</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-2" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/cake.png" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</h3>
                            
                            </div>

                            <p><p>2</p>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2014</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">Web Development</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-3" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/circus.png" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</h3>
                            
                            </div>

                            <p><p>3</p>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2014</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">Web Development</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-4" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/game.png" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</h3>
                            
                            </div>

                            <p><h4 id="4">4</h4>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2014</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">Web Development</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-6" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/submarine.png" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</h3>
                            
                            </div>

                            <p><h4 id="6">6</h4>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2014</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">Web Development</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="portfolio-modal modal fade" id="portfolioModal-5" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <div align="center">
                            <h2></h2>
                            <hr class="star-primary">
                            <img src="img/portfolio/safe.png" class="img-responsive img-centered" alt="image-alt">

                            
                                <h3>Use this area of the page to describe your project. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Mollitia neque assumenda ipsam nihil, molestias magnam, recusandae quos quis inventore quisquam velit asperiores, vitae? Reprehenderit soluta, eos quod consequuntur itaque. Nam.</h3>
                            
                            </div>

                            <p><h4 id="5">5</h4>
</p>

                            <div align="center">
                            <ul class="list-inline item-details">
                                
                                    <li>Client:
                                        <strong><a href="http://startbootstrap.com">Start Bootstrap</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Date:
                                        <strong><a href="http://startbootstrap.com">April 2014</a>
                                        </strong>
                                    </li>
                                
                                
                                    <li>Service:
                                        <strong><a href="http://startbootstrap.com">Web Development</a>
                                        </strong>
                                    </li>
                                
                            </ul>
                            </div>
                            <div align="center">
                                <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

     <!-- jQuery Version 1.11.0 -->
    <script src="/js/jquery-1.11.0.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="/js/bootstrap.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="/js/jquery.easing.min.js"></script>
    <script src="/js/classie.js"></script>
    <script src="/js/cbpAnimatedHeader.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="/js/jqBootstrapValidation.js"></script>
    
    <script src="/js/contact_me_static.js"></script>
    

    <!-- Custom Theme JavaScript -->
    <script src="/js/freelancer.js"></script>

    

    </body>
</html>