<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2024-07-25T16:43:12+08:00</updated>
  <id>http://localhost:4000/</id>

  
    <title type="html">黄天霸</title>
  

  
    <subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle>
  

  

  
  
    <entry>
      <title type="html">Redissdsdatastructure</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Redissdsdatastructure" />
      <published>2024-07-09T00:00:00+08:00</published>
      <updated>2024-07-09T00:00:00+08:00</updated>
      <id>http://localhost:4000/redisSDSDataStructure</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;redis底层数据结构&quot;&gt;Redis底层数据结构&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;简单动态字符串 - sds&lt;/li&gt;
  &lt;li&gt;压缩列表 - ZipList&lt;/li&gt;
  &lt;li&gt;快表 - QuickList&lt;/li&gt;
  &lt;li&gt;字典/哈希表 - Dict&lt;/li&gt;
  &lt;li&gt;整数集 - IntSet&lt;/li&gt;
  &lt;li&gt;跳表 - ZSkipList&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;简单动态字符串---sds&quot;&gt;简单动态字符串 - sds&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;一种用于存储二进制数据的一种结构，具有动态扩容的特点，其实现位于src/sds.h和src/sds.c中。从版本3.2开始，sds底层数据结构也发生改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;字符串编码类型&lt;/strong&gt;&lt;br /&gt;
字符串有三种 encoding 类型 int 、 raw 、 embstr 。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;int：用于整数类型&lt;/li&gt;
  &lt;li&gt;embstr：用于短字符串&lt;/li&gt;
  &lt;li&gt;raw：用于长字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;定义在 server.h 中，下面列出 string 类型的编码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;br /&gt;
如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型来表示，那么这个整数值将会保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ），并将字符串对象的编码设置为 int 。&lt;br /&gt;
相对于用 raw 编码， int 编码既节省了指针占用的内存，也节省了 sds 结构的内存。&lt;/p&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/string-int.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;int示例&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/string-int.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;int示例&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;embstr&lt;/strong&gt;&lt;br /&gt;
embstr 编码是专门用于保存短字符串的一种优化编码方式。当字符串的长度小于等于 44(redis 3.2版本之前为39) 的时候，将采用 embstr 编码。&lt;br /&gt;
创建字符串对象的代码如下（object.c）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Create a string object with EMBSTR encoding if it is smaller than
 * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is
 * used.
 * 如果字符串小于等于OBJ_ENCODING_EMBSTR_SIZE_LIMIT 创建embstr编码，否则使用raw编码
 *
 * The current limit of 44 is chosen so that the biggest string object
 * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc.
 * 选择当前44的限制是为了作为embstr分配的最大字符串对象仍然适合64字节的jemalloc
 *
 */
#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
robj *createStringObject(const char *ptr, size_t len) {
    if (len &amp;lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return createRawStringObject(ptr,len);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;embstr 有个显著的特点，就是 redisObject 跟 sds 的内存是连在一起的。好处有：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;分配内存的时候只需要分配一次。而 raw 编码的 sds 跟 RedisObject 分离，就是分配两次内存&lt;/li&gt;
  &lt;li&gt;同样，释放内存也只需要释放一次&lt;/li&gt;
  &lt;li&gt;连续内存能更好利用内存带来的优势&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/embstr结构示意图.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;embstr结构示意图&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/embstr结构示意图.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;embstr结构示意图&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;raw&lt;/strong&gt;&lt;br /&gt;
raw 编码主要用来保存长度超过 44（redis 3.2版本之后） 的字符串。其真实数据由sdshdr结构来表示存储，外层还是由 RedisObject 包装。&lt;br /&gt;
sds 的结构大致如下：&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/raw-sds结构.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;raw-sds结构&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/raw-sds结构.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;raw-sds结构&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;redisObject 中的 ptr 指针，就是指向 sds 。&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/raw-robj.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;raw-robj&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/raw-robj.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;raw-robj&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;编码转换&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;int 转 raw&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当字符串传的不是整数的时候，int 就会转成 raw 编码&lt;/li&gt;
  &lt;li&gt;如果执行了一些修改命令，如 append 等（set 不算），都会转成 raw 编码&lt;/li&gt;
  &lt;li&gt;一旦编码变为 raw 之后，将不会再转成 embstr&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;embstr 转 raw&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果执行了一些修改的命令，如 append 等，都会转成 raw 编码，不管修改后字符串的长度。因为没有给 embstr 编码实现修改接口，实际上 embstr 是只读的。&lt;/li&gt;
  &lt;li&gt;一旦编码为 raw 之后，将不会再转成 embstr&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;embstr编码为什么从 39 位修改为 44 位&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;embstr 编码中，RedisObject 和 sds 是一块连续的内存空间，这块内存空间 Redis 限制了 64 个字节，而 RedisObject 固定占了 16 字节，
redis3.2 版本之前的 sds 占了 8 个字节，再加上字符串末尾 \0 占用了 1 个字节，所以：64-16-8-1=39 字节。&lt;br /&gt;
redis3.2 版本之后 sds 做了优化，对于 embstr 编码会采用 sdshdr8 来存储，而 sdshdr8 占用的空间只有 24 位，即 3 字节（len+alloc+flag） + \0 字符(1字节)，
所以最后为： 64-16-3-1=44 字节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;sds结构优化&lt;/strong&gt;&lt;/p&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/sds结构图-3.0.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;sds示例-3.0&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/sds结构图-3.0.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;sds示例-3.0&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#redis3.2 sdshdr结构  

struct sdshdr {
    //记录buf数组中已使用字节的数量  4字节
    //等于SDS所保存字符串的长度
    unsigned int len;

    //记录buf数组中未使用字节的数量  4字节
    unsigned int free;

    //char数组，用于保存字符串
    char buf[];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;len为6，表示这个SDS保存了一个长度为5的字符串  4字节&lt;/li&gt;
  &lt;li&gt;free为0，表示这个SDS没有剩余空间  4字节&lt;/li&gt;
  &lt;li&gt;buf是个char类型的数组，注意末尾保存了一个空字符 ‘\0’(1字节)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#redis6.2 sdshdr结构  

struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */ 已使用 1字节存储
    uint8_t alloc; /* excluding the header and null terminator */ 1字节存储
    unsigned char flags; /* 3 lsb of type, 5 unused bits */ 1字节存储
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;strong&gt;sdshd&lt;/strong&gt; 是头部， &lt;strong&gt;buf&lt;/strong&gt; 是真实存储用户数据的地方，另外注意，从命名上能看出来，这个数据结构除了能存储二进制数据，显然是用于设计作为字符串使用的，所以在 &lt;strong&gt;buf&lt;/strong&gt; 中，用户数据后总跟着一个 &lt;strong&gt;\0&lt;/strong&gt;，即图中的 “数据”+”\0” 就是所谓的buf。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;len:保存了SDS保存字符串的长度  1字节 (len-alloc 即为之前的 free)&lt;/li&gt;
  &lt;li&gt;alloc:分别以uint8, uint16, uint32, uint64表示整个SDS，除头部与末位的 \0，剩余的字节数  1字节&lt;/li&gt;
  &lt;li&gt;flags:始终为 1 字节，以低三位标示着头部的类型，高五位未使用 1字节&lt;/li&gt;
  &lt;li&gt;buf[]:数组用来保存字符串的每个元素，注意末尾保存了一个空字符 ‘\0’(1字节)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，我们还需要注意以下源码中的 &lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;packed&lt;/strong&gt;)) 。它的作用就是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用的字节数进行对齐。&lt;br /&gt;
从上面我们已经知道，结构体会按照所有变量中最宽的基本数据类型做字节对齐。但是用 packed 修饰后，结构体则变为按 1 字节对齐。&lt;br /&gt;
以 sdshdr32 为例，修饰前按 4 字节对齐大小为 12（4&lt;em&gt;3 - len=4;alloc=4;flags=4(实际是1)） 字节；修饰后按 1 字节对齐，共 9 （4&lt;/em&gt;2+1 - len=4;alloc=4;flags=1(实际是1)）  字节。注意 buf 是个 char 类型的柔性数组，地址连续，始终在 flags 之后，packed 修饰前后如下图所示。&lt;/p&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/packed修饰前后示意.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;packed修饰前后示意&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/packed修饰前后示意.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;packed修饰前后示意&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;这样做有两个好处：&lt;br /&gt;
1 - 节省内存：例如 sdshdr32 可节省 3 个字节（12-9）&lt;br /&gt;
2 - SDS 返回给上层的，不是结构体首地址，而是指向内容的 buf 指针。因为此时按 1 字节对齐，故 SDS创建成功后， 无论是 sdshdr8、sdsdhr16、还是 sdshdr32，都能通过 (char*)sh+hdrlen 得到 buf 指针地址（其中 hdrlen 是结构体长度，通过 sizeof 计算得到）。修饰后，无论是 sdshdr8、sdshdr16 还是 sdshdr32，都能通过 buf[-1] 找到 flags，因为此时按 1 字节对齐。若没有 packed 的修饰，还需要对不同结构进行处理，实现更复杂。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;存在问题:&lt;br /&gt;
  不同长度的字符串是否有必要占用大小的头部？一个int占 4 字节，在实际应用中，存放与redis的字符串往往没有这么长，每个字符串都用 4 字节存储未免太浪费空间。&lt;br /&gt;
  短字符串，len 和 free 的长度为 1 字节就够了；长字符串，用 2 字节或 4 字节；更长的字符串，用 8 字节。&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
这样确实更省内存，但依然存在以下问题：&lt;br /&gt;
1-如何区分三种情况？&lt;br /&gt;
2-对于短字符串来说，头部还是太长了。以长度为 1 字节的字符串为例，len 和 free 本身就占了 2 字节，能不能进一步压缩呢？&lt;br /&gt;
对于问题 1，考虑增加一个字符 flags 来标识类型，用最小的 1 字节来存储，且把 flags 加在柔性数组 buf 之前，这样虽然多了 1 字节，但是通过偏移柔性数组的指针即能快速定位 flags ，区分类型也可以接受。&lt;br /&gt;
对于问题 2，由于 len 已经是最小的 1 字节了，再压缩只能考虑用位长来存储长度了。&lt;/p&gt;

&lt;p&gt;  结合以上两个问题，5 中类型（长度 1 字节、2 字节、4 字节、8 字节、小于 1 字节）的SDS至少需要 3 位来存储类型（2^3=8），1 个字节 8 位，剩余的 5 位存储长度，可以满足长度小于 32 的短字符串。&lt;/p&gt;

&lt;p&gt;在 Redis 5.0 中，我们用如下结构来存储长度小于 32 的短字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 低 3 位存储类型，高 5 位存储长度 */
    char buf[];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sdshdr5 结构如下，flags 占 1 个字节，其低三位（bit）表示 type，高 5 位（bit）表示长度。能表示的长度区间为 0~31(2^5)。flags 后面就是字符串的内容。&lt;/p&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/sdshdr5结构.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;sdshdr5结构&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/sdshdr5结构.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;sdshdr5结构&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;而长度大于 31 的字符串，1 字节依然放不下。按之前的思路，将 len 和 free 单独存放。sdshdr8、sdshdr16、sdshdr32和sdshdr64的结构相同，以 sdshdr8 为例，结构如下：&lt;/p&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/sdshdr8结构.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;sdshdr8结构&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/sdshdr8结构.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;sdshdr8结构&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;其中表头共占用了 S[1(len) + 1(alloc) + 1(flags)] 个字节。flags的内容与 sdshdr5 类型，依然采用 3 位存储类型，但剩余 5 位不存储长度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sds源码分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串创建&lt;/strong&gt;&lt;br /&gt;
核心代码在 sds.c#sdsnewlen() :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Create a new sds string with the content specified by the &apos;init&apos; pointer
 * and &apos;initlen&apos;.
 * 通过init指针和initlen指定的内容创建一个新的sds字符串
 * If NULL is used for &apos;init&apos; the string is initialized with zero bytes.
 * 如果init为null 字符串将被初始化为0字节
 * If SDS_NOINIT is used, the buffer is left uninitialized;
 * 如果使用SDS_NOINIT，缓冲区将不会初始化
 *
 * The string is always null-termined (all the sds strings are, always) so
 * even if you create an sds string with:
 * 字符串总是空结尾（适用于所有的sds字符串），即使你创建mystring = sdsnewlen(&quot;abc&quot;,3) 字符串
 *
 * mystring = sdsnewlen(&quot;abc&quot;,3);
 *
 * You can print the string with printf() as there is an implicit \0 at the
 * end of the string. However the string is binary safe and can contain
 * \0 characters in the middle, as the length is stored in the sds header.
 * 你可以通过printl()打印字符串，在字符串末尾会有一个隐含的 \0. 然而 字符串是二进制安全的，可以包含中间的 \0 字符，因为长度存储在sds头部
 *
 */
sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) {
    void *sh;
    sds s;
    //根据字符串长度初始化sds类型
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    //空字符串通常是为了添加而创建。使用 8 代替 5
    if (type == SDS_TYPE_5 &amp;amp;&amp;amp; initlen == 0) type = SDS_TYPE_8;
    //根据上一步获取的type计算header的长度
    int hdrlen = sdsHdrSize(type);
    //标志位的指针
    unsigned char *fp; /* flags pointer. */
    //已分配的空间
    size_t usable;

    assert(initlen + hdrlen + 1 &amp;gt; initlen); /* Catch size_t overflow */
    //申请内存 大小为 头部+字符串大小+null字符串结尾
    sh = trymalloc?
        s_trymalloc_usable(hdrlen+initlen+1, &amp;amp;usable) ://尝试分配内存，失败返回null
        s_malloc_usable(hdrlen+initlen+1, &amp;amp;usable);//分配内存或抛出异常
    if (sh == NULL) return NULL;
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        //初始化内存 将 sh 内存块中前 hdrlen+initlen+1 个字节设置为 0
        memset(sh, 0, hdrlen+initlen+1);
    //将 s 指向字符串的首地址 即指向buf，从首地址向右偏移 hdrlen 长度
    s = (char*)sh+hdrlen;
    //fp 指向头部的最后一个字节 即flag
    fp = ((unsigned char*)s)-1;

    //已使用大小 即申请内容大小减去 头部大小 + 末尾 1 字节占位符
    usable = usable-hdrlen-1;
    if (usable &amp;gt; sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    //根据类型初始化字符串
    switch(type) {
        case SDS_TYPE_5: {
            //sdshdr5 的 flags 的 高5bit 存放着 len， 低3bit位存放着 type
            *fp = type | (initlen &amp;lt;&amp;lt; SDS_TYPE_BITS);
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            sh-&amp;gt;len = initlen;//初始化总长度
            sh-&amp;gt;alloc = usable;//初始化已使用长度
            *fp = type;//初始化类型
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            sh-&amp;gt;len = initlen;
            sh-&amp;gt;alloc = usable;
            *fp = type;
            break;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            sh-&amp;gt;len = initlen;
            sh-&amp;gt;alloc = usable;
            *fp = type;
            break;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            sh-&amp;gt;len = initlen;
            sh-&amp;gt;alloc = usable;
            *fp = type;
            break;
        }
    }
    if (initlen &amp;amp;&amp;amp; init)
        //将 init 字符串的内容复制到 s 中
        memcpy(s, init, initlen);
    //初始化字符串结尾 占位符
    s[initlen] = &apos;\0&apos;;
    return s;
}


/**
 * 根据字符串长度判断 sds类型
 * 1&amp;lt;&amp;lt;5 = 32 :      SDS_TYPE_5
 * 1&amp;lt;&amp;lt;5 = 256:      SDS_TYPE_8
 * 1&amp;lt;&amp;lt;16 = 65536:   SDS_TYPE_16
 * 1&amp;lt;&amp;lt;32 = 4294967296:   SDS_TYPE_32
 * else:   SDS_TYPE_64
 * @param string_size
 * @return
 */
static inline char sdsReqType(size_t string_size) {
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;5)
        return SDS_TYPE_5;
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;8)
        return SDS_TYPE_8;
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;16)
        return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size &amp;lt; 1ll&amp;lt;&amp;lt;32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}


/**
 * 获取不同类型头部长度
 * @param type 
 * @return 
 */
static inline int sdsHdrSize(char type) {
    switch(type&amp;amp;SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return sizeof(struct sdshdr5);
        case SDS_TYPE_8:
            return sizeof(struct sdshdr8);
        case SDS_TYPE_16:
            return sizeof(struct sdshdr16);
        case SDS_TYPE_32:
            return sizeof(struct sdshdr32);
        case SDS_TYPE_64:
            return sizeof(struct sdshdr64);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br /&gt;
根据字符串长度选择合适的 sds 类型并分配内存，根据字符串类型初始化 sds 。返回值是 sds 结构中 buf 的指针。&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串扩容&lt;/strong&gt;&lt;br /&gt;
核心代码在 sds.c#sdscat()#sdsMakeRoomFor()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Append the specified null terminated C string to the sds string &apos;s&apos;.
 * 将指定的以空结尾的C字符串追加到sds字符串 &apos;s&apos;后面
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串不再有效，所有的引用必须被该调用返回的指针替代
 */
sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}

/* Append the specified binary-safe string pointed by &apos;t&apos; of &apos;len&apos; bytes to the
 * end of the specified sds string &apos;s&apos;.
 * 将指定的以空结尾的C字符串追加到sds字符串 &apos;s&apos;后面
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串不再有效，所有的引用必须被该调用返回的指针替代
 */
sds sdscatlen(sds s, const void *t, size_t len) {
    //获取字符串 s 的长度，即取 len 属性 sds5取flags的高五位
    size_t curlen = sdslen(s);
    //字符串扩容
    s = sdsMakeRoomFor(s,len);
    if (s == NULL) return NULL;
    //将 len 长度 t 复制到 s字符串中， 从 s+curlen 位置开始
    memcpy(s+curlen, t, len);
    //更新字符串长度 即len属性， sds5更新flags的高五位
    sdssetlen(s, curlen+len);
    //末尾添加占位符
    s[curlen+len] = &apos;\0&apos;;
    return s;
}


/* Enlarge the free space at the end of the sds string so that the caller
 * is sure that after calling this function can overwrite up to addlen
 * bytes after the end of the string, plus one more byte for nul term.
 * 扩大sds字符串末尾的可用空间，调用后可以保证在字符串结束后覆盖最多 addlen 个字节，再加上一个字节为 null 占位符
 *
 * Note: this does not change the *length* of the sds string as returned
 * by sdslen(), but only the free buffer space we have.
 * 注意：他不会改变 sds 字符串的长度，例如调用 sdslen()， 但是只有可用的缓冲空间
 */
sds sdsMakeRoomFor(sds s, size_t addlen) {
    void *sh, *newsh;
    //获取可用空间 即 len-alloc=free
    size_t avail = sdsavail(s);
    size_t len, newlen, reqlen;
    //获取 s 字符串类型 s指向buf的指针，s[-1]即为flags地址
    char type, oldtype = s[-1] &amp;amp; SDS_TYPE_MASK;
    int hdrlen;
    size_t usable;

    /* Return ASAP if there is enough space left. */
    //如果 可用大于 addlen 直接返回
    if (avail &amp;gt;= addlen) return s;

    //获取字符串长度
    len = sdslen(s);
    //将指针向左偏移 hdr 长度，即当前指针指向 sds头部，而不是从 buf 开始
    sh = (char*)s-sdsHdrSize(oldtype);
    //初始化新增的长度
    reqlen = newlen = (len+addlen);
    assert(newlen &amp;gt; len);   /* Catch size_t overflow */
    //如果拼接字符串后的长度小于 1M， 则扩容为拼接字符串后长度的两倍
    if (newlen &amp;lt; SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        //否则在拼接长度的基础上新增 1M
        newlen += SDS_MAX_PREALLOC;

    //根据最终字符串长度 获取字符串类型
    type = sdsReqType(newlen);

    /* Don&apos;t use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    //获取新字符串类型长度
    hdrlen = sdsHdrSize(type);
    assert(hdrlen + newlen + 1 &amp;gt; reqlen);  /* Catch size_t overflow */
    //如果扩容后结构体不变
    if (oldtype==type) {
        //根据原始字符串及扩容后的长度重新分配内存，并将内容复制到新内存中，并清空原内存空间
        //usable会被设置为当前分配的大小
        newsh = s_realloc_usable(sh, hdrlen+newlen+1, &amp;amp;usable);
        if (newsh == NULL) return NULL;
        //将 s 字符串指针指向 buf 数组
        s = (char*)newsh+hdrlen;
    } else {
        /* Since the header size changes, need to move the string forward,
         * and can&apos;t use realloc */
        //由于头部长度改变，需要向前移动字符串，不能使用内存重新分配
        //分配最新长度的内存空间，从堆上重新申请数据空间
        newsh = s_malloc_usable(hdrlen+newlen+1, &amp;amp;usable);
        if (newsh == NULL) return NULL;
        //将 len+1 长度的 s 内容复制新内存空间中
        memcpy((char*)newsh+hdrlen, s, len+1);
        //释放原内容空间
        s_free(sh);
        //将 s 字符串指针指向 buf 数组
        s = (char*)newsh+hdrlen;
        //设置字符串类型 flags
        s[-1] = type;
        //更新新字符串长度
        sdssetlen(s, len);
    }
    //获取实际可用数据空间
    usable = usable-hdrlen-1;
    if (usable &amp;gt; sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    //设置新字符串已使用总长度 alloc
    sdssetalloc(s, usable);
    return s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br /&gt;
扩容阶段：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若 SDS 中剩余空闲空间 avail 大于新增内容的长度 addlen，则无需扩容；&lt;/li&gt;
  &lt;li&gt;若 SDS 中剩余空闲空间 avail 小于或等于新增内容的长度 addlen：
    &lt;ul&gt;
      &lt;li&gt;若新增后的总长度 len+addlen &amp;lt; 1MB ，则按新长度的两倍扩容；&lt;/li&gt;
      &lt;li&gt;若新增后的总长度 len+addlen &amp;gt; 1MB ，则按新长度加上 1MB 扩容。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内容分配阶段：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据扩容后的长度选择对应的SDS类型：
    &lt;ul&gt;
      &lt;li&gt;若类型不变，则只需通过 s_realloc_usable 扩大 buf 数组即可；&lt;/li&gt;
      &lt;li&gt;若类型变化，则需要为整个 SDS 重新分配内存，并将原来的 SDS 内容拷贝至新位置。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/sdsMakeRoomFor流程图.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;sdsMakeRoomFor流程图&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/sdsMakeRoomFor流程图.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;sdsMakeRoomFor流程图&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串释放（惰性空间释放）&lt;/strong&gt;&lt;br /&gt;
重置len属性清空SDS在 sds.c#sdsclear()&lt;br /&gt;
真正清空SDS在 sds.c#sdsfree()&lt;br /&gt;
清空空闲缓存在 sds.c#sdsRemoveFreeSpace()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Modify an sds string in-place to make it empty (zero length).
 * However all the existing buffer is not discarded but set as free space
 * so that next append operations will not require allocations up to the
 * number of bytes previously available.
 * 原地修改 SDS 字符串使用为空（长度为0）
 * 但是所有的缓冲区不会被丢弃而是被设置为空闲区域，这样下一个追加操作不需要分配之前可用的字节数
 */
void sdsclear(sds s) {
    //将长度设置为0
    sdssetlen(s, 0);
    s[0] = &apos;\0&apos;;
}

/* Free an sds string. No operation is performed if &apos;s&apos; is NULL.
 * 释放 sds字符串。当 s 为 NULL 时不会执行任何操作
 */
void sdsfree(sds s) {
    if (s == NULL) return;
    //s-sdsHdrSize(s[-1]):指针指向sds起始地址  s_free释放内存
    s_free((char*)s-sdsHdrSize(s[-1]));
}

/* Reallocate the sds string so that it has no free space at the end. The
 * contained string remains not altered, but next concatenation operations
 * will require a reallocation.
 * 重新分配sds字符串，使得结尾没有任何空余空间。
 * 原来包含的字符串不会改动，但是下一个串联操作将需要重新分配内存
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串将不再有效。且所有的引用将被调用返回的新指针代替
 */
sds sdsRemoveFreeSpace(sds s, int would_regrow) {
    return sdsResize(s, sdslen(s), would_regrow);
}

/* Resize the allocation, this can make the allocation bigger or smaller,
 * if the size is smaller than currently used len, the data will be truncated.
 * 调整分配大小，这可以使分配更大或更小，如果大小小于当前已使用的长度，数据将被截断
 *
 * The when the would_regrow argument is set to 1, it prevents the use of
 * SDS_TYPE_5, which is desired when the sds is likely to be changed again.
 * 当would_regrow参数为1时，它将阻止使用sds5，这是在sds可能再次更改时所需要的
 *
 * The sdsAlloc size will be set to the requested size regardless of the actual
 * allocation size, this is done in order to avoid repeated calls to this
 * function when the caller detects that it has excess space.
 * 无论实际大小多少，sdsAlloc大小都将被设置为请求的大小，这么做是为了当调用者检测到它有多余的空间时防止重复调用此方法
 */
sds sdsResize(sds s, size_t size, int would_regrow) {
    void *sh, *newsh;
    //取原sds类型
    char type, oldtype = s[-1] &amp;amp; SDS_TYPE_MASK;
    //取原sds头部长度
    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);
    //取sds 长度
    size_t len = sdslen(s);
    //指针指向sds起始位置
    sh = (char*)s-oldhdrlen;

    /* Return ASAP if the size is already good. */
    //如果大小已经满足则直接满足  即 len=alloc
    if (sdsalloc(s) == size) return s;

    /* Truncate len if needed. */
    //如果size小于len 直接直接截断
    if (size &amp;lt; len) len = size;

    /* Check what would be the minimum SDS header that is just good enough to
     * fit this string. */
    //根据size  重新计算sds类型
    type = sdsReqType(size);
    if (would_regrow) {
        /* Don&apos;t use type 5, it is not good for strings that are expected to grow back. */
        //不要使用type5， 它不适合那些期望增长回来的字符串
        if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    }
    //根据sds类型计算头部大小
    hdrlen = sdsHdrSize(type);

    /* If the type is the same, or can hold the size in it with low overhead
     * (larger than SDS_TYPE_8), we just realloc(), letting the allocator
     * to do the copy only if really needed. Otherwise if the change is
     * huge, we manually reallocate the string to use the different header
     * type.
     * 如果类型相同，或可以用低位表示大小（type大于8），我们只需要 realloc()，让分配器只在真正需要的时候进行复制。
     * 如果改变很大，根据不同的头部大小手动重新分配内存
     */
    //判断是需要重新分配
    int use_realloc = (oldtype==type || (type &amp;lt; oldtype &amp;amp;&amp;amp; type &amp;gt; SDS_TYPE_8));
    //若重新分配使用原类型
    size_t newlen = use_realloc ? oldhdrlen+size+1 : hdrlen+size+1;
    int alloc_already_optimal = 0;
    #if defined(USE_JEMALLOC)
        /* je_nallocx returns the expected allocation size for the newlen.
         * We aim to avoid calling realloc() when using Jemalloc if there is no
         * change in the allocation size, as it incurs a cost even if the
         * allocation size stays the same. */
        alloc_already_optimal = (je_nallocx(newlen, 0) == zmalloc_size(sh));
    #endif

    //使用重新分配内存
    if (use_realloc &amp;amp;&amp;amp; !alloc_already_optimal) {
        //根据newlen重新分配内存
        newsh = s_realloc(sh, newlen);
        if (newsh == NULL) return NULL;
        //指针指向 buf 缓冲区
        s = (char*)newsh+oldhdrlen;
    } else if (!alloc_already_optimal) {
        //使用新建内存空间 新分配newlen的空间
        newsh = s_malloc(newlen);
        if (newsh == NULL) return NULL;
        //将s的len长度内存复制到newsh+hdrlen中
        memcpy((char*)newsh+hdrlen, s, len);
        //释放sh
        s_free(sh);
        //指针指向 buf缓冲区
        s = (char*)newsh+hdrlen;
        //设置flgas类型
        s[-1] = type;
    }
    //设置字符串末尾占位符
    s[len] = 0;
    //更新长度
    sdssetlen(s, len);
    //更新已使用大小
    sdssetalloc(s, size);
    return s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br /&gt;
redis提供了三种方法清空 SDS。&lt;br /&gt;
sdsclear：重置len属性，不直接释放内存，新的数据可以复写，而不用重新申请内存。&lt;br /&gt;
sdsfree：通过 s_free 释放内存。&lt;br /&gt;
sdsRemoveFreeSpace：清空未使用缓存空间，执行字符串相关指令时通过 tryObjectEncoding 触发或通过 clientsCron 定时触发。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;为什么使用sds&quot;&gt;为什么使用sds&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;常数复杂度获取字符串长度&lt;br /&gt;
由于len属性的存在，我们获取sds字符串的长度只需要获取len属性，时间复杂度为O(1)。而对于C语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为O(n)。通过&lt;strong&gt;strlen key&lt;/strong&gt;命令可以获取key的字符串长度。&lt;/li&gt;
  &lt;li&gt;杜绝缓冲区溢出&lt;br /&gt;
在C语言中使用strcat函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间就会造成缓冲区溢出。而对于SDS数据类型，在进行字符修改的时候，会首先根据记录的len属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。&lt;/li&gt;
  &lt;li&gt;减少修改字符串的内存重分配次数&lt;br /&gt;
C语言由于不记录字符串长度，所以如果要修改字符串，必须要重新分配内存，如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄漏。&lt;br /&gt;
而对于SDS，由于len和alloc属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略:
    &lt;ol&gt;
      &lt;li&gt;空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。&lt;/li&gt;
      &lt;li&gt;惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重分配来回收缩短后多余的字节，而是使用&lt;strong&gt;alloc&lt;/strong&gt;属性将这些字节的数量记录下来，等待后续使用。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;二进制安全&lt;br /&gt;
因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件，内容可能包括空字符串，因此C字符串无法正确存取；而所有SDS的API都是以处理二进制的方式来处理buf里面的元素，并且SDS不是以空字符串来判断是否结束，而是以len属性表示的长度来判断字符串是否结束。&lt;/li&gt;
  &lt;li&gt;兼容部分C字符串函数&lt;br /&gt;
虽然SDS是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用C语言库 string.h 中的一部分函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;空间预分配进一步理解&quot;&gt;空间预分配进一步理解&lt;/h5&gt;
&lt;p&gt;当执行追加操作时，比如现在给key=’Hello World’的字符后追加’ again!’，则这时的len=18，free由0变成了18，此时的 buf=’Hello World again!\0………………’(.表示空格)，也就是buf的内存空间是18+18+1=37字节，其中’\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，
就无须在进行空间分配了。在当前版本中，当新字符串长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。&lt;br /&gt;
思考：&lt;strong&gt;这种分配策略会浪费内存资源吗？&lt;/strong&gt; &lt;br /&gt;
答：执行过APPEND命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭redis之后，再次启动时重新载入的字符串对象将不会有预分配空间。
因为执行APPEND命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND操作的键很多，而字符串的体积又很大的话，那可能就需要修改redis服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;小结&quot;&gt;小结&lt;/h5&gt;
&lt;p&gt;redis的字符串表示为sds，而不是C字符串（以\0结尾的char*），它是redis底层所使用的字符串表示，对比如下：&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/sds/sds和c字符串对比.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;字符串对比图&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/sds/sds和c字符串对比.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;redis字符串对比图&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h3 id=&quot;压缩列表---ziplist&quot;&gt;压缩列表 - ZipList&lt;/h3&gt;

&lt;h3 id=&quot;快表---quicklist&quot;&gt;快表 - QuickList&lt;/h3&gt;

&lt;h3 id=&quot;字典哈希表---dict&quot;&gt;字典/哈希表 - Dict&lt;/h3&gt;

&lt;h3 id=&quot;整数集---intset&quot;&gt;整数集 - IntSet&lt;/h3&gt;

&lt;h3 id=&quot;跳表---zskiplist&quot;&gt;跳表 - ZSkipList&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://pdai.tech/md/db/nosql-redis/db-redis-overview.html&lt;br /&gt;
https://blog.wangjunfeng.com/post/redis-sds/&lt;br /&gt;
https://juejin.cn/post/7064359936842530830&lt;br /&gt;
https://www.cnblogs.com/chenchuxin/p/14189925.html&lt;br /&gt;
https://cloud.tencent.com/developer/article/1911682&lt;br /&gt;
https://www.cnblogs.com/chenchuxin/p/14204452.html&lt;br /&gt;
https://juejin.cn/post/6894539895084154887&lt;br /&gt;
https://blog.csdn.net/yangbodong22011/article/details/78419966&lt;br /&gt;
https://www.aphysia.cn/archives/redis-2—sdsyuan-ma-fen-xi&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="redis" />
      

      

      
        <summary type="html">Redis底层数据结构 简单动态字符串 - sds 压缩列表 - ZipList 快表 - QuickList 字典/哈希表 - Dict 整数集 - IntSet 跳表 - ZSkipList</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Redisobject</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Redisobject" />
      <published>2024-06-24T00:00:00+08:00</published>
      <updated>2024-06-24T00:00:00+08:00</updated>
      <id>http://localhost:4000/redisObject</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/redisObject/redisObject.jpg&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;redisObject&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/redisObject/redisObject.jpg&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;redisObject概览&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;p&gt;    上图展示了redisObject，Redis所有数据类型、Redis所欲编码方式以及底层数据结构之间的关系。&lt;br /&gt;
    它反映了redis的每种对象其实都由 &lt;strong&gt;对象结构（redisObject）&lt;/strong&gt; 与 &lt;strong&gt;对应编码的数据结构&lt;/strong&gt; 组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。&lt;br /&gt;
所以，我们需要从几个角度来研究：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对象设计机制：对象结构（redisObject）&lt;/li&gt;
  &lt;li&gt;编码类型和底层数据结构：对应编码的数据结构&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;为什么设计redisobject对象&quot;&gt;为什么设计redisObject对象&lt;/h3&gt;

&lt;p&gt;    在redis的命令中，用于对键进行处理的命令占了很大一部分，而对于键所保存的值的类型（键的类型），键能执行的命令又各不相同。
如：LPUSH和LLEN只能用于列表键，而SADD和SRANDMEMBER只能用于集合键等；另外一些命令，比如DEL、TTL和TYPE，可以用于任何类型的键；但是要正确实现这些命令，
必须为不同类型的键设置不同的处理方式，比如说，删除一个列表键和删除一个字符串键的操作过程就不太一样。&lt;br /&gt;
    故：&lt;strong&gt;Redis必须让每个键都带有类型信息，使得程序可以检查键的类型，并为它选择合适的处理方式。&lt;/strong&gt;&lt;br /&gt;
    比如说，集合类型就可以由字典和整数集合两种不同的数据结构实现，但是当用户执行ZADD命令时，它不关心集合使用的是什么编码，只要Redis能按照ZADD命令的指示，将新元素添加到集合就可以了。&lt;br /&gt;
    这说明，&lt;strong&gt;操作数据类型的命令除了要对键的类型进行检查之外，还需要根据数据类型的不同编码进行多态处理。&lt;/strong&gt;&lt;br /&gt;
    为了解决以上问题，Redis构建了自己的类型系统，这个系统的主要功能包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;redisObject对象&lt;/li&gt;
  &lt;li&gt;基于redisObject对象的类型检查&lt;/li&gt;
  &lt;li&gt;基于redisObject对象的显示多态函数&lt;/li&gt;
  &lt;li&gt;对redisObject进行分配、共享和销毁的机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;redisobject数据结构&quot;&gt;redisObject数据结构&lt;/h3&gt;
&lt;p&gt;    redisObject是Redis类型系统的核心，数据库中的每个键、值以及Redis本身处理的参数，都表示为这种数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;typedef struct redisObject {
    unsigned type:4;            //redisObject的类型    4bit
    unsigned encoding:4;        //同一种类型的不同编码方式  4bit
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or  
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
                            //记录RedisObject的访问时间信息      24bit
                            //LRU时间（相对于全局 lru_clock）
                            //LFU数据(最低有效的8位频率和最高有效的16位访问时间)
    int refcount;           //引用计数      32bit
    void *ptr;              //指向底层实现数据结构的指针     64bit
} robj;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redisObject占用 16 个字节( 4 + 4 + 24 + 32 + 64 = 128 位)。&lt;br /&gt;
其中type、encoding和ptr是最重要的三个属性。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;type记录了对象所保存的值的类型，它的值可能是以下常量中的一个：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* A redis object, that is a type able to hold a string / list / set */

/* The actual Redis Object */
//真正的redis对象
#define OBJ_STRING 0    /* String object. */
#define OBJ_LIST 1      /* List object. */
#define OBJ_SET 2       /* Set object. */
#define OBJ_ZSET 3      /* Sorted set object. */
#define OBJ_HASH 4      /* Hash object. */
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;encoding记录了对象所保存的值的编码，它的值可能是以下常量中的一个：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Objects encoding. Some kind of objects like Strings and Hashes can be
 * internally represented in multiple ways. The &apos;encoding&apos; field of the object
 * is set to one of this fields for this object.
    对象编码。像字符串和哈希这种对象内部可以有多种方式标识。 encoding字段被设置为该对象的其中一个字段
 */
#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ptr是一个指针，指向实际保存值的数据结构，这个数据结构由type和encoding属性决定。&lt;br /&gt;
举个例子，如果一个redisObject的type属性为 OJB_LIST ，encoding属性为 OBJ_ENCODING_QUICKLIST，那么这个对象就是一个Redis列表（List），它的值保存在一个QuickList的数据结构内，而ptr指针就指向quickList的对象；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lru属性：记录了对象最后一次被命令程序访问的时间&lt;br /&gt;
    空转时长：当前时间减去键的值对象lru时间，就是该键的空转时长。Redis idletime命令可以打印出给定键的空转时长。&lt;br /&gt;
    如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;命令的类型检查和多态&quot;&gt;命令的类型检查和多态&lt;/h3&gt;

&lt;p&gt;当执行一个处理数据类型命令的时候，redis执行以下步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；&lt;/li&gt;
  &lt;li&gt;检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；&lt;/li&gt;
  &lt;li&gt;根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；&lt;/li&gt;
  &lt;li&gt;返回数据结构的操作结果作为命令的返回值；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;对象共享&quot;&gt;对象共享&lt;/h3&gt;

&lt;p&gt;    redis一般会把一些常见的值放在一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。&lt;br /&gt;
redis预分配的值对象如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE等等&lt;/li&gt;
  &lt;li&gt;包括0在内，小于REDIS_SHARED_INTEGERS的所有整数&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等的内存数据结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;    为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象？&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高&lt;/li&gt;
  &lt;li&gt;如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)&lt;/li&gt;
  &lt;li&gt;如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度是O(N)&lt;/li&gt;
  &lt;li&gt;如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其他对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N^2)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;引用计数以及对象的销毁&quot;&gt;引用计数以及对象的销毁&lt;/h3&gt;

&lt;p&gt;    redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；&lt;/li&gt;
  &lt;li&gt;当新创建一个对象时，它的refcount属性被设置为1；&lt;/li&gt;
  &lt;li&gt;当对一个对象进行共享时，redis将这个对象的rfcount加一；&lt;/li&gt;
  &lt;li&gt;当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的rfcount减一；&lt;/li&gt;
  &lt;li&gt;当对象的rfcount降至0时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放；&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html
https://axlgrep.github.io/tech/redis-object.html&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="redis" />
      

      

      
        <summary type="html">redisObject概览</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Redis Guide</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Redis Guide" />
      <published>2024-06-11T00:00:00+08:00</published>
      <updated>2024-06-11T00:00:00+08:00</updated>
      <id>http://localhost:4000/redis-guide</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;redis-为什么这么快&quot;&gt;Redis 为什么这么快&lt;/h3&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/redis/guide/whyRedisFast.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;Why is Redis so fast&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/redis/guide/whyRedisFast.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;Why is Redis so fast&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h3 id=&quot;完全基于内存&quot;&gt;完全基于内存&lt;/h3&gt;

&lt;p&gt;    redis作为一种内存导向型数据库系统，其关键特性在于将所有的数据实体，包括键值对及其相关的复杂数据结构，完全寄宿于内存之中。相较于依赖磁盘存储的传统数据库系统，redis巧妙地运用内存的高速读写特性，显著提升了系统的响应速度与整体性能表现。&lt;br /&gt;
    内存相对于磁盘具备无可比拟的读写速度优势，使得redis能够即时、高效地处理数据存取。在读取操作层面，redis无需经过耗时的磁盘I/O过程。只需要在内存空间内迅速定位所需数据，从而显著降低了访问延迟；而在写入操作时，redis同样直接作用于内存区域，新数据能立刻生效，仅在执行持久化策略时，例如RDB快照或AOF日志记录，数据才会被异步地或按需地同步到磁盘，以确保在系统重启后数据还能恢复，但此过程并不会妨碍redis在常规操作中维持其卓越的性能表现。&lt;br /&gt;
    服务器的内存是有限的，redis究竟是如何在有限内存空间中进行精细且高效的内存管理呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过期键删除&lt;/strong&gt;&lt;br /&gt;
    Redis支持为键设置过期时间（TTL），并且在键过期后会通过两种方式自动删除它们:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;惰性删除（Lazy Expire）：
  在访问某个键时，Redis会检查该键是否已经过期，如果已经过期，则在访问时将其删除。这意味胡总只有当客户端尝试访问过期键时，Redis才会执行删除操作。这种方式的优势在于避免了不必要的操作，只有在需要时才进行删除，但缺点是可能会导致过期键在一段时间内仍然占用内存。&lt;/li&gt;
  &lt;li&gt;定期删除（Active Expire）： 
  Redis周期性地（默认每秒10次）随机抽取一部分键，并检查它们的过期时间。如果发现某个键已经过期，则立即删除。这种方式可以保证过期键在一定时间内被及时删除，避免了过期键长时间占用内存。但定期删除会带来额外的CPU消耗，因为需要再每次抽取时检查键的过期时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    这两种方式结合起来，可以有效地管理和清理过期键，保证Redis的内存使用在合理范围内。同时，我们在日常开发中可以根据具体业务场景和需求调整过期策略的配置，以达到最佳的性能和内存利用率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存淘汰策略&lt;/strong&gt;&lt;br /&gt;
    内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的maxmemory），Redis会根据预先设置的淘汰策略来选择要删除的键，从而释放内存空间。通过合理选择和配置内存淘汰策略，可以有效地管理内存使用，防止内存溢出，并保证系统的稳定性和性能。&lt;br /&gt;
    常见的内存淘汰策略：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;LRU（最近最少使用）&lt;br /&gt;
   LRU策略会删除最近最少被访问的键。Redis会记录每个键最好一次被访问的时间戳，并定期检查这些时间戳，选择最久未被访问的键进行删除。LRU策略适用于缓存场景，通常最久未被访问的键可能是最不常用的，因此删除这些键可以释放更多的内存空间。&lt;/li&gt;
  &lt;li&gt;LFU（最不经常使用）&lt;br /&gt;
   LFU策略会删除最不经常被访问的键。Redis会记录每个键被访问的频率，并定期检查这些频率，选择访问频率最低的键进行删除。LFU策略适用于对访问频率较低的键进行淘汰，从而释放内存空间。&lt;/li&gt;
  &lt;li&gt;TTL（键的过期时间）&lt;br /&gt;
   TTL策略会删除已经过期的键。Redis会定期检查键的过期时间，并删除已经过期的键。通过设置键的过期时间，可以自动清理不再需要的数据，释放内存空间。&lt;/li&gt;
  &lt;li&gt;随机删除&lt;br /&gt;
   随机删除策略会随机选择一些键进行删除。虽然这种策略不考虑键的使用频率或过期时间，但在某些情况下可能会是一种简单且有效地淘汰方式，尤其在内存空间不足时。&lt;/li&gt;
  &lt;li&gt;淘汰固定数量的键&lt;br /&gt;
   淘汰固定数量的键策略会选择要删除的键数量，然后安装一定的规则（如LRU或LFU）来选择要删除的键。这种策略可以保证每次淘汰都释放固定数量的内存空间。&lt;br /&gt;
   当Redis的内存使用达到配置的 &lt;strong&gt;maxmemory&lt;/strong&gt; 限制时，就会触发内存淘汰策略，以释放内存空间。合理选择内存淘汰策略，并根据系统的需求设置 &lt;strong&gt;maxmemory&lt;/strong&gt; 参数，可以有效地管理内存使用，保证系统的稳定性和性能。通过合理配置内存限制和内存淘汰策略，可以有效地管理Redis的内存使用，保证系统在内存空间不足时能够及时释放内存，避免因内存溢出而导致系统功能下降或者崩溃。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;修改内存 &lt;strong&gt;maxmemory&lt;/strong&gt; 只需要在 &lt;strong&gt;redis.config&lt;/strong&gt; 配置文件中配置 &lt;strong&gt;maxmemory-policy&lt;/strong&gt; 参数即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;内存碎片管理&lt;/strong&gt;&lt;br /&gt;
    内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。&lt;br /&gt;
    在Redis中，由于数据的增删改查操作不断进行，会导致内存空间中出现大量的内存碎片。这些内存碎片虽然单个很小，但如果积累起来会导致内存碎片化，降低内存利用率，影响系统的性能和稳定性。&lt;br /&gt;
    为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;遍历内存空间：Redis会遍历整个内存空间，检查每个内存块的状态，包含已分配和未分配的内存块。&lt;/li&gt;
  &lt;li&gt;合并相邻的空闲内存块：Redis会尝试合并相邻的空间内存块，将它们合并成一个更大的内存块。这样可以减少内存碎片的数量，提高内存利用率。&lt;/li&gt;
  &lt;li&gt;移动数据：如果有必要，Redis可能会将数据从一个内存块移动到另一个内存块，以便更好地组织内存空间。这个过程可能会比较耗时，因为需要将数据从一个位置复制到另一个位置。&lt;/li&gt;
  &lt;li&gt;释放不再使用的内存块：最后，Redis会释放那些不再使用的内存块，以便它们可以被重新分配给新的数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    通过定期进行内存碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化的程度，提高内存利用率，从而提高系统的性能和稳定性。但是，内存碎片整理过程可能会消耗一定的系统资源，尤其在内存碎片较多的情况下。所以，通常情况下，Redis会选择在系统负载较低的时候进行碎片整理操作。&lt;/p&gt;

&lt;h3 id=&quot;高效的数据结构&quot;&gt;高效的数据结构&lt;/h3&gt;

&lt;p&gt;    Redis的每种对象其实都由 &lt;strong&gt;对象结构（redisObject）&lt;/strong&gt; 与 &lt;strong&gt;对应编码的数据结构&lt;/strong&gt; 组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://markdown.com.cn/basic-syntax/blockquotes.html
https://www.cnblogs.com/coderacademy/p/18099027
https://redis.io/docs/latest/develop/data-types/
https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="redis" />
      

      

      
        <summary type="html">Redis 为什么这么快</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Introduce</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Introduce" />
      <published>2024-01-10T00:00:00+08:00</published>
      <updated>2024-01-10T00:00:00+08:00</updated>
      <id>http://localhost:4000/introduce</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h1 id=&quot;图例&quot;&gt;图例&lt;/h1&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD基本概念.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;DDD基本概念&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD基本概念.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;DDD基本概念&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD脑图.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;DDD脑图&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD脑图.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;DDD脑图&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h1 id=&quot;基本概念&quot;&gt;基本概念&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;通用类概念
    &lt;ol&gt;
      &lt;li&gt;领域驱动设计（DDD）&lt;br /&gt;
&lt;strong&gt;DDD是Domain-Driven Design的缩写，是Eric Evans于2004年提出的一种软件设计方法和理念。&lt;/strong&gt;&lt;br /&gt;
其主要思想是利用确定的业务模型来指导业务与应用的设计和实现。主张开发人员与业务人员持续地沟通和模型的持续迭代式演化，以保证业务模型与代码实现的一致性，从而实现有效管理业务复杂度，优化软件设计的目的。&lt;/li&gt;
      &lt;li&gt;模型（Model）&lt;br /&gt;
&lt;strong&gt;通常，模型是对对象、人或系统的信息表示。它通过较为简单的信息结构来代表我们需要理解的复杂事物或系统。&lt;/strong&gt;&lt;br /&gt;
地图、乐高都是模型，模型可以简化复杂事物的认知。通俗来说模型就是经验的抽象集合，平时听到的谚语、公式、定理，本质上都是一种模型。&lt;/li&gt;
      &lt;li&gt;建模（Modeling）&lt;br /&gt;
&lt;strong&gt;建模是构建模型的过程。&lt;/strong&gt;&lt;br /&gt;
在软件设计过程中，通过分析业务，将业务需求使用合适的模型表示出来，是建模的任务。模型可以作为业务分析的输出，并作为软件设计的重要理论基础。比如在分析一个电商应用的业务时，抽象出订单、商品等概念，进一步定义出模型，并用合适的图例表达，往往是UML来表达。&lt;/li&gt;
      &lt;li&gt;模型驱动设计（Model-Driven Design）&lt;br /&gt;
&lt;strong&gt;面向模型的设计方法，优先通过识别模型来简化业务设计。&lt;/strong&gt;&lt;br /&gt;
设计过程中，以模型的为中心，始终维护模型，并基于此指导设计。&lt;/li&gt;
      &lt;li&gt;软件设计（The Software Design）&lt;br /&gt;
&lt;strong&gt;软件设计从需求出发，对软件系统的整体结构、模块做出划分和规划，以便于具体代码的编写。&lt;/strong&gt;&lt;br /&gt;
由于软件具有非结构化、准确的定义，软件设计往往通过经验完成，无法通过某种特定的推理路线严格推导实现。&lt;/li&gt;
      &lt;li&gt;战略设计（Strategic Design）&lt;br /&gt;
&lt;strong&gt;战略设计也称为战略建模，是指对业务进行高层次的抽象和归类，主要手段包括理清上下文和进行子域的划分。&lt;/strong&gt;&lt;br /&gt;
战略设计关注模型的分离，其解决的问题的大的模型如何划分为小模型以及相互之间如何关联。战略设计的产出可以用于指导团队协作，使得规模巨大的软件可以被合理拆分。&lt;br /&gt;
战略设计的产出通常为上下文图，以及模块及微服务划分。&lt;/li&gt;
      &lt;li&gt;战术设计（Tactical Design）&lt;br /&gt;
&lt;strong&gt;战术设计也称为战术建模，是指对特定上下文下的模型进行详细设计。&lt;/strong&gt;&lt;br /&gt;
战术设计的对象包括聚合、实体和值对象，其目标时明确它们是什么以及相互之间有何关系。战术设计的产出可以使用UML表达的类图，需要细化到具体的属性，同时确保在代码级别可实现。&lt;/li&gt;
      &lt;li&gt;软件（Software）&lt;br /&gt;
&lt;strong&gt;DDD讨论下的软件是指，用于解决具体业务问题的计算机程序，既可以是单体也可以是分布式系统。&lt;/strong&gt;&lt;br /&gt;
软件设计是DDD的最终目的，使用DDD的各种工具可以指导软件设计，最终构建出健壮、容易维护的系统。&lt;/li&gt;
      &lt;li&gt;原则（Principle）&lt;br /&gt;
&lt;strong&gt;为了更好的践行DDD，需要遵守几个原则：通用语言、聚焦核心域、协作共创和持续建模。&lt;/strong&gt;&lt;br /&gt;
这些原则是为了更好的服务业务，从业务驱动模型设计。&lt;/li&gt;
      &lt;li&gt;通用语言（Ubiquitous Language）&lt;br /&gt;
&lt;strong&gt;通用语言是指在软件设计中，业务人员和开发人员需要使用无歧义的统一语言来对话。&lt;/strong&gt;&lt;br /&gt;
这些语言包括对概念的统一理解和定义，以及业务人员参与到软件建模中，否则业务的变化会造成软件巨大的变化。&lt;/li&gt;
      &lt;li&gt;聚焦核心域（Focus）&lt;br /&gt;
&lt;strong&gt;核心域是最关键的业务逻辑，聚焦核心域决定了软件的定位和投资重心。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;协作共创（Collaboration）&lt;br /&gt;
&lt;strong&gt;协作共创是指领域专家和业务专家共同建模。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;持续建模（Continuous）&lt;br /&gt;
&lt;strong&gt;持续建模是指模型需要随业务变化而被及时更新。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;上下文（Context）&lt;br /&gt;
&lt;strong&gt;上下文是指不同语境下的概念虽然有相同的用词，可能具有不同的含义。&lt;/strong&gt;&lt;br /&gt;
在软件设计中，因为自然语言的原因，相同的用词导致实际是不同概念，会对建模和软件设计带来误导。同时，不同的上下文也是识别模型边界的手段。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;领域分析类概念
    &lt;ol&gt;
      &lt;li&gt;问题空间（Problem Space）&lt;br /&gt;
&lt;strong&gt;待解决的业务问题的集合。&lt;/strong&gt;&lt;br /&gt;
在DDD实践中，应该明确区分问题空间和解空间，避免混为一谈。&lt;/li&gt;
      &lt;li&gt;领域（Domain）&lt;br /&gt;
&lt;strong&gt;领域是业务相关知识的集合。&lt;/strong&gt;&lt;br /&gt;
通常来说，领域就是业务知识。业务有一些内在规则，存在专业性。计算机只是业务规则的自动化。&lt;/li&gt;
      &lt;li&gt;子域（Sub Domain）&lt;br /&gt;
&lt;strong&gt;一个子域是领域的一部分。&lt;/strong&gt;&lt;br /&gt;
为了降低业务理解复杂度，DDD实践中通常将领域划分为子域，通过分而治之的方法分析问题。&lt;/li&gt;
      &lt;li&gt;核心域（Core Domain）&lt;br /&gt;
&lt;strong&gt;核心域是指领域中最核心的部分，通常对应企业的核心业务。&lt;/strong&gt;&lt;br /&gt;
核心域需要我们投入最大精力，进行充分的分析。因为它是企业能运转的基础。&lt;/li&gt;
      &lt;li&gt;支撑域（Support Domain）&lt;br /&gt;
&lt;strong&gt;支撑域是一种特殊的子域，是指为了实现核心业务而不得不开发的业务所对应的相关知识的集合。&lt;/strong&gt;&lt;br /&gt;
例如，活动平台业务属于电商的支撑域，因为该业务对电商企业并不是必需的，其存在的意义仅在于放大利润。&lt;/li&gt;
      &lt;li&gt;通用域（General Domain）&lt;br /&gt;
&lt;strong&gt;通用域是另一种特殊的子域，对应的是业界已经有成熟方案的业务。&lt;/strong&gt;&lt;br /&gt;
通用域可以看做一种特殊的支撑域，可以使用标准部件来实现，短信通知、邮件等领域问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;建模类概念
    &lt;ol&gt;
      &lt;li&gt;解空间（Solution Space）&lt;br /&gt;
&lt;strong&gt;解空间是一个数学概念。是指满足问题的所有约束前提下，所有可行解的集合。在DDD的上下文中，指的是所有可能的解决方案的集合。&lt;/strong&gt;&lt;br /&gt;
解空间是相对于问题空间存在的，认识到解空间存在的好处是解空间可以通过一些方法从问题空间导出，而不是通过猜测得出的。&lt;/li&gt;
      &lt;li&gt;领域模型（Model）&lt;br /&gt;
&lt;strong&gt;领域模型是业务概念在程序中的一种表达方式。&lt;/strong&gt;&lt;br /&gt;
领域模型可以用来设计和理解整个软件结构。面向对象设计中的类概念是领域模型的一种表达方式。与此类似，UML的建模方法也可以应用于在对领域模型的表达上。在DDD实践中，领域模型应当尽量简洁，能反应业务概念即可。&lt;/li&gt;
      &lt;li&gt;限界上下文（Bounded context）&lt;br /&gt;
&lt;strong&gt;限界上下文是有明确边界的上下文。在DDD中领域模型会被限定在限界上下文中。&lt;/strong&gt;&lt;br /&gt;
限界上下文强调概念的一致性。虽然传统的方法学已经在追求概念的一致性，但是忽略的系统的庞大性，不论系统多庞大，在系统任何位置同一概念通用。DDD不追求全局的一致性，而是将系统拆成多块，在相同的上下文中实现概念一致性。&lt;br /&gt;
识别上下文可以从概念的二义性着手，比如商品的概念在物流、交易、支付含义完全不一样，但具有不同内涵和外延，实际上他们处在不同上下文。&lt;br /&gt;
限界上下文可以用于微服务划分、避免模型的不正确复用带来的问题。&lt;/li&gt;
      &lt;li&gt;实体（Entity）&lt;br /&gt;
&lt;strong&gt;实体是在相同限界上下文中具有唯一标识的领域模型，可变，通过标识判断同一性。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;值对象（Value Object）&lt;br /&gt;
&lt;strong&gt;值对象是一种特殊的领域模型，不可变，通过值判断同一性。&lt;/strong&gt;&lt;br /&gt;
实体中可以使用ID标识，但是值对象用属性标识，任何属性的变化都视为新的值对象。比如一个银行账户，可以由ID唯一标识，币种和余额可以被修改但是还是同一个账户；交易单中的金额由币种和数值组成，无论修改哪一个属性，金额都不再是原来的金额。&lt;/li&gt;
      &lt;li&gt;聚合（Aggregate）&lt;br /&gt;
&lt;strong&gt;聚合是一组生命周期强一致，修改规则强关联的实体和值对象的集合，表达统一的业务含义。&lt;/strong&gt;&lt;br /&gt;
聚合的意义在于让业务统一一致，在面向对象中有非常重要的价值。比如，订单中有多个订单项，订单的总价是根据订单项计算而来的。如果没有经验的开发者直接对订单项做出修改，而不是由订单统一处理业务逻辑，会造成业务的一致性问题。&lt;br /&gt;
聚合需要在相同的上下文中，不能跨上下文。&lt;/li&gt;
      &lt;li&gt;聚合根（Aggregate Root）&lt;br /&gt;
&lt;strong&gt;聚合根是聚合中最核心的实体，其他的实体和值对象都从属于这个实体&lt;/strong&gt;&lt;br /&gt;
要管理聚合必须使用一个聚合根，然后使用聚合根来实现发现、持久化聚合的作用，完成统一的业务意义。一个聚合中有且只有一个聚合根，聚合也可以只会有一个单独的实体。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;软件设计类概念
    &lt;ol&gt;
      &lt;li&gt;模块（Module）&lt;br /&gt;
&lt;strong&gt;模块是一组类或对象组成的集合。&lt;/strong&gt;&lt;br /&gt;
在DDD实践中推荐使用限界上下文和聚合来指导模块划分。同时，如果不是特别复杂的业务逻辑也可以不遵守该模式。&lt;/li&gt;
      &lt;li&gt;仓储（Repository）&lt;br /&gt;
&lt;strong&gt;仓储是以持久化领域模型为职责的类。&lt;/strong&gt;&lt;br /&gt;
仓储的目的是屏蔽业务逻辑和持久化基础设施的差异。例如，对于同样的持久化业务需求，在采用关系型数据库和非关系型数据库作为存储基础设施时的实现细节是有所不同的。&lt;br /&gt;
软件的设计往往是围绕着对数据的修改完成的。经验不多的开发者往往会认为，软件的开发过程就是对数据库的增删改查。但实际上基于该认知的软件设计让软件难以维护。&lt;br /&gt;
对于采用关系数据库作为存储基础设置的项目，仓储层可以被ORM实现。若不使用ORM，则需要自己实现仓储。&lt;/li&gt;
      &lt;li&gt;服务（Service）&lt;br /&gt;
&lt;strong&gt;服务是领域模型的操作者，负责领域内的业务规则的实现。&lt;/strong&gt;&lt;br /&gt;
在实践中如果使用主、客体的思维来进行设计，则服务为主体，领域模型为客体。使用拟人化的方式来对服务进行命名，可以让开发者更容易理解。比如一个维护客户数据的CRM应用中，客户数据被抽象为模型：Client，对应的服务可以设计为：ClientManager。&lt;/li&gt;
      &lt;li&gt;工厂（Factory）&lt;br /&gt;
&lt;strong&gt;工厂是以构建领域模型（实体或值对象）为职责的类或方法。&lt;/strong&gt;&lt;br /&gt;
工厂可以利用不同的业务参数构建不同的领域模型。对于简单的业务逻辑实现可以不使用工厂。工厂的实现不一定是类的形式，也可以是具备工厂功能的方法。&lt;br /&gt;
在面向对象程序设计中，工厂是一种设计模型。在广义的工厂模式中，工厂可以根据不同的规则的业务需求构造不同的对象。例如在Redis连接客户端的实现中，可以使用Redis单机、哨兵、集群等不同的方式来构建Redis连接客户端。&lt;/li&gt;
      &lt;li&gt;策略（Strategy）&lt;br /&gt;
&lt;strong&gt;策略是业务规则的实现方式。&lt;/strong&gt;&lt;br /&gt;
例如通知业务，可以使用不同的渠道来实现，不同渠道的实现逻辑可以认为是不同的策略。在面向对象程序设计中，策略模式也是一种设计模式，是多态的一种实现模式。&lt;br /&gt;
策略通常会搭配着接口来设计。如果说接口是一种契约，那策略就是契约的履约方式。&lt;/li&gt;
      &lt;li&gt;规格（Specification）&lt;br /&gt;
&lt;strong&gt;规格是一些特殊的业务规则。通常表现为用于校验、查询和搜索条件。&lt;/strong&gt;&lt;br /&gt;
在实践中，规则可以被设计为灵活的查询或校验条件，也可以被抽象出来以便复用。&lt;br /&gt;
例如，在JPA、MongoDB、ElasticSearch和一些具有查询能力的ORM都大量使用这种设计方式，同样的在应用程序中我们也可以参考这种设计模式，把业务规则提取处理。&lt;/li&gt;
      &lt;li&gt;分层架构&lt;br /&gt;
&lt;strong&gt;分层架构是指在软件设计过程中按照既定的原则将不同的功能实现拆分到不同的层级进行实现的一种设计方式。每个层级有独立的职责，多个层次协同以提供完整功能。按照DDD的分层模型，通常可以划分为：接入层、应用层、领域层、基础设施层。&lt;/strong&gt;&lt;br /&gt;
分层架构在具体的软件中可以表现为不同的形式。例如，在分布式系统中，不同层级的软件实现，可以表现为独立部署的服务。而在单体系统中，分层可以用不同的模块或包来实现。&lt;br /&gt;
分层架构的设计理念与计算机网络的层级结构类似，上层依赖下层的实现，而下层实现无需关心上层实现。例如,HTTP协议构建TCP协议之上，TCP协议只负责提供传输层的能力，而不需要知道具体的应用层协议。&lt;br /&gt;
分层架构中层级的数量需要依照系统复杂度来定，并不需要死板地按照DDD推荐的四层来进行设计。在简单的系统中，可以通过减少分层来避免样板代码，减少冗余。例如在web系统中有时候只有一种接入方式，接入层和应用层能力高度重叠，可以考虑直接使用应用层替代接入层。&lt;br /&gt;
软件框架的使用，通常会引入新的层级，从而影响系统整体的分层架构。例如，ORM框架本身就提供了对Repository的一层抽象。&lt;/li&gt;
      &lt;li&gt;接入层（Interface）&lt;br /&gt;
&lt;strong&gt;接入层负责的是系统的输入和输出。&lt;/strong&gt;&lt;br /&gt;
接入层只关心沟通协议，不关心业务相关的数据校验。接入层的实现是与业务应用强相关的，不同的业务应用有不同的实现方式。例如，对于普通的Web应用，基于HTTP协议的API是一种接入层实现方式。&lt;br /&gt;
接入层特点：&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;接入层对应用数据透明，只关心数据格式而不关心数据的内容&lt;/li&gt;
      &lt;li&gt;在大部分单体系统中接入层通常被框架实现。例如，在SpringBoot框架中，HTTP协议的API设计不需要关注HTTP协议本身。&lt;/li&gt;
      &lt;li&gt;在分布式系统中接入层通常被网关实现。  &lt;br /&gt;
    9. 应用层（Application）&lt;br /&gt;
&lt;strong&gt;应用层，组织业务场景，编排业务，隔离场景对领域层的差异。&lt;/strong&gt;&lt;br /&gt;
应用层遵循面向对象核心思想中的关注点分离概念。应用层的关注点在于业务场景的处理。例如：对于一个服务多种类型用户的应用，toC的网页界面和后台管理页面对应的是不同的业务场景。对于新用户注册这个业务来说，
通过ToC的网页注册和通过后台管理页面进行注册是不同的业了务场景。然而，用户注册在系统层面的基本逻辑是一样的。所以，用户注册的基本业务逻辑可以交由领域层来实现。而两种不同渠道进行用户注册所需要进行的身份验证等逻辑，
可以设计在应用层进行实现。这样便能达到关注点分离，复用核心业务逻辑的目的。&lt;br /&gt;
应用层的特点：&lt;/li&gt;
      &lt;li&gt;关心处理完一个完整的业务&lt;/li&gt;
      &lt;li&gt;该层只负责业务编排，对象转换，而具体的业务逻辑由领域层实现&lt;/li&gt;
      &lt;li&gt;虽然不关心请求从何处来，但关心谁来、做什么、有没有权限做&lt;/li&gt;
      &lt;li&gt;利用不同的领域服务来解决问题&lt;/li&gt;
      &lt;li&gt;对最终一致性有要求的业务和事务处理需要放到应用层来处理&lt;/li&gt;
      &lt;li&gt;功能权限放到这层&lt;br /&gt;
    10. 领域层（Domain）&lt;br /&gt;
&lt;strong&gt;领域层，实现具体的业务逻辑、规则，为应用层提供无差别的服务能力。&lt;/strong&gt;&lt;br /&gt;
实际处理业务的地方，领域层需要对应用层提供无差别的服务和能力。例如，对于用户注册的场景，用户既可以通过邮箱自己注册，也可以由管理员在后台进行添加。用户注册的核心逻辑可以由领域层完成，但是对于不同渠道进行用户注册的参数校验和权限验证等逻辑则由应用层实现。&lt;br /&gt;
领域层的特点：&lt;/li&gt;
      &lt;li&gt;不关心场景，关心模型完整性和业务规则&lt;/li&gt;
      &lt;li&gt;不关心谁来，不关心场景完整的业务，关心当前上下文的业务完整&lt;/li&gt;
      &lt;li&gt;强一致性事务放到此层，聚合的事务是理所当然的&lt;/li&gt;
      &lt;li&gt;对应到分布式系统中的domain service、后台等概念&lt;/li&gt;
      &lt;li&gt;领域层做业务规则验证&lt;/li&gt;
      &lt;li&gt;数据权限放到这层（比如只允许删除自己创建的商品），因为数据权限涉及业务规则&lt;/li&gt;
      &lt;li&gt;根据业务情况，参考反范式理论，跨上下文使用只对象做必要的数据冗余&lt;br /&gt;
    11. 基础设施层（Infrastructure）&lt;br /&gt;
&lt;strong&gt;基础设施层，提供具体的技术实现，比如存储，基础设施对业务保持透明。&lt;/strong&gt;&lt;br /&gt;
对于基础设施层来说，基础设施层并不是指Mysql、Redis等外部组件，而是外部组件的适配器，Hibernate、Mybatis、Redis Template等，因此再DDD中适配器模式被多次提到，基础设施层往往不能单独存在，还是要依附于领域层。基础设施层的适配器还包括了外部系统的适配，互联网产品系统的外部系统非常多，常见的有活体检测、风控系统、税务发票等。&lt;br /&gt;
基础设施层的特点：&lt;/li&gt;
      &lt;li&gt;关心存储、通知、第三方系统等外部设施&lt;/li&gt;
      &lt;li&gt;基础设施的权限由配置到应用的凭证控制，例如数据库、对象存储的凭证，基础设施层不涉及用户的权限&lt;br /&gt;
    12. 部署架构&lt;br /&gt;
&lt;strong&gt;部署架构是指具体的架构实现。&lt;/strong&gt;&lt;br /&gt;
主要是在分布式系统、单体系统，甚至在客户端软件中体现。&lt;br /&gt;
把逻辑架构和部署构架区分开可以很好的理解软件设计上和部署上的不同，对于应用架构来说，逻辑上的设计不一定对应部署架构。&lt;br /&gt;
这样就很好理解DDD在不同场合中的使用方式，避免生搬硬套。当DDD的分层结构在单体应用中使用时，每层可能使用包、模块来表达，在微服务中使用时，每层可能由不同角色的微服务来完成。&lt;br /&gt;
    13. 微服务（Micro Service）&lt;br /&gt;
&lt;strong&gt;微服务是一种低耦合的分布式应用系统。&lt;/strong&gt;&lt;br /&gt;
维基百科的定义是：一种软件开发技术-面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。这个定义没有问题，但是忽略了一个重要的信息，微服务是一种分布式架构，微服务必须面对分布式系统的各种问题。&lt;br /&gt;
分布式系统是通过计算机网络连接、协同工作的IT系统，因此使用DDD时候，需要为这种系统做适配，而不是简单的做出切分。&lt;br /&gt;
    14. 单体（Monomer）&lt;br /&gt;
&lt;strong&gt;单体是主要业务实现和部署在单一服务器上的应用。&lt;/strong&gt;&lt;br /&gt;
单体系统是相对于微服务来说的，其特点是主要的实现在单一的服务器中。&lt;br /&gt;
    15. 分布式应用系统（Distributed）&lt;br /&gt;
&lt;strong&gt;分布式应用系统是建立在计算机网络之上的应用软件系统，不同单元通过计算机网络集成。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;事件风暴类概念
    &lt;ol&gt;
      &lt;li&gt;事件风暴（Event Storming）&lt;br /&gt;
&lt;strong&gt;事件风暴是一种以工作坊的形式，使用DDD建模的方式。&lt;/strong&gt;&lt;br /&gt;
事件风暴是一种捕获行为需求的方法，类似传统软件的开发用例分析。所有人员（领域专家和技术专家）对业务行为进行一次发散，并最终收敛达到业务的统一。&lt;/li&gt;
      &lt;li&gt;领域事件（Domain Event）&lt;br /&gt;
&lt;strong&gt;事件是系统状态发生的某种客观现象，领域事件是和领域有关的事件。&lt;/strong&gt;&lt;br /&gt;
领域事件是在业务上真实发生的客观事实，这些事实对系统会产生关键影响，是观察业务系统变化的关键点。领域事件一般是领域专家关心的。&lt;br /&gt;
事件的评价方式是系统状态是否发生变化。系统状态变化意味着领域模型被业务规则操作，这是观察系统业务的好办法。&lt;br /&gt;
识别领域事件的线索有：&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;是否产生了某种数据&lt;/li&gt;
      &lt;li&gt;系统状态是否发生改变，无论这种状态存放到数据库还是内存&lt;/li&gt;
      &lt;li&gt;是否对外发送了某些消息&lt;br /&gt;
    3. 业务规则（Policy）&lt;br /&gt;
&lt;strong&gt;业务规则是指对业务逻辑的定义和约束。&lt;/strong&gt;&lt;br /&gt;
不同的业务规则往往意味着不同的领域事件被触发，未来在技术实现时可能是一些分支条件，对应DDD实现中可能通过领域服务、规格、策略等方式实现。&lt;br /&gt;
业务规则的识别是为了将数据和算法分开。&lt;br /&gt;
    4. 命令（Command）&lt;br /&gt;
&lt;strong&gt;命令时执行者发起的操作，构成要件是执行者和行为。&lt;/strong&gt;&lt;br /&gt;
命令可以类比于UML分析中的业务用例，是某个场景中领域事件的触发动作。&lt;br /&gt;
    5. 执行者（Actor）&lt;br /&gt;
&lt;strong&gt;执行者是指使用系统的主体，是导致系统状态变化的触发源。&lt;/strong&gt;&lt;br /&gt;
执行者有点像UML的涉众，不过区别是执行者不仅是用户，还包括外部系统和本系统。在事件风暴中，执行者可以是：用户、外部系统、本系统、定时器。&lt;br /&gt;
    6. 用户（User）&lt;br /&gt;
&lt;strong&gt;用户是执行者的一种，是指使用软件或服务的人。&lt;/strong&gt;&lt;br /&gt;
用户可以有不同的角色，通常我们会把不同角色的相似行为作为不同的命令来处理，有可能得到同样的事件。&lt;br /&gt;
    7. 外部系统（Out System）&lt;br /&gt;
&lt;strong&gt;外部系统是执行者的一种，系统开放API的调用发起者。&lt;/strong&gt;&lt;br /&gt;
有一些系统会提供对外的API给外部系统，这时候外部系统也会发出命令让系统产生事件，这里的外部系统特指作为执行者的外部系统。&lt;br /&gt;
    8. 本系统（System）&lt;br /&gt;
&lt;strong&gt;本系统是执行者的一种，指系统本身。&lt;/strong&gt;&lt;br /&gt;
事件的触发可以由用户、外部系统、定时器触发，也可以由上一个事件触发，因此这里的触发者是系统本身。&lt;br /&gt;
    9. 定时器（Timer）&lt;br /&gt;
&lt;strong&gt;定时器是执行者的一种，通常是定时任务。&lt;/strong&gt;&lt;br /&gt;
定时器可以作为执行者，不过需要区别于本系统这个触发源。定时器可以看待为外部一个时间信号源，类似于计算机中主机中的振荡器。&lt;br /&gt;
    10. 参与人（Participants）&lt;br /&gt;
&lt;strong&gt;作为工作坊的参与人员（应区别于执行者）&lt;/strong&gt;&lt;br /&gt;
参与人只是一种角色，而非具体的一个人，可以多个自然人做群体参与，也可以一人一人分饰不同的角色。&lt;br /&gt;
在开始工作坊之前，参与人需要满足一些条件：&lt;/li&gt;
      &lt;li&gt;参与人需要对解决的问题和产出目标达成共识&lt;/li&gt;
      &lt;li&gt;参与人需要DDD的基本知识或接受过基本培训&lt;/li&gt;
      &lt;li&gt;领域专家、技术专家需要能全程参加&lt;br /&gt;
    11. 领域专家（Domain Expert）&lt;br /&gt;
&lt;strong&gt;领域专家是指熟悉业务规则的人，在工作坊中一般是能敲定业务规则的人。&lt;/strong&gt;&lt;br /&gt;
在实际的事件风暴工作坊中，领域专家是一个比技术专家更难获得的人，一个合格的、能让工作坊进展下去的领域专家需要有几个要求：
    1. 了解现有业务情况
    2. 能对具体的业务方向做出结论性的输出
在做工作坊时，需要分清现状（As-IS）和目标（To-Be）业务，现状业务很多人能说出来，不过真正的领域专家能对目标业务做出描述的人。&lt;br /&gt;
    12. 技术专家（Tech Expert）
&lt;strong&gt;技术专家是指熟悉技术方案和实现方式的人，能给出可行的技术方案和了解基础设计的限制条件。&lt;/strong&gt;&lt;br /&gt;
技术专家需要能对现有的技术做出描述，而未来的技术选型可能是动态的，能有一定预见性最好。技术专家往往是当前团队中最熟悉架构和代码的人。&lt;br /&gt;
    13. 主持人（Facilitator）&lt;br /&gt;
&lt;strong&gt;主持人是工作坊流程的推动者，以及DDD方法论的守护者。&lt;/strong&gt;&lt;br /&gt;
在一些工作坊中，主持人往往是外部的咨询师，他们有大量的实践经验，需要能对DDD的概念、方法有成体系的研究，并能推动工作坊进行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="DDD" />
      

      

      
        <summary type="html">图例 DDD基本概念</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Bitoperation</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Bitoperation" />
      <published>2023-11-18T00:00:00+08:00</published>
      <updated>2023-11-18T00:00:00+08:00</updated>
      <id>http://localhost:4000/BitOperation</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h4 id=&quot;常见运算符&quot;&gt;常见运算符&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;按位与 &amp;amp;&lt;br /&gt;
  两个操作数相应的二进制位都为1，结果为1，反之为0。&lt;/li&gt;
  &lt;li&gt;按位或 |&lt;br /&gt;
  两个操作数相应的二进制位只要有一个为1，结果为1，反之为0。&lt;/li&gt;
  &lt;li&gt;按位异或 ^&lt;br /&gt;
  两个操作数相应的二进制位值只要相同，运算结果为0，反之为1。&lt;/li&gt;
  &lt;li&gt;按位取反 ~&lt;br /&gt;
  单目运算符，只有一个操作数，是将操作数相应的二进制位数取反。&lt;/li&gt;
  &lt;li&gt;左移 «  
  将一个数的各二进制位左移若干位，移动的位数由右操作数指定。&lt;/li&gt;
  &lt;li&gt;右移 »&lt;br /&gt;
  与左移相反&lt;/li&gt;
  &lt;li&gt;二进制数最低位1和后面所有0组成的 \(2^k\) lowbit&lt;br /&gt;
  将x的二进制所有位全部取反，再加1，就可以得到 -x 的二进制编码。例如6的二进制编码是 110 ，全部取反后得到 001，加1得到010。&lt;br /&gt;
  设原先x的二进制编码是 (…)10…00，全部取反后得到[…]01…11，加1后得到[…]10…00，也就是-x的二进制编码。这里x表示二进制中第一个1是x最低位的1。&lt;br /&gt;
  (…)和[…]中省略号的每一位分别相反，所以 x&amp;amp;-x = (…)10…00 &amp;amp; […]10…00 = 10…00，得到的结果就是 lowbit。&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">常见运算符 按位与 &amp;amp;   两个操作数相应的二进制位都为1，结果为1，反之为0。 按位或 |   两个操作数相应的二进制位只要有一个为1，结果为1，反之为0。 按位异或 ^   两个操作数相应的二进制位值只要相同，运算结果为0，反之为1。 按位取反 ~   单目运算符，只有一个操作数，是将操作数相应的二进制位数取反。 左移 «    将一个数的各二进制位左移若干位，移动的位数由右操作数指定。 右移 »   与左移相反 二进制数最低位1和后面所有0组成的 \(2^k\) lowbit   将x的二进制所有位全部取反，再加1，就可以得到 -x 的二进制编码。例如6的二进制编码是 110 ，全部取反后得到 001，加1得到010。   设原先x的二进制编码是 (…)10…00，全部取反后得到[…]01…11，加1后得到[…]10…00，也就是-x的二进制编码。这里x表示二进制中第一个1是x最低位的1。   (…)和[…]中省略号的每一位分别相反，所以 x&amp;amp;-x = (…)10…00 &amp;amp; […]10…00 = 10…00，得到的结果就是 lowbit。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Mathematicalformula</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Mathematicalformula" />
      <published>2023-10-18T00:00:00+08:00</published>
      <updated>2023-10-18T00:00:00+08:00</updated>
      <id>http://localhost:4000/MathematicalFormula</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;数学公式&quot;&gt;数学公式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;等差数列&quot;&gt;等差数列&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;定义式
https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/1129192?fr=ge_ala&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;等比数列&quot;&gt;等比数列&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;排列组合&quot;&gt;排列组合&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">数学公式</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Algorithmtips</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Algorithmtips" />
      <published>2023-10-18T00:00:00+08:00</published>
      <updated>2023-10-18T00:00:00+08:00</updated>
      <id>http://localhost:4000/AlgorithmTips</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;常用算法小技巧&quot;&gt;常用算法小技巧&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;向下取整&quot;&gt;向下取整&lt;/h4&gt;
    &lt;p&gt;  向下取整函数floor(val)的结果是小于或等于val的最大整数。&lt;br /&gt;
  例如:求x除以3的向下取整数字，直接除以3即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;向上取整&quot;&gt;向上取整&lt;/h4&gt;
    &lt;p&gt;  向上取整函数ceil(val)的结果是大于或等于val的最小整数。将其转化为向下取整思路，先将x加上要除以的n-1，再除以n即可。&lt;br /&gt;
  例如:求x除以3的向上取整数字，为避免浮点数运算，需要先将x加2再直接除以3，即ceil((x/3)=(x+2)/3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">常用算法小技巧</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Datatype</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Datatype" />
      <published>2022-09-26T00:00:00+08:00</published>
      <updated>2022-09-26T00:00:00+08:00</updated>
      <id>http://localhost:4000/dataType</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h1 id=&quot;mysql基本数据类型&quot;&gt;Mysql基本数据类型&lt;/h1&gt;

&lt;h2 id=&quot;数值类型&quot;&gt;数值类型&lt;/h2&gt;
&lt;h3 id=&quot;整数类型&quot;&gt;整数类型&lt;/h3&gt;
&lt;p&gt;  数值型数据类型主要用来存储数字,Mysql提供了多种数值数据类型,不同的数据类型提供不同的取值范围,可以存储的值范围越大,其所需要的存储空间也会越大.&lt;br /&gt;
  mysql主要提供的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT.整数类型的属性字段可以添加AUTO_INCREMENT自增约束条件.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据范围&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Storage(Bytes)&lt;/th&gt;
      &lt;th&gt;Minimum Value Signed&lt;/th&gt;
      &lt;th&gt;Minimum Value Unsigned&lt;/th&gt;
      &lt;th&gt;Maximum Value Signed&lt;/th&gt;
      &lt;th&gt;Maximum Value Unsigned&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;TINYINT&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;-128&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;127&lt;/td&gt;
      &lt;td&gt;255&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SMALLINT&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;-32768&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;32767&lt;/td&gt;
      &lt;td&gt;65535&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MEDIUMINT&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;-8388608&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;8388607&lt;/td&gt;
      &lt;td&gt;16777215&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INT&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;-2147483648&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2147483647&lt;/td&gt;
      &lt;td&gt;4294967295&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIGINT&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;\(-2^63\)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2^63 - 1&lt;/td&gt;
      &lt;td&gt;2^64 - 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FLOAT&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;-3.402823466E+38&lt;/td&gt;
      &lt;td&gt;1.175494351E-38&lt;/td&gt;
      &lt;td&gt;-1.175494351E-38&lt;/td&gt;
      &lt;td&gt;3.402823466E+38&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DOUBLE&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;-1.7976931348623157E+308&lt;/td&gt;
      &lt;td&gt;2.2250738585072014E-308&lt;/td&gt;
      &lt;td&gt;-2.2250738585072014E-308&lt;/td&gt;
      &lt;td&gt;1.7976931348623157E+308&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;示例:&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int(4)&lt;/code&gt;&lt;br /&gt;
该声明指明,该字段中的数据一般只显示4位数字.&lt;/p&gt;

&lt;p&gt;注意点:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;显示宽度和数据类型取值范围是无关的。显示宽度只是指明mysql最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充；如果掺入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且可以显示出来。 &lt;br /&gt;
例如:向year字段插入一个数值12345，当使用select查询该列值的时候，mysql显示的将是完整的带有5位数字的12345，而不是4位数字的值。&lt;br /&gt;
其他整数型数据类型也可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度。  &lt;br /&gt;
显示宽度只用于显示，并不能限制取值范围和占用空间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应该根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。&lt;/p&gt;

&lt;h3 id=&quot;浮点数类型和定点数类型&quot;&gt;浮点数类型和定点数类型&lt;/h3&gt;
&lt;p&gt;mysql中使用浮点数和定点数表示小数。&lt;br /&gt;
浮点数类型有两种:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;单精度浮点类型(FLOAT)&lt;/li&gt;
  &lt;li&gt;双精度浮点类型(DOUBLE)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;定点数类型只有一种:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DECIMAL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浮点数类型和定点数类型都可以用(M, N)来表示。其中，用M称为精度，表示总共的位数；N称为标度，表示小数的位数。&lt;br /&gt;
DECIMAL类型不同于FLOAT和DOUBLE，DECIMAL实际是以串存放的，可能的最大取值范围和DOUBLE一样，但是其有效的取值范围由M和D的值来决定。如果改变M而固定D，则取值范围将随着M的变大而变大。&lt;/p&gt;

&lt;p&gt;注意点:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;无论是定点数还是浮点数类型，如果用户指定的精度超出精度范围，则会四舍五入。&lt;br /&gt;
FLOAT和DOUBLE在不指定精度操作时，默认会按照实际的精度(由计算机硬件和操作系统决定)，DECIMAL若不指定精度则默认为(10, 0);&lt;br /&gt;
在mysql中，定点数以字符串形式存储，在对精度要求比较高的时候，使用DECIMAL的类型比较好，另外，两个浮点数进线减法和比较运算时，容易出现问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考链接:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;https://dev.mysql.com/doc/refman/5.7/en/numeric-types.html&lt;br /&gt;
https://zhuanlan.zhihu.com/p/543865001&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="mysql" />
      

      

      
        <summary type="html">Mysql基本数据类型</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Morristraversing</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Morristraversing" />
      <published>2022-08-19T00:00:00+08:00</published>
      <updated>2022-08-19T00:00:00+08:00</updated>
      <id>http://localhost:4000/MorrisTraversing</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;  对于二叉树的遍历我们常用的方法就是迭代和递归遍历，两种遍历方式使用压栈的方式，递归调用的是虚拟机的栈，迭代使用的是自定义的栈，两者的空间复杂度都为 &lt;strong&gt;O(n)&lt;/strong&gt; 。&lt;br /&gt;
  为了追求极致的效率,莫里斯遍历应运而生,它使用一种巧妙的方式将空间复杂度降为 &lt;strong&gt;O(1)&lt;/strong&gt; .下面我们就一起来看看如何巧妙:&lt;/p&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;基本思路&quot;&gt;基本思路&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;  遍历过程中用到的两个概念先说明一下,当前遍历的根节点用 &lt;strong&gt;node&lt;/strong&gt; 来表示,当前根节点左子树中的最右节点 &lt;strong&gt;pre&lt;/strong&gt; .&lt;br /&gt;
从当前根节点 &lt;strong&gt;node&lt;/strong&gt; 开始遍历:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;若当前根节点 &lt;strong&gt;node&lt;/strong&gt; 的左节点为空,将当前根节点的右节点指向当前根节点 &lt;strong&gt;node = node.right&lt;/strong&gt; ,说明不存在左子树,即左子树遍历结束,开始遍历右子树(这里之所以遍历右子树,因为在第二步中已经将右子树和最近的一个根节点建立连接形成环)&lt;/li&gt;
  &lt;li&gt;若当前根节点 &lt;strong&gt;node&lt;/strong&gt; 的左节点不为空,将当前根节点的左节点指向最右节点 &lt;strong&gt;pre = node.left&lt;/strong&gt; ,从当前根节点的左节点继续向右遍历一直到底,因为会通过步骤2.1形成环,所有这里的结束条件为右节点为空或右节点等于当前根节点,判断最右节点的右节点 &lt;strong&gt;pre.right&lt;/strong&gt; 是否为空:
    &lt;ul&gt;
      &lt;li&gt;2.1 若最右节点的右节点 &lt;strong&gt;pre.right&lt;/strong&gt; 为空,将最右节点的右节点指向根节点 &lt;strong&gt;pre.right = root&lt;/strong&gt; ,继续遍历当前根节点的左子树 &lt;strong&gt;node = node.left&lt;/strong&gt; ,说明此最右节点与当前根节点形成环,成环并继续从当前根节点向左遍历&lt;/li&gt;
      &lt;li&gt;2.2 若最右节点的右节点 &lt;strong&gt;pre.right&lt;/strong&gt; 不为空,将最右节点的右节点指向空 &lt;strong&gt;pre.right = null&lt;/strong&gt; ,继续遍历当前根节点的右子树 &lt;strong&gt;node = node.right&lt;/strong&gt; ,说明此时遇到步骤2.1生成的环了,将环断开并继续从当前根节点向右遍历&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  可见的莫里斯遍历的核心思想就是将根节点与根节点左子树中的最右节点相连接形成环,这样在遍历的时候就可以重新回到根节点,无须借助其他数据结构降低空间复杂度.&lt;/p&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;遍历过程&quot;&gt;遍历过程&lt;/h3&gt;
&lt;hr /&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/莫里斯遍历.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;莫里斯遍历&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/莫里斯遍历.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;莫里斯遍历&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;例题&quot;&gt;例题&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;1.&lt;a href=&quot;https://leetcode.cn/problems/recover-binary-search-tree/&quot;&gt;恢复二叉搜索树&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/恢复二叉搜索树.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;恢复二叉搜索树&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/恢复二叉搜索树.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;恢复二叉搜索树&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;blockquote&gt;
  &lt;p&gt;java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;morris&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//判断当前节点是否有左子树&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 1.有则说明左子树未遍历完继续遍历左子树,再根据最右节点进行判断&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 2.无则说明左子树遍历完,取当前节点值,并继续遍历右子树&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//pre意在找到当前节点左子树中的最右节点&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//若 pre存在右节点 &amp;amp;&amp;amp; pre的右节点不等于当前遍历的根节点 (因为在下一步若pre不存在右节点会将pre的右节点指向当前节点x形成一个环)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//1.若pre最右节点不存在右节点(也可以理解为未指向其根节点形成环),则将pre的右节点指向根节点形成环,并继续遍历根节点的左子树&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//2.若pre最右节点存在右节点(可以理解为已经指向根节点形成环了),取当前root值并将pre最右节点置为null(即将环断开),继续遍历右子树 (若经过步骤1成环了,即变成从子节点回到根节点)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                    //先序遍历&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                    res.add(root.val);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//中序遍历&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度:O(n)&lt;br /&gt;
空间复杂度为:O(1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;延伸-后序遍历&quot;&gt;延伸-后序遍历&lt;/h3&gt;
&lt;hr /&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/莫里斯后序遍历.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;莫里斯后序遍历&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/mirrorsTraversing/莫里斯后序遍历.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;莫里斯后序遍历&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;


&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;morrisPostOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//自定义头结点形成环&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//使用头插法在断开环时将右节点和根节点加入结果汇总&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;其他语言&quot;&gt;其他语言&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;C++&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;python3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">定义   对于二叉树的遍历我们常用的方法就是迭代和递归遍历，两种遍历方式使用压栈的方式，递归调用的是虚拟机的栈，迭代使用的是自定义的栈，两者的空间复杂度都为 O(n) 。   为了追求极致的效率,莫里斯遍历应运而生,它使用一种巧妙的方式将空间复杂度降为 O(1) .下面我们就一起来看看如何巧妙:</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Reservoirsampling</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Reservoirsampling" />
      <published>2022-06-15T00:00:00+08:00</published>
      <updated>2022-06-15T00:00:00+08:00</updated>
      <id>http://localhost:4000/ReservoirSampling</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;  给定一串很长的数据流,对该数据流中数据只能访问一次,使得数据流中所有数据被选中的概率相等.&lt;br /&gt;
  解决这样的问题,就可以利用蓄水池算法(Reservoir Sampling).&lt;/p&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;基本思路&quot;&gt;基本思路&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;  假设需要采样的数量为 &lt;strong&gt;k&lt;/strong&gt; .&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;首先构建一个 &lt;strong&gt;k&lt;/strong&gt; 个元素的数组,将序列前的 &lt;strong&gt;k&lt;/strong&gt; 个元素放入数组中.&lt;/li&gt;
  &lt;li&gt;对于从第 &lt;strong&gt;j&lt;/strong&gt; 个元素 &lt;strong&gt;(j&amp;gt;k)&lt;/strong&gt; ,以 &lt;strong&gt;$\frac{k}{j}$&lt;/strong&gt; 的概率来决定该元素是否被替换到数组中,数组中的 &lt;strong&gt;k&lt;/strong&gt; 个元素被替换的概率是相同的.&lt;/li&gt;
  &lt;li&gt;当遍历完所有元素之后,数组中剩下的元素即为采样样本.
    &lt;hr /&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;证明过程&quot;&gt;证明过程&lt;/h3&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;对于第 &lt;strong&gt;i&lt;/strong&gt; 个元素 &lt;strong&gt;(i&amp;lt;k)&lt;/strong&gt; .在 &lt;strong&gt;k&lt;/strong&gt; 步之前,被选中的概率为1.
当走到第 &lt;strong&gt;k+1&lt;/strong&gt; 步时,被 &lt;strong&gt;k+1&lt;/strong&gt; 个元素替换的概率 = 第 &lt;strong&gt;k+1&lt;/strong&gt; 个元素被选中的概率 &lt;strong&gt;$\times$&lt;/strong&gt; &lt;strong&gt;i&lt;/strong&gt; 被选中替换的概率,即 &lt;strong&gt;$\frac{k}{k+1} \times \frac{1}{k} = \frac{1}{k+1}$&lt;/strong&gt; .&lt;br /&gt;
那么,不被第 &lt;strong&gt;k+1&lt;/strong&gt; 个元素替换的概率为 &lt;strong&gt;$1-\frac{1}{k+1} = \frac{k}{k+1}$&lt;/strong&gt; .以此类推,不被 &lt;strong&gt;k+2&lt;/strong&gt; 个元素替换的概率为 &lt;strong&gt;$1-\frac{k}{k+2} \times \frac{1}{k} = \frac{k+1}{k+2}$&lt;/strong&gt; .&lt;br /&gt;
当递推到第 &lt;strong&gt;n&lt;/strong&gt; 个元素时,第 &lt;strong&gt;i&lt;/strong&gt; 个元素被保留的概率 = 被选中的概率 &lt;strong&gt;$\times$&lt;/strong&gt; 不被替换的概率,即 &lt;strong&gt;\[1 \times \frac{k}{k+1} \times \frac{k+1}{k+2} \times \frac{k+2}{k+3} … \times \frac{n-1}{n} = \frac{1}{n}\]&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;对于第 &lt;strong&gt;j&lt;/strong&gt; 个元素 &lt;strong&gt;(j&amp;gt;k)&lt;/strong&gt; . 在第 &lt;strong&gt;j&lt;/strong&gt; 步被选中的概率为 &lt;strong&gt;$\frac{k}{j}$&lt;/strong&gt; ,不被 &lt;strong&gt;j+1&lt;/strong&gt; 个元素替换的概率为 &lt;strong&gt;$1- \frac{k}{j+1} \times \frac{1}{k}$&lt;/strong&gt; ,当递推到第 &lt;strong&gt;n&lt;/strong&gt; 个元素时,被保留的概率 = 被选中的概率 * 不被替换的概率，即 &lt;strong&gt;\[\frac{k}{j} \times \frac{j}{j+1} \times \frac{j+1}{j+2} … \times \frac{n-1}{n} = \frac{k}{n}\]&lt;/strong&gt; 因此对于每个元素,被保留的概率都是 &lt;strong&gt;$\frac{k}{n}$&lt;/strong&gt;
    &lt;hr /&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;理解过程&quot;&gt;理解过程&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;  遍历长度等于 &lt;strong&gt;n&lt;/strong&gt; 的数组.当第 &lt;strong&gt;i&lt;/strong&gt; 次遇到 &lt;strong&gt;target&lt;/strong&gt; 的元素时,随机选择区间 &lt;strong&gt;[0, i)&lt;/strong&gt; 内的一个整数,如果其等于 &lt;strong&gt;0&lt;/strong&gt; ,则将返回值置为该元素的下标,否则返回值不变.&lt;br /&gt;
  设nums中有 &lt;strong&gt;k&lt;/strong&gt; 个值为 &lt;strong&gt;target&lt;/strong&gt; 的元素,该算法会保证这 &lt;strong&gt;k&lt;/strong&gt; 个元素的下标最终返回值概率均为$\frac{1}{k}$,证明如下&lt;br /&gt;
P(第i次遇到值为target的元素下标称为最终返回值) = P(第i次随机选择的值=0) &lt;strong&gt;$\times$&lt;/strong&gt; P(第i+1次随机选择的值!=0) &lt;strong&gt;$\times…\times$&lt;/strong&gt; P(第k次随机选择的值!=0)&lt;/p&gt;

\[\frac{1}{i} \times (1-\frac{1}{i+1}) \times...\times(1-\frac{1}{k}) = \frac{1}{i} \times \frac{i}{i+1} \times...\times \frac{k-1}{k} = \frac{1}{k}\]

&lt;hr /&gt;

&lt;h3 id=&quot;例题&quot;&gt;例题&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;1.&lt;a href=&quot;https://leetcode.cn/problems/random-pick-index/&quot;&gt;随机数索引-随机选一个数&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/reservoirSampling/随机数索引.jpg&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;随机数索引&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/reservoirSampling/随机数索引.jpg&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;随机数索引&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;blockquote&gt;
  &lt;p&gt;java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Random&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度:O(n)&lt;br /&gt;
空间复杂度为:O(1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;随机选k个数
    &lt;blockquote&gt;
      &lt;p&gt;java&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Random&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;时间复杂度:O(n)&lt;br /&gt;
空间复杂度度:O(1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;其他语言&quot;&gt;其他语言&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;C++&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//随机选一个数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
					&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
					&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
					&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
						&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
					&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//随机选K个数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selectK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;python3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;随机选一个数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;randrange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;
        
&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;随机选K个数&lt;/span&gt;        
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;randrange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//随机选一个数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constructor1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//随机选K个数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SelectK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">定义   给定一串很长的数据流,对该数据流中数据只能访问一次,使得数据流中所有数据被选中的概率相等.   解决这样的问题,就可以利用蓄水池算法(Reservoir Sampling).</summary>
      

      
      
    </entry>
  
</feed>
