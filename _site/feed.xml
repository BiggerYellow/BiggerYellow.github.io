<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <link href="https://github.com/jeromelachaud/freelancer-theme/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" />
  <updated>2021-08-21T00:48:56+08:00</updated>
  <id>https://github.com/jeromelachaud/freelancer-theme/</id>

  
    <title type="html">黄天霸</title>
  

  
    <subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle>
  

  

  
  
    <entry>
      <title type="html">Heapsort</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Heapsort" />
      <published>2021-08-20T00:00:00+08:00</published>
      <updated>2021-08-20T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/HeapSort</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;h3 id=&quot;前置概念&quot;&gt;前置概念&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;完全二叉树:叶子节点只能出现在最下层或次下层,且最下层的叶子节点集中在树的左部。即除了最后一层其他层的节点个数都是满的而且最后一层的叶子节点必须靠左.&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;完全二叉树&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h3 id=&quot;二叉堆&quot;&gt;二叉堆&lt;/h3&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;必须是完全二叉树&lt;/li&gt;
  &lt;li&gt;二叉堆中的每一个节点,都必须大于等于(或小于等于)其子树中每个节点的值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;若每个节点大于等于子树中的每个节点,称之为大顶堆.
若每个节点小于等于子树中的每个节点,称之为小顶堆.&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;小顶堆/大顶堆&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;
&lt;p&gt;我们仔细观察下大顶堆和小顶堆,可以发现如果父节点的位置为0,其左子节点的位置1,右子节点的位置为2,大约可以猜到父节点和左右子节点的关系为:若父节点的位置为1,那么左子节点的位置为 &lt;strong&gt;2×i+1&lt;/strong&gt; ,右子节点的位置为 &lt;strong&gt;2×i+2&lt;/strong&gt; .可以带入到其他节点验证一下.该属性是二叉堆调整的关键.
注意:我们这里索引是从0开始的,如果索引从1开始的话,那么左右子节点的位置即是 &lt;strong&gt;2×i&lt;/strong&gt; 和 &lt;strong&gt;2×i+1&lt;/strong&gt; .&lt;/p&gt;

&lt;h3 id=&quot;二叉堆的基本操作&quot;&gt;二叉堆的基本操作&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;上浮:由下至上的堆有序化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果堆的有序状态因为某个节点的变得比它的父节点更大而打破,那么我们就需要通过交换它和它的父节点来修复堆,直到这个节点向上移动遇到一个更大的节点.若这个节点位置为k,那他的父节点位置就是 &lt;strong&gt;k/2&lt;/strong&gt;,不断和父节点比较并交换位置即可.&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;上浮&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;private void swim(int[] nums, int k){
    while(k&amp;gt;1 &amp;amp;&amp;amp; nums[k/2]&amp;lt;nums[k]){
        int temp = nums[k/2];
        nums[k/2] = nums[k];
        nums[k] = temp;
        k = k/2;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;下沉:由上至下的堆有序化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果堆的有序状态因为某个节点变的比它的两个子节点或者其中之一更小而打破了,那么我们可以通过将它和它的两个子节点中的较大者交换来恢复堆,交换知道它的子节点都比他更小或达到堆的底部.若节点的位置为k,那么它的左右子节点的位置为 &lt;strong&gt;2×k+1&lt;/strong&gt; 和 &lt;strong&gt;2×k+2&lt;/strong&gt;,不断和这两个节点比较并交换即可.&lt;/p&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;下沉&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h4 id=&quot;代码-1&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;private void sink(int[] nums, int k, int N){
    while(2*k&amp;lt;=N){
        int j=2*k;
        if(j&amp;lt;N &amp;amp;&amp;amp; nums[j+1]&amp;gt;nums[j]){
            j++;
        }
        if(nums[j] &amp;lt; nums[k]){
            break;
        }
        int temp = nums[k];
        nums[k] = nums[j];
        nums[j] = temp;
        k=j
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;基本思想&quot;&gt;基本思想&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;主要就是构建堆,利用大顶堆或小顶堆的性质排序&lt;/p&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;堆排序其实就是两步&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;建堆:利用上浮和下沉构建大顶堆或小顶堆,上浮下沉图解见上方&lt;/li&gt;
  &lt;li&gt;排序：
    &lt;ul&gt;
      &lt;li&gt;若为升序排序,那么应该建立大顶堆,然后将根节点和堆的最后一个节点交换,并将新的根节点下沉到合适位置即调整堆为大顶堆,此时数组最后即为最大元素,重复以上步骤,直到处理的数组长度为1.&lt;/li&gt;
      &lt;li&gt;若为降序排序,那么就应该建立小顶堆,重复上面的交换流程,整个数据交换后数组有序.
    - - -&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;堆排序图解&quot;&gt;堆排序图解&lt;/h3&gt;
&lt;hr /&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;HeapSort&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h4 id=&quot;代码-2&quot;&gt;代码&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;private int[] heapSort(int[] nums){
    int len = nums.length();
    //1.利用下沉建立大顶堆
    for(int i=len/2;i&amp;gt;=0;i--){
        sink(nums, i, len);
    }
    //2.排序
    while(len &amp;gt; 1){
        swap(nums, 0 ,--len);
        sink(nums, 0, len); 
    }
    return nums;
}

//下沉
private void sink(int[] nums, int k, int len){
    while(k*2+1&amp;lt;len){
        int j=2*k+1;
        while(j+1&amp;lt;len &amp;amp;&amp;amp; nums[j+1]&amp;gt;nums[j]){
            j++;
        }
        if(nums[j]&amp;lt;nums[k]){
            break;
        }
        swap(nums, k, j);
        k=j;
    }
}

private void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度:O(n*logn)&lt;/p&gt;

  &lt;p&gt;空间复杂度:O(1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;其他语言&quot;&gt;其他语言&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;C++&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
	//内部正序
	void bubbleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums)
	{
		int len = nums.size();
		for (int i = 0; i &amp;lt; len - 1; i++)
		{
			for (int j = 0; j &amp;lt; len-i-1; j++)
			{
				if (nums[j + 1] &amp;lt; nums[j])
				{
					int temp = nums[j];
					nums[j] = nums[j + 1];
					nums[j + 1] = temp;
				}
			}
		}
	}

	//内部逆序
	void bubbleSort1(vector&amp;lt;int&amp;gt;&amp;amp; nums)
	{
		int len = nums.size();
		for (int i = 0; i &amp;lt; len; i++)
		{
			for (int  j = len-1; j &amp;gt;i; j--)
			{
				if (nums[j-1]&amp;gt;nums[j])
				{
					int temp = nums[j];
					nums[j] = nums[j - 1];
					nums[j - 1] = temp;
				}
			}
		}
	}
};

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;python3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Solution:
    #内部正序
    def bubbleSort(self, nums:List[int]):
        length = len(nums)
        for i in range(0, length-1):
            for j in range(0, length-i-1):
                if nums[j+1] &amp;lt; nums[j]:
                    temp = nums[j]
                    nums[j] = nums[j+1]
                    nums[j+1] = temp

    #内部正序
    def bubbleSort1(self, nums:List[int]):
        length = len(nums)
        for i in range(0, length):
            for j in (length-1, i, -1):
                if nums[j-1]&amp;gt;nums[j]:
                    temp = nums[j]
                    nums[j] = nums[j-1]
                    nums[j-1] = temp
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;//内部逆序
func bubbleSort(nums []int) {
	len :=len(nums)
	for i:=0;i&amp;lt;len-1;i++ {
		for j:=0;j&amp;lt;len-i-1;j++ {
			if nums[j+1]&amp;lt;nums[j] {
				temp:=nums[j]
				nums[j]=nums[j+1]
				nums[j+1]=temp
			}
		}
	}
}

func bubbleSort1(nums []int){
	len := len(nums)
	for i:=0; i&amp;lt;len;i++ {
		for j:=len-1;j&amp;gt;i;j-- {
			if nums[j] &amp;lt; nums[j-1] {
				temp:=nums[j]
				nums[j]=nums[j-1]
				nums[j-1]=temp
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">前置概念 完全二叉树:叶子节点只能出现在最下层或次下层,且最下层的叶子节点集中在树的左部。即除了最后一层其他层的节点个数都是满的而且最后一层的叶子节点必须靠左. 完全二叉树</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Quicksort</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Quicksort" />
      <published>2021-08-17T00:00:00+08:00</published>
      <updated>2021-08-17T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/QuickSort</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;h3 id=&quot;基本思想&quot;&gt;基本思想&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;是一种分治的排序算法,他将一个数组分成两个子数组,将两部分独立的排序.&lt;/p&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;首先以left=0,right=nums.len-1进行排序,最外层需要保证left&amp;lt;right&lt;/li&gt;
  &lt;li&gt;排序首先以nums[left]为基准值base&lt;/li&gt;
  &lt;li&gt;然后将右指针从右往左遍历,当left&amp;lt;right且nums[right]&amp;gt;=base时,将右指针右移,否则就将右指针的值替换到左指针处 (此步的意义就是找到最右侧小于基准值base并将右侧值赋值到左指针的值)&lt;/li&gt;
  &lt;li&gt;接着将左指针从左往右遍历,当left&amp;lt;right且nums[left]&amp;lt;=base时,将左指针左移,否则将左指针的值赋值给右指针 (此步同步骤三相反,即找到最左侧大于基准值base的值,并将此值赋值给右指针的值)&lt;/li&gt;
  &lt;li&gt;最后当两个指针相交时,将base值赋值给nums[left],并同时将left返回作为下个区间的中间值&lt;/li&gt;
  &lt;li&gt;接下来就是递归遍历[left,temp-1]和[temp+1,right],遍历结束即数组有序
    &lt;hr /&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;图解&quot;&gt;图解&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;第一层排序[0, 4]
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort1.jpg&quot; alt=&quot;quickSort1&quot; class=&quot;img-responsive img-centered&quot; /&gt;
第二层排序[0,-1]和[1,4]
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort2.jpg&quot; alt=&quot;quickSort2&quot; class=&quot;img-responsive img-centered&quot; /&gt;
第三轮排序[1,1]和[3,4]
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/quickSort/quickSort3.jpg&quot; alt=&quot;quickSort3&quot; class=&quot;img-responsive img-centered&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;public static void quickSort(int[] nums, int left, int right){
    if (left&amp;lt; right){
        int base = division(nums, left, right);
        quickSort(nums, left, base-1);
        quickSort(nums, base+1, right);
    }
}

public static int division(int[] nums, int left, int right){
    int base = nums[left];
    while (left&amp;lt;right){
        while (left&amp;lt;right &amp;amp;&amp;amp; nums[right]&amp;gt;=base){
            right--;
        }
        nums[left] = nums[right];
        while (left&amp;lt;right &amp;amp;&amp;amp; nums[left]&amp;lt;=base){
            left++;
        }
        nums[right] = nums[left];
    }
    nums[left]=base;
    return left;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;时间复杂度:O(nlogn)&lt;/p&gt;

  &lt;p&gt;空间复杂度:O(1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;其他语言&quot;&gt;其他语言&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;c++&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
	void quickSort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right) 
	{
		if (left&amp;lt;right)
		{
			int temp = division(nums, left, right);
			quickSort(nums, left, temp - 1);
			quickSort(nums, temp + 1, right);
		}
	}

	int division(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right)
	{
		int base = nums[left];
		while (left&amp;lt;right)
		{
			while (left &amp;lt; right &amp;amp;&amp;amp; nums[right] &amp;gt;= base) {
				right--;
			}
			nums[left] = nums[right];
			while (left &amp;lt; right &amp;amp;&amp;amp; nums[left] &amp;lt;= base) {
				left++;
			}
			nums[right] = nums[left];
		}
		nums[left] = base;
		return left;
	}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;python3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Solution:
    def quickSort(self, nums:List[int], left:int, right:int):
        def division(nums:List[int], left:int, right:int)-&amp;gt;int:
            base = nums[left]
            while left&amp;lt;right:
                while left&amp;lt;right and nums[right]&amp;gt;=base:
                    right-=1
                nums[left]=nums[right]
                while left&amp;lt;right and nums[left]&amp;lt;=base:
                    left+=1
                nums[right]=nums[left]
            nums[left]=base
            return left
        if left&amp;lt;right:
            temp = division(nums, left ,right)
            self.quickSort(nums, left, temp-1)
            self.quickSort(nums, temp+1, right)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func quickSort(nums []int, left int, right int)  {
		var division func(nums []int, left int, right int) int
		division = func(nums []int, left int, right int) int {
			base := nums[left]
			for left&amp;lt;right {
				for left&amp;lt;right &amp;amp;&amp;amp; nums[right]&amp;gt;=base {
					right--
				}
				nums[left] = nums[right]
				for left&amp;lt;right &amp;amp;&amp;amp; nums[left]&amp;lt;=base {
					left++
				}
				nums[right] = nums[left]
			}
			nums[left]=base
			return left
		}

		if left&amp;lt;right {
			temp:=division(nums, left, right)
			quickSort(nums, left, temp-1)
			quickSort(nums, temp+1, right)
		}
}
&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">基本思想 是一种分治的排序算法,他将一个数组分成两个子数组,将两部分独立的排序.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Bubblesort</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Bubblesort" />
      <published>2021-08-13T00:00:00+08:00</published>
      <updated>2021-08-13T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/BubbleSort</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;h3 id=&quot;基本思想&quot;&gt;基本思想&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;就是两两比较然后交换位置，将较小值不断向前移动&lt;/p&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;首先需要两层循环，外层从i=0开始&lt;/li&gt;
  &lt;li&gt;内层循环的主要作用就根据遍历顺序保证最大值或最小值已经移动到数组的末尾或者开头&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内层有两者方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从前往后：j从0一直遍历到nums.len-1-i 处，同时比较nums[j]和nums[j+1]的值，只有nums[j]&amp;gt;nums[j+1]时才将nums[j]向后移动，每次循环结束保证最大值在末尾&lt;/li&gt;
  &lt;li&gt;从后往前：j从nums.len一直遍历到 i 处，同时比较nums[j-1]和nums[j]的值，只有nums[j-1]&amp;gt;nums[j]时才将nums[j]向前移动，每次循环结束保证最小值在开头&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;内层逆序图解&quot;&gt;内层逆序图解&lt;/h3&gt;
&lt;hr /&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/algorithm/bubbleSort/BubbleSort.jpg&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;bubbleSort&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;//内层逆序遍历
public static void bubbleSort(int[] nums){
     int temp;
    for (int i = 0; i&amp;lt; nums.length - 1; i++ ){
        for (int j = nums.length -1; j&amp;gt;i; j--){
            if (nums[j-1]&amp;gt; nums[j]){
                temp = nums[j-1];
                nums[j-1] = nums[j];
                nums[j] = temp;
            }
        }
    }
}

//内层正序遍历
private static void bubbleSort(int[] nums) {
        if(nums==null || nums.length &amp;lt; 2 ){
            return;
        }
        for (int i = 0; i &amp;lt; nums.length - 1; i++) {
            for (int j = 0; j &amp;lt; nums.length - i -1; j++) {   
                if (nums[j] &amp;gt; nums[j + 1]) {
                    int temp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = temp;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度:O(n^2)&lt;/p&gt;

  &lt;p&gt;空间复杂度:O(1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;算法优化&quot;&gt;算法优化&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;没有什么大的优化，主要是若一次遍历过后中间没有移动的动作说明数组已经有序，无需继续往后遍历，直接结束&lt;/p&gt;
&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static void bubbleSort(int[] nums) {
    int temp;
    boolean flag = true;
    for (int i = 0; i&amp;lt; nums.length - 1; i++ ){
        for (int j = nums.length -1; j&amp;gt;i; j--){
            if (nums[j-1]&amp;gt; nums[j]){
                temp = nums[j-1];
                nums[j-1] = nums[j];
                nums[j] = temp;
                flag = false;
            }
        }
        if (flag){
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;其他语言&quot;&gt;其他语言&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;C++&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
	//内部正序
	void bubbleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums)
	{
		int len = nums.size();
		for (int i = 0; i &amp;lt; len - 1; i++)
		{
			for (int j = 0; j &amp;lt; len-i-1; j++)
			{
				if (nums[j + 1] &amp;lt; nums[j])
				{
					int temp = nums[j];
					nums[j] = nums[j + 1];
					nums[j + 1] = temp;
				}
			}
		}
	}

	//内部逆序
	void bubbleSort1(vector&amp;lt;int&amp;gt;&amp;amp; nums)
	{
		int len = nums.size();
		for (int i = 0; i &amp;lt; len; i++)
		{
			for (int  j = len-1; j &amp;gt;i; j--)
			{
				if (nums[j-1]&amp;gt;nums[j])
				{
					int temp = nums[j];
					nums[j] = nums[j - 1];
					nums[j - 1] = temp;
				}
			}
		}
	}
};

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;python3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Solution:
    #内部正序
    def bubbleSort(self, nums:List[int]):
        length = len(nums)
        for i in range(0, length-1):
            for j in range(0, length-i-1):
                if nums[j+1] &amp;lt; nums[j]:
                    temp = nums[j]
                    nums[j] = nums[j+1]
                    nums[j+1] = temp

    #内部正序
    def bubbleSort1(self, nums:List[int]):
        length = len(nums)
        for i in range(0, length):
            for j in (length-1, i, -1):
                if nums[j-1]&amp;gt;nums[j]:
                    temp = nums[j]
                    nums[j] = nums[j-1]
                    nums[j-1] = temp
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;//内部逆序
func bubbleSort(nums []int) {
	len :=len(nums)
	for i:=0;i&amp;lt;len-1;i++ {
		for j:=0;j&amp;lt;len-i-1;j++ {
			if nums[j+1]&amp;lt;nums[j] {
				temp:=nums[j]
				nums[j]=nums[j+1]
				nums[j+1]=temp
			}
		}
	}
}

func bubbleSort1(nums []int){
	len := len(nums)
	for i:=0; i&amp;lt;len;i++ {
		for j:=len-1;j&amp;gt;i;j-- {
			if nums[j] &amp;lt; nums[j-1] {
				temp:=nums[j]
				nums[j]=nums[j-1]
				nums[j-1]=temp
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">基本思想 就是两两比较然后交换位置，将较小值不断向前移动</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Project 8</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Project 8" />
      <published>2021-07-22T00:00:00+08:00</published>
      <updated>2021-07-22T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/project-8</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;h1 id=&quot;springboot&quot;&gt;springboot&lt;/h1&gt;
&lt;p&gt;springboot test&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test
&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="springboot" />
      

      

      
        <summary type="html">springboot springboot test test</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Project 10</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Project 10" />
      <published>2021-07-22T00:00:00+08:00</published>
      <updated>2021-07-22T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/project-10</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;div align=&quot;center&quot;&gt;&lt;font size=&quot;70&quot;&gt;springboot2&lt;/font&gt;&lt;/div&gt;

&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;

&lt;h1 id=&quot;testalignleft&quot;&gt;test{:align=”left”}&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BiggerYellow/BiggerYellow.github.io/master/img/algorithm/bubbleSort/BubbleSort1.jpg&quot; alt=&quot;rr&quot; class=&quot;img-responsive img-centered&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;

&lt;p align=&quot;left&quot;&gt;左对齐&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test2
&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="springboot" />
      

      

      
        <summary type="html">springboot2</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Project 9</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Project 9" />
      <published>2021-07-22T00:00:00+08:00</published>
      <updated>2021-07-22T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/project-9</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;h1 id=&quot;spring2&quot;&gt;spring2&lt;/h1&gt;
&lt;p&gt;spring test2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test2
&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="spring" />
      

      

      
        <summary type="html">spring2 spring test2 test2</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Project 7</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Project 7" />
      <published>2021-07-22T00:00:00+08:00</published>
      <updated>2021-07-22T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/project-7</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;h1 id=&quot;spring&quot;&gt;spring&lt;/h1&gt;
&lt;p&gt;spring test&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test
&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="spring" />
      

      

      
        <summary type="html">spring spring test test</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Project 1</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Project 1" />
      <published>2014-07-18T00:00:00+08:00</published>
      <updated>2014-07-18T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/project-1</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;p&gt;###　test&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;啊实打实&gt;
&lt;/啊实打实&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="Web Development" />
      

      

      
        <summary type="html">###　test</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Project 2</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Project 2" />
      <published>2014-07-17T00:00:00+08:00</published>
      <updated>2014-07-17T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/project-2</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;p&gt;2&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="Web Development" />
      

      

      
        <summary type="html">2</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Project 3</title>
      <link href="https://github.com/jeromelachaud/freelancer-theme/" rel="alternate" type="text/html" title="Project 3" />
      <published>2014-07-16T00:00:00+08:00</published>
      <updated>2014-07-16T00:00:00+08:00</updated>
      <id>https://github.com/jeromelachaud/freelancer-theme/project-3</id>
      <content type="html" xml:base="https://github.com/jeromelachaud/freelancer-theme/">&lt;p&gt;3&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="Web Development" />
      

      

      
        <summary type="html">3</summary>
      

      
      
    </entry>
  
</feed>
