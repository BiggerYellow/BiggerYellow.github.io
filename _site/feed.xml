<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2024-11-25T19:59:03+08:00</updated>
  <id>http://localhost:4000/</id>

  
    <title type="html">黄天霸</title>
  

  
    <subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle>
  

  

  
  
    <entry>
      <title type="html">Redis Quicklist</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Redis Quicklist" />
      <published>2024-10-23T00:00:00+08:00</published>
      <updated>2024-10-23T00:00:00+08:00</updated>
      <id>http://localhost:4000/redis-quicklist</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;快表---quicklist&quot;&gt;快表 - quicklist&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;quicklist 是一个 3.2 版本之后新增的基础数据结构，是 redis 自定义的一种复杂数据结构，将 ziplist 和 adlist 结合到一个数据结构中。主要是作为 list 的基础数据结构。&lt;br /&gt;
在 3.2 之前，list 是根据元素数量的多少采用 ziplist 或者 adlist 作为基础数据结构， 3.2 之后统一改用 quicklist，从数据结构的角度来说， quicklist 结合了两种数据结构的优缺点，复杂但是实用:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;链表在插入，删除节点的时间复杂度很低；但是内存利用率低，且由于内存不连续容易产生内存碎片&lt;/li&gt;
  &lt;li&gt;压缩表内存连续，存储效率高；但是插入和删除的成本太高，需要频繁的进行数据搬移、释放或申请内存&lt;br /&gt;
而 quicklist 通过将每个压缩列表用双向链表的方式连接起来，来寻求一种收益最大化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;redislist数据结构特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;表 list 是一个能维持数据项先后顺序的双向链表&lt;/li&gt;
  &lt;li&gt;在表 list 的两端追加和删除数据极为方便，时间复杂度为 O(1)&lt;/li&gt;
  &lt;li&gt;表 list 也支持在任意中间位置的存取操作，时间复杂度为 O(N)&lt;/li&gt;
  &lt;li&gt;表 list 经常被用作队列使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;内部分布图:&lt;/p&gt;
&lt;center&gt;   
&lt;img src=&quot;../../img/redis/quicklist/redis_quicklist_structure.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;quicklist内存分布图&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;需要注意的几点:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;两端各有 2 个橙黄色的节点，是没有被压缩的。它们的数据指针 zl 指向真正的 ziplist。中间的其他节点是被压缩过的，它们的数据指针 zl 指向被压缩后的 ziplist 结构，即一个 quicklistLZF 结构。&lt;/li&gt;
  &lt;li&gt;左侧头结点上的 ziplist 里有 2 项数据，右侧尾节点上的 ziplist 里有 1 项数据，中间其他节点上的 ziplist 里都有 3 项数据（包括压缩的节点内部）。这表示在表的两端执行过多次 push和pop 操作后的一个状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先是 quicklist 的节点 quicklistNode ，源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.
 * We use bit fields keep the quicklistNode at 32 bytes.
 * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &amp;lt; 32k).
 * encoding: 2 bits, RAW=1, LZF=2.
 * container: 2 bits, NONE=1, ZIPLIST=2.
 * recompress: 1 bit, bool, true if node is temporary decompressed for usage.
 * attempted_compress: 1 bit, boolean, used for verifying during testing.
 * extra: 10 bits, free for future use; pads out the remainder of 32 bits
 *
 * quicklistNode 是一个32字节的结构体，描述quickList的压缩列表。
 * 我们使用位字段将 quicklistNode 控制在 32 字节
 * count: 16位，最大 65536 （最终字节数为 65k，所以最大计数实际小于 32k）
 * encoding: 2位， 原始为1，使用LZF压缩算法为 2
 * container: 2位， 每个链表节点所持有的数据类型是什么，默认的实现是 ziplist，对应的值为2
 * quicklistNode: 1位，如果节点临时解压缩以供使用，则为true
 * attempted_compress: 1位，用于测试时的验证
 * extra:10位，免费供将来使用，补出32位的剩余部分
 *
 * */
typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *zl;
    unsigned int sz;             /* ziplist size in bytes */
    unsigned int count : 16;     /* count of items in ziplist */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can&apos;t compress; too small */
    unsigned int extra : 10; /* more bits to steal for future usage */
} quicklistNode;

/* quicklistLZF is a 4+N byte struct holding &apos;sz&apos; followed by &apos;compressed&apos;.
 * &apos;sz&apos; is byte length of &apos;compressed&apos; field.
 * &apos;compressed&apos; is LZF data with total (compressed) length &apos;sz&apos;
 * NOTE: uncompressed length is stored in quicklistNode-&amp;gt;sz.
 * When quicklistNode-&amp;gt;zl is compressed, node-&amp;gt;zl points to a quicklistLZF
 * quicklistLZF 是一个 4+N 字节的结构体，包含 sz 后面跟着 compressed。
 * sz 是 compressed 字段的长度。
 * compressed 是总长度为 sz 的LZF数据
 * 请注意：非压缩的长度存储在 quicklistNode 的 sz 字段中。
 * 当 quicklistNode 的 zl 是压缩的， 节点的 zl 字段指向 quicklistLZF
 * */
typedef struct quicklistLZF {
    unsigned int sz; /* LZF size in bytes*/
    char compressed[];
} quicklistLZF;

/* Bookmarks are padded with realloc at the end of of the quicklist struct.
 * They should only be used for very big lists if thousands of nodes were the
 * excess memory usage is negligible, and there&apos;s a real need to iterate on them
 * in portions.
 * When not used, they don&apos;t add any memory overhead, but when used and then
 * deleted, some overhead remains (to avoid resonance).
 * The number of bookmarks used should be kept to minimum since it also adds
 * overhead on node deletion (searching for a bookmark to update).
 * 书签在快速列表结构体的末尾使用 realloc 填充。
 * 它们只应该用于非常大的列表，如果有数千个节点，多余的内存使用可以忽略不计，并且确实需要对它们就行部分迭代。
 * 当不使用它们时，它们不会增加任何内存开销，但是当使用并删除它们时，会保留一些开心。
 * 使用的书签数量应该保持在最低限度，因为它也会增加删除节点时的开销。
 * */
typedef struct quicklistBookmark {
    quicklistNode *node;
    char *name;
} quicklistBookmark;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;quicklistNode 实际上就是对 ziplist 的进一步封装，其中包括:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;prev:指向链表前一个节点的指针&lt;/li&gt;
  &lt;li&gt;next:指向链表后一个节点的指针&lt;/li&gt;
  &lt;li&gt;zl:数据指针，如果当前节点的数据没有压缩，那么它指向一个 ziplist 结构；否则，它指向一个 quicklistLZF 结构&lt;/li&gt;
  &lt;li&gt;sz:表示 zl 指向的 ziplist 的总大小（包括 zlbytes、zltail、zllen、zlend和各个数据项）。需要注意的是：如果 ziplist 被压缩了，那么这个 sz 的值仍然是压缩前的 ziplist 大小。&lt;/li&gt;
  &lt;li&gt;count:表示 ziplist 里面包含的数据项个数，这个字段只有 16bit。&lt;/li&gt;
  &lt;li&gt;encoding:表示 ziplist 是否压缩了以及用了哪个压缩算法。目前只有两种取值：2 表示被压缩了（而且用的是 LZF压缩算法），1 表示没有压缩&lt;/li&gt;
  &lt;li&gt;container:是一个预留字段。本来设计是用来表明一个 quicklist 节点下面是直接存数据，还是使用 ziplist 存数据，或者用其他的数据结构来存数据。但是，在目前的实现中，这个值是一个固定的值 2，表示使用 ziplist 作为数据容器&lt;/li&gt;
  &lt;li&gt;recompress:当我们使用类似 lindex 这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置 recompress=1 做一个标记，等有机会再把数据重新压缩&lt;/li&gt;
  &lt;li&gt;attempted_compress:这个值只对 Redis 的自动化测试程序有用。不用管它&lt;/li&gt;
  &lt;li&gt;extra:其他扩展字段，目前也没用上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里从变量 count 开始，都采用了位域的方式进行数据的内存声明，使用 6 个 unsigned int 变量只用到了一个 unsigned int 的内存大小。&lt;br /&gt;
C语言支持位域的方式对结构体中的数据进行声明，也就是可以指定一个类型占用几位:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果相邻位域字段的类型相同，且其位宽之和小于类型的 sizeof 大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；&lt;/li&gt;
  &lt;li&gt;如果相邻位域字段的类型相同，且其位宽之和大于类型的 sizeof 大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍&lt;/li&gt;
  &lt;li&gt;如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++ 采取压缩方式&lt;/li&gt;
  &lt;li&gt;如果位域字段之间穿插着非位域字段，则不进行压缩&lt;/li&gt;
  &lt;li&gt;整个结构体的总大小为最宽基本类型成员大小的整数倍&lt;br /&gt;
sizeof(quicklistNode): //output:32，通过位域的声明方式，quicklistNode 可以节省 24 个字节&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;quicklistLZF 结构表示一个被压缩过的 ziplist。其中：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sz:表示压缩后的 ziplist 大小&lt;/li&gt;
  &lt;li&gt;compressed: 是个柔性数组，存放压缩后的 ziplist字节数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过 quicklist 将 quicklistNode 连接起来就是一个完整的数据结构。源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
 * &apos;count&apos; is the number of total entries.
 * &apos;len&apos; is the number of quicklist nodes.
 * &apos;compress&apos; is: 0 if compression disabled, otherwise it&apos;s the number
 *                of quicklistNodes to leave uncompressed at ends of quicklist.
 * &apos;fill&apos; is the user-requested (or default) fill factor.
 * &apos;bookmakrs are an optional feature that is used by realloc this struct,
 *      so that they don&apos;t consume memory when not used.
 *  quicklist 是一个 40 字节的结构体，描述一个快速列表
 *  count: 表示 ziplist 节点的总数量
 *  len: 表示 quicklist 节点的总数量
 *  compress: 如果关闭压缩则为0， 否则用来表示在 quicklist 的末尾保留未压缩的 quicklistNode 的数量  对应配置:list-compress-depth
 *  0-是个特殊值，表示不压缩。是Redis的默认值
 *  1-表示quicklist两端各有 1 个节点不压缩，中间的节点压缩
 *  2-表示quicklist两端各有 2 个节点不压缩，中间的节点压缩
 *  3-表示quicklist两端各有 3 个节点不压缩，中间的节点压缩
 *  以此类推
 *
 *  fill: ziplist 的大小设置  对应配置:list-max-ziplist-size
 *  当取正值的时候，表示按照数据项个数来限定每个 quicklist 节点上的 ziplist 长度。比如，当这个参数设置成 5 时，表示每个 quicklist 节点的 ziplist 最多包含 5 个数据项
 *  当取负值的时候，表示按照占用字节数来限定每个 quicklist 节点上的 ziplist 长度。这时，它只能取 -1 到 -5 这五个值，每个值含义如下：
 *  -1:每个 quicklist 节点上的 ziplist 大小不能超过 4kb
 *  -2:每个 quicklist 节点上的 ziplist 大小不能超过 8kb (Redis 给的默认值)
 *  -3:每个 quicklist 节点上的 ziplist 大小不能超过 16kb
 *  -4:每个 quicklist 节点上的 ziplist 大小不能超过 32kb
 *  -5:每个 quicklist 节点上的 ziplist 大小不能超过 64kb
 *  bookmakrs: 是 realloc 这个结构体使用的一个可选特性，这样他们在不使用时就不会消耗内存
 *      */
typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all ziplists */
    unsigned long len;          /* number of quicklistNodes */
    int fill : QL_FILL_BITS;              /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
} quicklist;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;head:指向头节点（左侧第一个节点）的指针&lt;/li&gt;
  &lt;li&gt;tail:指向尾节点（右侧第一个节点）的指针&lt;/li&gt;
  &lt;li&gt;count:所有 ziplist 数据项的个数总和&lt;/li&gt;
  &lt;li&gt;len:quicklist 节点的个数&lt;/li&gt;
  &lt;li&gt;fill:16bit，ziplist 大小设置，默认为 -2，存放 list-max-ziplist-size 参数的值&lt;br /&gt;
list-max-ziplist-size 数值含义:
    &lt;ul&gt;
      &lt;li&gt;-1:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 4kb （建议配置）&lt;/li&gt;
      &lt;li&gt;-2:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 8kb （默认配置）&lt;/li&gt;
      &lt;li&gt;-3:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 16kb&lt;/li&gt;
      &lt;li&gt;-4:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 32kb&lt;/li&gt;
      &lt;li&gt;-5:每个 quicklistNode 节点的 ziplist 所占字节数不能超过 64kb&lt;/li&gt;
      &lt;li&gt;任意正数:表示 ziplist 结构最多包含的 entry 个数，最大为 215215&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;list-max-ziplist-size 配置产生产生的原因?&lt;br /&gt;
每个 quicklist 节点上的 ziplist 越短，则内存碎片越多。内存碎片多了，有可能在内存中产品很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个 quicklist 节点上的 ziplist 只包含一个数据项，这就退变成一个普通的双向链表。&lt;br /&gt;
每个 quicklist 节点上的 ziplist 越长，则为 ziplist 分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间，但却找不到一块足够大的空闲空间分配给 ziplist 的情况。这同样会降低存储效率。这种情况的极端是整个 quicklist 只有一个节点，所有的数据项都分配在这仅有的一个节点的 ziplist 里面，这其实就退化成一个 ziplist 了。&lt;br /&gt;
可见，一个 quicklist 节点上的 ziplist 要保持一个合理的长度。那么到底多长合理呢？Redis 提供了一个配置参数 list-max-ziplist-size ，就是为了让使用者可以来根据实际应用场景进行调整优化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;compress:16bit，节点压缩深度设置，存放 list-compress-depth 参数的值&lt;br /&gt;
list-compress-depth:这个参数表示一个 quicklist 两端不被压缩的节点个数。注意:这里的节点个数是指 quicklist 双向链表的节点个数，而不是指 ziplist 里面的数据项个数。实际上，一个 quicklist 节点上的 ziplist，如果被压缩，就是整体被压缩的。&lt;br /&gt;
list-compress-depth取值含义如下：
    &lt;ul&gt;
      &lt;li&gt;0:是个特殊值，表示都不压缩，是默认值&lt;/li&gt;
      &lt;li&gt;1:表示 quicklist 两端各有 1 个节点不压缩，中间的节点压缩&lt;/li&gt;
      &lt;li&gt;2:表示 quicklist 两端各有 2 个节点不压缩，中间的节点压缩&lt;/li&gt;
      &lt;li&gt;3:表示 quicklist 两端各有 3 个节点不压缩，中间的节点压缩&lt;/li&gt;
      &lt;li&gt;以此类推&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;list-compress-depth 配置产生原因？&lt;br /&gt;
当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率较低。如果应用场景符合这个特点，那么 list 还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据压缩&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;quicklist 每个节点的实际数据存储结构为 ziplist，这种结构的主要优势在于节省存储空间。&lt;br /&gt;
为了进一步降低 ziplist 所占用的空间，Redis 允许对 ziplist 进一步压缩，Redis 采用的压缩算法是 LZF，压缩过后的数据可以分成多个片段，每个片段有 2 部分：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一部分是解释字段，另一部分是存放具体的数据字段&lt;/li&gt;
  &lt;li&gt;解释字段可以占用 1~3 个字节，数据字段可能不存在&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;解释字段|数据|……|解释字段|数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LZF 压缩的数据格式有 3 种，即解释字段有 3 种:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;000LLLLL:字面型，解释字段占用 1 个字节，数据字段长度由解释字段后 5 位决定；L 是数据长度字段，数据长度是长度字段组成的字面值加 1。例如：0000 0001 代表数据长度为 2&lt;/li&gt;
  &lt;li&gt;LLLooooo oooooooo:简短重复型，解释字段占用 2 个字节，没有数据字段，数据内容与前面数据内容重复，重复长度小于 8；L 是长度字段，数据长度为长度字段的字面值加 2, o 是偏移量字段，位置偏移量是偏移字段组成的字面值加 1。例如： 0010 0000 0000 0100 代表与前面 5 字节处内容重复，重复 3 字节&lt;/li&gt;
  &lt;li&gt;111ooooo LLLLLLLL oooooooo:批量重复型，解释字段占 3 个字节，没有数据字段，数据内容与前面内容重复；L 是长度字段，数据长度为长度字段的字面值加 9，o 是偏移量字段，位置偏移量是偏移字段组成的字面值加 1。例如：1110 0000 0000 0010 0001 0000 代表与前面 17 字节处内容重复，重复 11 个字节&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;quicklistLZF结构:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* quicklistLZF is a 4+N byte struct holding &apos;sz&apos; followed by &apos;compressed&apos;.
 * &apos;sz&apos; is byte length of &apos;compressed&apos; field.
 * &apos;compressed&apos; is LZF data with total (compressed) length &apos;sz&apos;
 * NOTE: uncompressed length is stored in quicklistNode-&amp;gt;sz.
 * When quicklistNode-&amp;gt;zl is compressed, node-&amp;gt;zl points to a quicklistLZF
 * quicklistLZF 是一个 4+N 字节的结构体，包含 sz 后面跟着 compressed。
 * sz 是 compressed 字段的长度。
 * compressed 是总长度为 sz 的LZF数据
 * 请注意：非压缩的长度存储在 quicklistNode 的 sz 字段中。
 * 当 quicklistNode 的 zl 是压缩的， 节点的 zl 字段指向 quicklistLZF
 * */
typedef struct quicklistLZF {
    unsigned int sz; /* LZF size in bytes*/
    char compressed[];
} quicklistLZF;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;sz:表示该压缩节点的总长度&lt;/li&gt;
  &lt;li&gt;compressed:压缩后的数据片段（多个），每个数据片段由解释字段和数据字段组成&lt;/li&gt;
  &lt;li&gt;当前 ziplist 未压缩长度存在于 quicklistNode -&amp;gt; sz 字段中&lt;/li&gt;
  &lt;li&gt;当 ziplist 被压缩后，node -&amp;gt; zl字段将指向 quicklistLZF&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;压缩&lt;br /&gt;
LZF 数据压缩的基本思想是: 数据与前面重复的，记录重复位置以及重复长度，否则直接记录原始数据内容。&lt;br /&gt;
压缩算法的流程如下: 遍历输入字符串，对当前字符及后面 2 个字符进行散列运算，如果在 Hash 表中找到曾经出现的记录，则计算重复字节的长度以及位置，反之直接输出数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;/*
 * compressed format
 *
 * 000LLLLL &amp;lt;L+1&amp;gt;    ; literal, L+1=1..33 octets
 * LLLooooo oooooooo ; backref L+1=1..7 octets, o+1=1..4096 offset
 * 111ooooo LLLLLLLL oooooooo ; backref L+8 octets, o+1=1..4096 offset
 */
unsigned int
lzf_compress (const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压缩&lt;br /&gt;
根据 LZF 压缩后的数据格式，可以较为容易地实现 LZF 的解压缩。需要注意的是，可能存在重复数据与当前位置重叠的情况，例如在当前位置前的 15 个字节处，重复了 20 个字节，此时需要按位逐个复制。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lzf_decompress&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;源码解析&quot;&gt;源码解析&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;创建节点&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;/* Create a new quicklist.
 * Free with quicklistRelease().
 * 创建一个快速列表
 * 通过quicklistRelease 释放
 * */
quicklist *quicklistCreate(void) {
    struct quicklist *quicklist;

    //分配内存
    quicklist = zmalloc(sizeof(*quicklist));
    //初始化头尾节点为null
    quicklist-&amp;gt;head = quicklist-&amp;gt;tail = NULL;
    //初始化快表节点的长度
    quicklist-&amp;gt;len = 0;
    //初始化压缩列表的长度
    quicklist-&amp;gt;count = 0;
    //初始化压缩的标识
    quicklist-&amp;gt;compress = 0;
    //初始化 压缩列表的大小设置为-2
    quicklist-&amp;gt;fill = -2;
    quicklist-&amp;gt;bookmark_count = 0;
    return quicklist;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化快表，各个字段初始化默认值，fill 默认为 -2，也就是说每个 quicklistNode 中的 ziplist 最长是 8k 字节。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;节点插入&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;插入流程图：&lt;/p&gt;
&lt;center&gt;   
&lt;img src=&quot;../../img/redis/quicklist/quicklistPush.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;quicklistPush&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;/* Wrapper to allow argument-based switching between HEAD/TAIL pop
 * 包装器允许在 头部和尾部 pop 之间基于参数的切换
 * */
void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
                   int where) {
    //若当前位置是头部 则在头部插入
    if (where == QUICKLIST_HEAD) {
        quicklistPushHead(quicklist, value, sz);
    } else if (where == QUICKLIST_TAIL) {//若当前位置是尾部 则在尾部插入
        quicklistPushTail(quicklist, value, sz);
    }
}

/* Add new entry to head node of quicklist.
 * 在快表的头部新增节点
 *
 * Returns 0 if used existing head.
 * Returns 1 if new head created.
 * 如果使用已存在的头部则返回0，如果创建新头部则返回1
 * */
int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    //定义原始快表头部
    quicklistNode *orig_head = quicklist-&amp;gt;head;
    assert(sz &amp;lt; UINT32_MAX); /* TODO: add support for quicklist nodes that are sds encoded (not zipped) */
    //检查头部是否能够允许插入新元素
    if (likely(
            _quicklistNodeAllowInsert(quicklist-&amp;gt;head, quicklist-&amp;gt;fill, sz))) {
        //将新元素插入到 压缩列表头部
        quicklist-&amp;gt;head-&amp;gt;zl =
            ziplistPush(quicklist-&amp;gt;head-&amp;gt;zl, value, sz, ZIPLIST_HEAD);
        //更新压缩列表大小
        quicklistNodeUpdateSz(quicklist-&amp;gt;head);
    } else {//若原头部没有空间插入则新建节点插入在头部
        //新建快表节点
        quicklistNode *node = quicklistCreateNode();
        //为 node 初始化压缩列表，同时将新节点插入压缩列表头部
        node-&amp;gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
        //更新压缩长度
        quicklistNodeUpdateSz(node);
        //将新节点插入到快表头部
        _quicklistInsertNodeBefore(quicklist, quicklist-&amp;gt;head, node);
    }
    //节点计数+1
    quicklist-&amp;gt;count++;
    quicklist-&amp;gt;head-&amp;gt;count++;
    return (orig_head != quicklist-&amp;gt;head);
}

/* Add new entry to tail node of quicklist.
 * 同插入头部
 * Returns 0 if used existing tail.
 * Returns 1 if new tail created. */
int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_tail = quicklist-&amp;gt;tail;
    assert(sz &amp;lt; UINT32_MAX); /* TODO: add support for quicklist nodes that are sds encoded (not zipped) */
    if (likely(
            _quicklistNodeAllowInsert(quicklist-&amp;gt;tail, quicklist-&amp;gt;fill, sz))) {
        quicklist-&amp;gt;tail-&amp;gt;zl =
            ziplistPush(quicklist-&amp;gt;tail-&amp;gt;zl, value, sz, ZIPLIST_TAIL);
        quicklistNodeUpdateSz(quicklist-&amp;gt;tail);
    } else {
        quicklistNode *node = quicklistCreateNode();
        node-&amp;gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeAfter(quicklist, quicklist-&amp;gt;tail, node);
    }
    quicklist-&amp;gt;count++;
    quicklist-&amp;gt;tail-&amp;gt;count++;
    return (orig_tail != quicklist-&amp;gt;tail);
}

/**
 * 检查插入位置的 ziplist 是否能容纳该元素
 * 计算新插入元素的大小（new_sz），这个大小等于 quicklistNode 的当前大小（node-&amp;gt;sz）、插入元素的大小（）
 */
REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
                                           const int fill, const size_t sz) {
    if (unlikely(!node))
        return 0;

    int ziplist_overhead;
    /* size of previous offset
     * 计算下一个节点的 prev 的偏移量大小
     * */
    if (sz &amp;lt; 254) //小于254时 后一个节点的 pre 只有 1字节，否则为 5字节
        ziplist_overhead = 1;
    else
        ziplist_overhead = 5;

    /* size of forward offset
     * 计算下一个节点的 encoding 大小
     * */
    if (sz &amp;lt; 64) //若小于 64 字节当前节点的 encoding 为 1字节
        ziplist_overhead += 1;
    else if (likely(sz &amp;lt; 16384)) //若小于 16384 encoding 为 2字节
        ziplist_overhead += 2;
    else
        ziplist_overhead += 5; //其余情况都为 5 字节

    /* new_sz overestimates if &apos;sz&apos; encodes to an integer type
     * new_sz 高估了 sz 可以被编码整数类型的场景
     * */
    //计算新 sz 的值，原sz + 新sz + 新增偏移量大小   忽略连锁更新的情况
    unsigned int new_sz = node-&amp;gt;sz + sz + ziplist_overhead;
    //检查 fill 为负数是否超过单存储限制，不超过直接返回1
    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))
        return 1;
    /* when we return 1 above we know that the limit is a size limit (which is
     * safe, see comments next to optimization_level and SIZE_SAFETY_LIMIT)
     * 当我们返回上面的 1 时，我们知道限制是一个大小限制
     * */
    //校验单个节点是否超过 8 kb，主要防止fill为正数时单个节点内存过大
    else if (!sizeMeetsSafetyLimit(new_sz))
        return 0;
    //fill 为正数 是否超过存储限制
    else if ((int)node-&amp;gt;count &amp;lt; fill)
        return 1;
    else
        return 0;
}


unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
    unsigned char *p;
    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
    //压缩列表插入
    return __ziplistInsert(zl,p,s,slen);
}


/* Wrappers for node inserting around existing node. */
REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
                                             quicklistNode *old_node,
                                             quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 0);
}

REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
                                            quicklistNode *old_node,
                                            quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 1);
}


/* Insert &apos;new_node&apos; after &apos;old_node&apos; if &apos;after&apos; is 1.
 * Insert &apos;new_node&apos; before &apos;old_node&apos; if &apos;after&apos; is 0.
 * Note: &apos;new_node&apos; is *always* uncompressed, so if we assign it to
 *       head or tail, we do not need to uncompress it.
 * 如果 after=1 将 new_node 插入到 old_node 之后。
 * 如果 after=0 将 new_node 插入到 old_node 之前。
 * 注意：new_node 总是未压缩的，所以当我们将它设置到头部或者末尾时不需要解压缩他们
 *       */
REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
                                        quicklistNode *old_node,
                                        quicklistNode *new_node, int after) {
    //若 after=1，则将新节点插入到旧节点之后
    if (after) {
        //将新节点的 prev 指针指向旧节点
        new_node-&amp;gt;prev = old_node;
        //若存在旧节点
        if (old_node) {
            //将 old_node 的 next 指针赋值给 new_node 的 next，即将新节点的下一个节点指向原来的下一个
            new_node-&amp;gt;next = old_node-&amp;gt;next;
            //若旧节点存在下一个节点
            if (old_node-&amp;gt;next)
                //将旧节点的下一个节点的上一个节点指针指向新节点
                old_node-&amp;gt;next-&amp;gt;prev = new_node;
            //旧节点的下一个节点指针指向新节点
            old_node-&amp;gt;next = new_node;
        }
        //快表最后一个节点为旧节点
        if (quicklist-&amp;gt;tail == old_node)
            //更新结尾节点为新节点
            quicklist-&amp;gt;tail = new_node;
    } else {//其他情况将新节点插入到旧节点之前
        //新节点的下一个节点指向到旧节点
        new_node-&amp;gt;next = old_node;
        //如果存在旧节点
        if (old_node) {
            //将新节点的上一个节点指针指向旧节点的上一个节点指针
            new_node-&amp;gt;prev = old_node-&amp;gt;prev;
            //如果存在旧节点的上一个节点
            if (old_node-&amp;gt;prev)
                //将上一个节点的下一个节点指针指向新节点
                old_node-&amp;gt;prev-&amp;gt;next = new_node;
            //将旧节点的上一个节点指针指向新节点
            old_node-&amp;gt;prev = new_node;
        }
        //如果快表的头结点为旧节点
        if (quicklist-&amp;gt;head == old_node)
            //更新头结点为新节点
            quicklist-&amp;gt;head = new_node;
    }
    /* If this insert creates the only element so far, initialize head/tail.
     * 如果插入导致创建了只有一个元素，则初始化头结点和尾节点
     * */
    if (quicklist-&amp;gt;len == 0) {
        quicklist-&amp;gt;head = quicklist-&amp;gt;tail = new_node;
    }

    /* Update len first, so in __quicklistCompress we know exactly len
     * 首先更新长度，所以在 __quicklistCompress 中我们知道长度
     * */
    quicklist-&amp;gt;len++;

    //如果存在旧节点
    if (old_node)
        //尝试将旧节点压缩
        quicklistCompress(quicklist, old_node);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于 list 而言，头部或者尾部插入是最简单的。&lt;br /&gt;
头插和尾插方法调用过程相似，一个处理 head 节点，一个处理 tail 节点。方法内部都调用了 _quicklistNodeAllowInsert 先判断了是否能直接在当前头尾节点插入，如果能就直接插入到对应的 ziplist 里，否则就需要新建一个新节点再操作。  _quicklistNodeAllowInsert 其实就是根据 fill 的值来判断是否已经超过最大容量。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果现有头部大小允许插入新节点，则直接插入到压缩列表中并更新压缩列表大小&lt;/li&gt;
  &lt;li&gt;如果现有头部大小不允许插入新节点，则新建头部为待插入的节点的压缩列表并将其指向新增的快表节点 quicklistNode 的属性 zl，更新压缩列表大小，最后将新快表节点插入到原快表头部&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;特定位置插入&lt;/em&gt;
头插尾插比较简单，但 quicklist 在非头尾插入就比较繁琐了，因为要考虑到插入位置、前后节点的存储情况。&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/quicklist/quicklistInsert.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;quicklistInsert&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;/* Insert a new entry before or after existing entry &apos;entry&apos;.
 * 在已有节点 entry 之前或之后插入一个新节点。
 *
 * If after==1, the new value is inserted after &apos;entry&apos;, otherwise
 * the new value is inserted before &apos;entry&apos;.
 * 如果 after=1，新值插入在 entry 之后，否则新值插入在 entry 之前
 * */
REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,
                                   void *value, const size_t sz, int after) {
    int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;
    int fill = quicklist-&amp;gt;fill;
    quicklistNode *node = entry-&amp;gt;node;
    quicklistNode *new_node = NULL;
    assert(sz &amp;lt; UINT32_MAX); /* TODO: add support for quicklist nodes that are sds encoded (not zipped) */

    //如果不存在已有节点，则直接新建节点插入
    if (!node) {
        /* we have no reference node, so let&apos;s create only node in the list
         * 没有参考节点，所以直接在列表中创建新节点
         * */
        D(&quot;No node given!&quot;);
        //创建新快表节点
        new_node = quicklistCreateNode();
        //创建压缩列表节点
        new_node-&amp;gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
        //向 quicklist 中插入新节点
        __quicklistInsertNode(quicklist, NULL, new_node, after);
        //节点计数加1
        new_node-&amp;gt;count++;
        quicklist-&amp;gt;count++;
        return;
    }

    /* Populate accounting flags for easier boolean checks later
     * 填充记账标志，以便以后更容易地进行布尔检查
     * */
    //检查要插入的节点是否是满的，若已满 full设置为1，未满则为默认0
    if (!_quicklistNodeAllowInsert(node, fill, sz)) {
        D(&quot;Current node is full with count %d with requested fill %lu&quot;,
          node-&amp;gt;count, fill);
        full = 1;
    }

    //检查要插入的节点是否在当前ziplist尾部  after == 1 且 当前偏移量等于节点数量
    if (after &amp;amp;&amp;amp; (entry-&amp;gt;offset == node-&amp;gt;count)) {
        D(&quot;At Tail of current ziplist&quot;);
        at_tail = 1;
        //检查下一个节点是否已满
        if (!_quicklistNodeAllowInsert(node-&amp;gt;next, fill, sz)) {
            D(&quot;Next node is full too.&quot;);
            full_next = 1;
        }
    }

    //检查要插入的节点是否在头部 after==0 且 当前偏移量==0
    if (!after &amp;amp;&amp;amp; (entry-&amp;gt;offset == 0)) {
        D(&quot;At Head&quot;);
        at_head = 1;
        //检查上一个节点是否已满
        if (!_quicklistNodeAllowInsert(node-&amp;gt;prev, fill, sz)) {
            D(&quot;Prev node is full too.&quot;);
            full_prev = 1;
        }
    }

    /* Now determine where and how to insert the new element
     * 现在确定在哪里以及如何插入新元素
     * */
    //当前节点未满 且 在 entry 之后插入
    if (!full &amp;amp;&amp;amp; after) {
        D(&quot;Not full, inserting after current position.&quot;);
        //将已压缩节点解压
        quicklistDecompressNodeForUse(node);
        //取下一个节点，若在末尾节点则返回 null
        unsigned char *next = ziplistNext(node-&amp;gt;zl, entry-&amp;gt;zi);
        //若next 为 null，即代表往末尾插入，直接调用 ziplistPush 方法向末尾插入
        if (next == NULL) {
            node-&amp;gt;zl = ziplistPush(node-&amp;gt;zl, value, sz, ZIPLIST_TAIL);
        } else {
            //若不为null，则走插入逻辑，插入在 next 节点之后
            node-&amp;gt;zl = ziplistInsert(node-&amp;gt;zl, next, value, sz);
        }
        //节点计数加 1
        node-&amp;gt;count++;
        //更新 sz 属性
        quicklistNodeUpdateSz(node);
        //重新压缩节点
        quicklistRecompressOnly(quicklist, node);
    } else if (!full &amp;amp;&amp;amp; !after) { //当前节点未满 且 在 entry 之前插入
        D(&quot;Not full, inserting before current position.&quot;);
        //将已压缩节点解压
        quicklistDecompressNodeForUse(node);
        //直接在当前节点之前插入新增节点
        node-&amp;gt;zl = ziplistInsert(node-&amp;gt;zl, entry-&amp;gt;zi, value, sz);
        //同上
        node-&amp;gt;count++;
        quicklistNodeUpdateSz(node);
        quicklistRecompressOnly(quicklist, node);
    } else if (full &amp;amp;&amp;amp; at_tail &amp;amp;&amp;amp; node-&amp;gt;next &amp;amp;&amp;amp; !full_next &amp;amp;&amp;amp; after) {
        /* If we are: at tail, next has free space, and inserting after:
         *   - insert entry at head of next node.
         *   如果当前节点是满的，要插入的位置是当前节点的尾部，且下一个节点还有空间，那就插入到下一个节点的头部
         *   */
        D(&quot;Full and tail, but next isn&apos;t full; inserting next node head&quot;);
        new_node = node-&amp;gt;next;
        quicklistDecompressNodeForUse(new_node);
        //在下一个节点的头部插入
        new_node-&amp;gt;zl = ziplistPush(new_node-&amp;gt;zl, value, sz, ZIPLIST_HEAD);
        new_node-&amp;gt;count++;
        quicklistNodeUpdateSz(new_node);
        quicklistRecompressOnly(quicklist, new_node);
    } else if (full &amp;amp;&amp;amp; at_head &amp;amp;&amp;amp; node-&amp;gt;prev &amp;amp;&amp;amp; !full_prev &amp;amp;&amp;amp; !after) {
        /* If we are: at head, previous has free space, and inserting before:
         *   - insert entry at tail of previous node.
         *   如果当前节点是满的，要插入的位置是当前节点的头部，且头一个节点还有空间，那就插入到前一个节点的尾部
         *   */
        D(&quot;Full and head, but prev isn&apos;t full, inserting prev node tail&quot;);
        new_node = node-&amp;gt;prev;
        quicklistDecompressNodeForUse(new_node);
        //插入到前一个节点的尾部
        new_node-&amp;gt;zl = ziplistPush(new_node-&amp;gt;zl, value, sz, ZIPLIST_TAIL);
        new_node-&amp;gt;count++;
        quicklistNodeUpdateSz(new_node);
        quicklistRecompressOnly(quicklist, new_node);
    } else if (full &amp;amp;&amp;amp; ((at_tail &amp;amp;&amp;amp; node-&amp;gt;next &amp;amp;&amp;amp; full_next &amp;amp;&amp;amp; after) ||
                        (at_head &amp;amp;&amp;amp; node-&amp;gt;prev &amp;amp;&amp;amp; full_prev &amp;amp;&amp;amp; !after))) {
        /* If we are: full, and our prev/next is full, then:
         *   - create new node and attach to quicklist
         * 如果当前节点是满的，前后节点也是满的，那就创建一个新的节点进入
         *   */
        D(&quot;\tprovisioning new node...&quot;);
        //新建一个节点
        new_node = quicklistCreateNode();
        //更新新节点 zl 信息
        new_node-&amp;gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
        new_node-&amp;gt;count++;
        quicklistNodeUpdateSz(new_node);
        //将新节点插入到旧节点之后
        __quicklistInsertNode(quicklist, node, new_node, after);
    } else if (full) {
        /* else, node is full we need to split it. */
        /* covers both after and !after cases
         * 否则，节点是满的，我们需要把它分裂成两个新节点，覆盖插入之前和之后两种情况，一般用于插入到当前节点 ziplist 中间某个位置时
         * */
        D(&quot;\tsplitting node...&quot;);
        quicklistDecompressNodeForUse(node);
        //按照 after 将节点拆分
        new_node = _quicklistSplitNode(node, entry-&amp;gt;offset, after);
        //将新节点插入到刚创建的节点中
        new_node-&amp;gt;zl = ziplistPush(new_node-&amp;gt;zl, value, sz,
                                   after ? ZIPLIST_HEAD : ZIPLIST_TAIL);
        new_node-&amp;gt;count++;
        quicklistNodeUpdateSz(new_node);
        __quicklistInsertNode(quicklist, node, new_node, after);
        //旧节点合并
        _quicklistMergeNodes(quicklist, node);
    }

    quicklist-&amp;gt;count++;
}


/* Insert &apos;new_node&apos; after &apos;old_node&apos; if &apos;after&apos; is 1.
 * Insert &apos;new_node&apos; before &apos;old_node&apos; if &apos;after&apos; is 0.
 * Note: &apos;new_node&apos; is *always* uncompressed, so if we assign it to
 *       head or tail, we do not need to uncompress it.
 * 如果 after=1 将 new_node 插入到 old_node 之后。
 * 如果 after=0 将 new_node 插入到 old_node 之前。
 * 注意：new_node 总是未压缩的，所以当我们将它设置到头部或者末尾时不需要解压缩他们
 *       */
REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
                                        quicklistNode *old_node,
                                        quicklistNode *new_node, int after) {
    //若 after=1，则将新节点插入到旧节点之后
    if (after) {
        //将新节点的 prev 指针指向旧节点
        new_node-&amp;gt;prev = old_node;
        //若存在旧节点
        if (old_node) {
            //将 old_node 的 next 指针赋值给 new_node 的 next，即将新节点的下一个节点指向原来的下一个
            new_node-&amp;gt;next = old_node-&amp;gt;next;
            //若旧节点存在下一个节点
            if (old_node-&amp;gt;next)
                //将旧节点的下一个节点的上一个节点指针指向新节点
                old_node-&amp;gt;next-&amp;gt;prev = new_node;
            //旧节点的下一个节点指针指向新节点
            old_node-&amp;gt;next = new_node;
        }
        //快表最后一个节点为旧节点
        if (quicklist-&amp;gt;tail == old_node)
            //更新结尾节点为新节点
            quicklist-&amp;gt;tail = new_node;
    } else {//其他情况将新节点插入到旧节点之前
        //新节点的下一个节点指向到旧节点
        new_node-&amp;gt;next = old_node;
        //如果存在旧节点
        if (old_node) {
            //将新节点的上一个节点指针指向旧节点的上一个节点指针
            new_node-&amp;gt;prev = old_node-&amp;gt;prev;
            //如果存在旧节点的上一个节点
            if (old_node-&amp;gt;prev)
                //将上一个节点的下一个节点指针指向新节点
                old_node-&amp;gt;prev-&amp;gt;next = new_node;
            //将旧节点的上一个节点指针指向新节点
            old_node-&amp;gt;prev = new_node;
        }
        //如果快表的头结点为旧节点
        if (quicklist-&amp;gt;head == old_node)
            //更新头结点为新节点
            quicklist-&amp;gt;head = new_node;
    }
    /* If this insert creates the only element so far, initialize head/tail.
     * 如果插入导致创建了只有一个元素，则初始化头结点和尾节点
     * */
    if (quicklist-&amp;gt;len == 0) {
        quicklist-&amp;gt;head = quicklist-&amp;gt;tail = new_node;
    }

    /* Update len first, so in __quicklistCompress we know exactly len
     * 首先更新长度，所以在 __quicklistCompress 中我们知道长度
     * */
    quicklist-&amp;gt;len++;

    //如果存在旧节点
    if (old_node)
        //尝试将旧节点压缩
        quicklistCompress(quicklist, old_node);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码比较长，总结如下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果当前被插入节点不满，直接插入。&lt;/li&gt;
  &lt;li&gt;如果当前被插入节点是满的，要插入的位置是当前节点的尾部，且后一个节点有空间，那就插到后一个节点的头部。&lt;/li&gt;
  &lt;li&gt;如果当前被插入节点是满的，要插入的位置是当前节点的头部，且前一个节点有空间，那就插到前一个节点的尾部。&lt;/li&gt;
  &lt;li&gt;如果当前被插入节点是满的，前后节点也是满的，要插入的位置是当前节点的头部或者尾部，那就创建一个新的节点插进去。&lt;/li&gt;
  &lt;li&gt;否则，当前节点是满的，且要插入的位置在当前节点的中间位置，我们需要把当前节点分裂成两个新节点，然后再插入。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;删除节点&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;源码分析:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;/* Delete one element represented by &apos;entry&apos;
 * 删除一个由 entry 表示的元素
 *
 * &apos;entry&apos; stores enough metadata to delete the proper position in
 * the correct ziplist in the correct quicklist node.
 * entry 存储了足够的元数据以删除适当的位置，在正确的压缩列表在正确的快速列表节点
 * */
void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
    quicklistNode *prev = entry-&amp;gt;node-&amp;gt;prev;
    quicklistNode *next = entry-&amp;gt;node-&amp;gt;next;
    //删除当前节点
    int deleted_node = quicklistDelIndex((quicklist *)entry-&amp;gt;quicklist,
                                         entry-&amp;gt;node, &amp;amp;entry-&amp;gt;zi);

    /* after delete, the zi is now invalid for any future usage.
     * 在删除之后， zi 现在对任何将来的使用都是无效的
     * */
    iter-&amp;gt;zi = NULL;

    /* If current node is deleted, we must update iterator node and offset.
     * 如果当前节点已经被删除了，我们必须更新迭代节点和偏移
     * */
    if (deleted_node) {
        //若是迭代方向为头部
        if (iter-&amp;gt;direction == AL_START_HEAD) {
            //迭代器当前指向下一个节点
            iter-&amp;gt;current = next;
            //偏移设置为0
            iter-&amp;gt;offset = 0;
        } else if (iter-&amp;gt;direction == AL_START_TAIL) { //若是迭代方向为尾部
            //迭代器当前指向上一个节点
            iter-&amp;gt;current = prev;
            //偏移设置为-1
            iter-&amp;gt;offset = -1;
        }
    }
    /* else if (!deleted_node), no changes needed.
     * we already reset iter-&amp;gt;zi above, and the existing iter-&amp;gt;offset
     * doesn&apos;t move again because:
     *   - [1, 2, 3] =&amp;gt; delete offset 1 =&amp;gt; [1, 3]: next element still offset 1
     *   - [1, 2, 3] =&amp;gt; delete offset 0 =&amp;gt; [2, 3]: next element still offset 0
     *  if we deleted the last element at offet N and now
     *  length of this ziplist is N-1, the next call into
     *  quicklistNext() will jump to the next node. */
}

/* Delete one entry from list given the node for the entry and a pointer
 * to the entry in the node.
 * 从给定条目节点的列表中删除一个条目，还有一个指向节点中条目的指针
 *
 * Note: quicklistDelIndex() *requires* uncompressed nodes because you
 *       already had to get *p from an uncompressed node somewhere.
 *
 * Returns 1 if the entire node was deleted, 0 if node still exists.
 * Also updates in/out param &apos;p&apos; with the next offset in the ziplist.
 * 返回1代表节点被删除了，0代表节点还存在
 * */
REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
                                   unsigned char **p) {
    int gone = 0;

    //删除压缩列表 zl
    node-&amp;gt;zl = ziplistDelete(node-&amp;gt;zl, p);
    //压缩列表节点减少
    node-&amp;gt;count--;
    //如果节点数量为 0
    if (node-&amp;gt;count == 0) {
        gone = 1;
        //删除快表中的节点
        __quicklistDelNode(quicklist, node);
    } else {
        //更新快表大小
        quicklistNodeUpdateSz(node);
    }
    //快表节点减少
    quicklist-&amp;gt;count--;
    /* If we deleted the node, the original node is no longer valid
     * 如果我们删除了该节点，原始节点不再有效
     * */
    return gone ? 1 : 0;
}

REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
                                     quicklistNode *node) {
    /* Update the bookmark if any */
    quicklistBookmark *bm = _quicklistBookmarkFindByNode(quicklist, node);
    if (bm) {
        bm-&amp;gt;node = node-&amp;gt;next;
        /* if the bookmark was to the last node, delete it. */
        if (!bm-&amp;gt;node)
            _quicklistBookmarkDelete(quicklist, bm);
    }

    //如果当前节点存在下一个节点
    if (node-&amp;gt;next)
        //将当前节点的下一个节点的prev 指向当前节点的prev
        node-&amp;gt;next-&amp;gt;prev = node-&amp;gt;prev;
    //如果当前节点存在前置节点
    if (node-&amp;gt;prev)
        //将当前节点上一个节点的next 指向当前节点的next
        node-&amp;gt;prev-&amp;gt;next = node-&amp;gt;next;

    //如果当前节点是快表的末尾节点
    if (node == quicklist-&amp;gt;tail) {
        //更新快表末尾节点为 当前节点的上一个节点
        quicklist-&amp;gt;tail = node-&amp;gt;prev;
    }

    //如果当前节点是快表的头结点
    if (node == quicklist-&amp;gt;head) {
        //更新快表头结点为当前节点的下一个节点
        quicklist-&amp;gt;head = node-&amp;gt;next;
    }

    /* Update len first, so in __quicklistCompress we know exactly len */
    //更新长度
    quicklist-&amp;gt;len--;
    quicklist-&amp;gt;count -= node-&amp;gt;count;

    /* If we deleted a node within our compress depth, we
     * now have compressed nodes needing to be decompressed. */
    __quicklistCompress(quicklist, NULL);

    //释放内存
    zfree(node-&amp;gt;zl);
    zfree(node);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;quicklist 对于元素删除提供了删除单一元素以及删除区间元素 2 种方案。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;对于删除单一元素，可以使用 quicklist 对外的接口 quicklistDelEntry 实现，也可以通过 quicklistPop 将头部或者尾部元素弹出。&lt;br /&gt;
quicklistDelEntry 函数调用底层 quicklistDelIndex 函数，该函数可以删除 quicklistNode 指向的 ziplist 中的某个元素，其中 p 指向 ziplist 中某个entry 的起始位置。&lt;br /&gt;
quicklistPop 可以弹出头部或者尾部元素，具体实现是通过 ziplist 的接口获取元素值，再通过上述的 quicklistDelIndex将数据删除。&lt;/li&gt;
  &lt;li&gt;对于删除区间元素，quicklist 提供了 quicklistDelRange 接口，该函数可以从指定位置删除指定数量的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总体删除逻辑为：不管什么方式删除，最终都会通过 ziplist 来执行元素删除操作。先尝试删除该链表节点所指向的 ziplist 中的元素，如果 ziplist 中的元素已经为空了，就将该链表节点也删除掉。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://pdai.tech/md/db/nosql-redis/db-redis-overview.html&lt;br /&gt;
http://zhangtielei.com/posts/blog-redis-quicklist.html
https://czrzchao.github.io/redisSourceQuicklist
https://fanlv.fun/2019/08/12/reids-source-code-6/
https://juejin.cn/post/7093145133368999943&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="redis" />
      

      

      
        <summary type="html">快表 - quicklist</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Redis Ziplist</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Redis Ziplist" />
      <published>2024-07-30T00:00:00+08:00</published>
      <updated>2024-07-30T00:00:00+08:00</updated>
      <id>http://localhost:4000/redis-ziplist</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;压缩列表---ziplist&quot;&gt;压缩列表 - ziplist&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;ziplist 是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在 O(1) 的时间复杂度下完成 list 两端的 push 和 pop 操作。但是因为每次操作都需要重新分配 ziplist 的内存，所以实际复杂度和 ziplist 的内存使用量相关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;为什么 ZipList 特别省内存&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ziplist 节省内存是相对于普通的 list 来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显需要预留空间）&lt;/li&gt;
  &lt;li&gt;所以 ziplist 在设计时就很容易想到尽量让每个元素按照实际的内容大小存储，所以增加 encoding 字段，针对不同的 encoding 来细化存储大小。&lt;/li&gt;
  &lt;li&gt;这时候还需要解决的一个问题是遍历元素时如何定位下一个元素？在普通数组中每个元素定长，所以不需要考虑这个问题；但是 ziplist 中每个 data 占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的 length，所以增加了 prelen 字段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ziplist 数据结构&lt;/strong&gt;&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/ziplist/ziplist结构图.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;ziplist结构图&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;由如下部分组成：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zlbytes&lt;/code&gt;：uint32_t 类型，表示整个 ziplist 所占用内存的字节数，在执行内存分配时会被使用。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zltail&lt;/code&gt;：uint32_t 类型，即上图到达 zlend 节点的偏移量，通过此偏移量可以快速定位到 zlend 节点。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zllen&lt;/code&gt;：uint16_t 类型，ziplist 中节点的数量。当这个值小于 UINT16_MAX(65535) 时，这个值就是 ziplist 中节点的数量；当这个值等于 UINT16_MAX 时，节点的数量需要遍历整个 ziplist 才能计算得出。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry&lt;/code&gt;：ziplist 所保存的节点，各个节点的长度根据内容而定。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zlend&lt;/code&gt;：uint8_t 类型，255 的二进制值 1111 1111(UINT8_MAX)，用于标记 ziplist 的末端。&lt;/p&gt;

&lt;p&gt;官方描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt; * ZIPLIST OVERALL LAYOUT
 * ======================
 *
 * The general layout of the ziplist is as follows:
 * ziplist的总体布局如下：
 *
 *   4字节     4字节     2字节                                1字节
 * &amp;lt;zlbytes&amp;gt; &amp;lt;zltail&amp;gt; &amp;lt;zllen&amp;gt; &amp;lt;entry&amp;gt; &amp;lt;entry&amp;gt; ... &amp;lt;entry&amp;gt; &amp;lt;zlend&amp;gt;
 *
 * NOTE: all fields are stored in little endian, if not specified otherwise.
 * 注意：如果没有另外指定，所有字段都以小端序存储（高位高存，顺序存放）
 *
 * &amp;lt;uint32_t zlbytes&amp;gt; is an unsigned integer to hold the number of bytes that
 * the ziplist occupies, including the four bytes of the zlbytes field itself.
 * This value needs to be stored to be able to resize the entire structure
 * without the need to traverse it first.
 * &amp;lt;uint32_t zlbytes&amp;gt; 是一个无符号整数来保存 ziplist 占用的字节数，包含 zlbytes 本身的四个字节。
 * 需要存储此值以便在不需要首先遍历它的情况下调整整个结构的大小。
 *
 * &amp;lt;uint32_t zltail&amp;gt; is the offset to the last entry in the list. This allows
 * a pop operation on the far side of the list without the need for full
 * traversal.
 * &amp;lt;uint32_t zltail&amp;gt; 是列表中最后一个entry的偏移量。它使得一个从列表另一边的 pop 操作无需全部遍历，时间复杂度为O(1)。
 *
 * &amp;lt;uint16_t zllen&amp;gt; is the number of entries. When there are more than
 * 2^16-2 entries, this value is set to 2^16-1 and we need to traverse the
 * entire list to know how many items it holds.
 * &amp;lt;uint16_t zllen&amp;gt; 代表 entry 的数量。 当entry的数量大于等于 2^16-2（即253） 时，它的值被设置为 2^16-1(即254)，并且我们需要遍历整个列表获取数量。为什么不是255，因为zlend默认使用255。
 *
 * &amp;lt;uint8_t zlend&amp;gt; is a special entry representing the end of the ziplist.
 * Is encoded as a single byte equal to 255. No other normal entry starts
 * with a byte set to the value of 255.
 * &amp;lt;uint8_t zlend&amp;gt; 是一个特殊的entry代表ziplist的结尾。 被编码为等于255的单个字节。 没有其他正常entry被设置为255.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ziplist-entry 数据结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第一种情况，一般结构为：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;prevlen&amp;gt; &amp;lt;encoding&amp;gt; &amp;lt;entry-data&amp;gt;&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prevlen&lt;/code&gt; : 前一个 entry 的大小，编码方式见下文；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;encoding&lt;/code&gt;：不同的情况下值不同，用于表示当前 entry 的类型和长度；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry-data&lt;/code&gt;：真正用于存储 entry 表示的数据;&lt;/p&gt;

&lt;p&gt;第二种情况，在 entry 中存储的是 int 类型时，encoding 和 entry-data 会合并在 encoding 中表示，此时没有 entry-data 字段；&lt;br /&gt;
redis 中，在存储数据时，会先尝试将 string 转换成 int 存储，节省空间；&lt;br /&gt;
此时 entry 结构：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;prevlen&amp;gt; &amp;lt;encoding&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;prevlen编码&lt;br /&gt;
当前一个元素长度小于 254 （255用于zlend） 的时候，prevlen长度为 1 个字节，值即为前一个 entry 的长度，如果长度大于等于 254 的时候，prevlen 用 5 个字节表示，第一个字节设置为 254 ，后面 4 个字节存储一个小端的无符号整型，表示前一个 entry 的长度：&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;prevlen from 0 to 253&amp;gt; &amp;lt;encoding&amp;gt; &amp;lt;entry&amp;gt;&lt;/code&gt; //长度小于 254 结构&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE &amp;lt;4 bytes unsigned little endian prevlen&amp;gt; &amp;lt;encoding&amp;gt; &amp;lt;entry&amp;gt;&lt;/code&gt;  //长度大于等于 254 结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;encoding编码&lt;br /&gt;
encoding 的长度和值根据保存的是 int 还是 string，还有数据的长度而定；&lt;br /&gt;
前两位用来表示类型，当为 11 时，表示 entry 存储的是 int 类型，其他表示存储的是 string；&lt;br /&gt;
&lt;strong&gt;存储 string 时&lt;/strong&gt;:&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|00pppppp|&lt;/code&gt;：此时 encoding 长度为 1 个字节，该字节的后六位表示 entry 中存储的 string 长度，因为是 6 位，所以entry 中存储的 string 长度不能超过 63；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|01pppppp|qqqqqqqq|&lt;/code&gt;：此时 encoding 长度为 2 个字节；此时 encoding 的后 14 位用来存储 string 长度，长度不能超过 16383(2^14 - 1)；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|&lt;/code&gt;：此时 encoding 长度为 5 个字节，后面的 4 个字节用来表示 encoding 中存储的字符串长度，长度不能超过 2^32 - 1；&lt;br /&gt;
&lt;strong&gt;存储 int 时&lt;/strong&gt;：&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|11000000|&lt;/code&gt;：encoding 为 3 个字节，后 2 个字节表示一个 int16；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|11010000|&lt;/code&gt;：encoding 为 5 个字节，后 4 个字节表示一个 int32；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|11100000|&lt;/code&gt;：encoding 为 9 个字节，后 8 个字节表示一个 int64；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|11110000|&lt;/code&gt;：encoding 为 4 个字节，后 3 个字节表示一个有符号整型；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|11111110|&lt;/code&gt;：encoding 为 2 个字节，后 1 个字节表示一个有符号整型；&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|1111xxxx|&lt;/code&gt;：encoding 长度就只有一个字节，xxxx 在 0001 到 1101 之前，表示无符号整数 0-12。 因为 0000和1111 不能被使用，实际编码值为 1-13，所以应该减去 1 获取正确的值； &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|11111111|&lt;/code&gt;：ziplist 特殊节点结尾；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;官方描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt; * ZIPLIST ENTRIES
 * ===============
 *
 * Every entry in the ziplist is prefixed by metadata that contains two pieces
 * of information. First, the length of the previous entry is stored to be
 * able to traverse the list from back to front. Second, the entry encoding is
 * provided. It represents the entry type, integer or string, and in the case
 * of strings it also represents the length of the string payload.
 * So a complete entry is stored like this:
 * ziplist中的每个节点都以包含两部分信息的元数据作为前缀。
 * 首先 将前一个节点的长度存储为能够从后到前遍历列表。
 * 第二 提供节点的编码，它代表节点的类型，整数或者字符串，在这种情况下的字符串，它也表示字符串有效载荷的长度。
 * 所以一个完整的节点按如下方式存储：
 *
 * &amp;lt;prevlen&amp;gt; &amp;lt;encoding&amp;gt; &amp;lt;entry-data&amp;gt;
 *
 * Sometimes the encoding represents the entry itself, like for small integers
 * as we&apos;ll see later. In such a case the &amp;lt;entry-data&amp;gt; part is missing, and we
 * could have just:
 * 有时编码代表节点自身，像后面看到的短整数。在这种情况下 &amp;lt;entry-data&amp;gt; 部分将消失，类型如下：
 *
 * &amp;lt;prevlen&amp;gt; &amp;lt;encoding&amp;gt;
 *
 * The length of the previous entry, &amp;lt;prevlen&amp;gt;, is encoded in the following way:
 * If this length is smaller than 254 bytes, it will only consume a single
 * byte representing the length as an unsinged 8 bit integer. When the length
 * is greater than or equal to 254, it will consume 5 bytes. The first byte is
 * set to 254 (FE) to indicate a larger value is following. The remaining 4
 * bytes take the length of the previous entry as value.
 * &amp;lt;prevlen&amp;gt; : 上一个节点的长度，按以下方式编码：
 * 如果长度小于254字节，它将消耗 1 字节表示长度为 8bit 的整数。
 * 当长度大于等于254，它将占用 5 字节。第一个字节设置为 254（FE） 表明紧跟着的是较大值。剩下的 4 个字节以前一个节点的长度作为值。
 *
 * So practically an entry is encoded in the following way:
 * 因此 实际上节点是按照以下方式编码的
 *
 * &amp;lt;prevlen from 0 to 253&amp;gt; &amp;lt;encoding&amp;gt; &amp;lt;entry&amp;gt;
 * prevlen = [0, 253]
 *
 * Or alternatively if the previous entry length is greater than 253 bytes
 * the following encoding is used:
 * 或者 如果上一个节点长度大于 253 字节使用下面编码
 *
 * 0xFE &amp;lt;4 bytes unsigned little endian prevlen&amp;gt; &amp;lt;encoding&amp;gt; &amp;lt;entry&amp;gt;
 *
 * The encoding field of the entry depends on the content of the
 * entry. When the entry is a string, the first 2 bits of the encoding first
 * byte will hold the type of encoding used to store the length of the string,
 * followed by the actual length of the string. When the entry is an integer
 * the first 2 bits are both set to 1. The following 2 bits are used to specify
 * what kind of integer will be stored after this header. An overview of the
 * different types and encodings is as follows. The first byte is always enough
 * to determine the kind of entry.
 * 节点的编码字段取决于节点的内容。
 * 当节点是字符串时，编码的第一个字节的前 2 位将保存用于存储字符串的编码类型，然后是字符串的实际长度。
 * 当节点是整数时，前 2 位都设为 1，接下来的 2 位用来指定在这个头之后存储的整数类型。
 * 不同类型和编码的概述如下。第一个字节总是足够确定节点的类型
 *
 * 字符串
 * |00pppppp| - 1 byte
 *      String value with length less than or equal to 63 bytes (6 bits).
 *      &quot;pppppp&quot; represents the unsigned 6 bit length.
 *      长度小于等于 63(2^6-1) 字节的字符串， pppppp 代表无符号 6bit 长度
 * |01pppppp|qqqqqqqq| - 2 bytes
 *      String value with length less than or equal to 16383 bytes (14 bits).
 *      IMPORTANT: The 14 bit number is stored in big endian.
 *      长度小于等于 16383(2^14-1) 字节的字符串
 *      14位数字以大端序存储（高位低存，逆序存放）
 * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
 *      String value with length greater than or equal to 16384 bytes.
 *      Only the 4 bytes following the first byte represents the length
 *      up to 2^32-1. The 6 lower bits of the first byte are not used and
 *      are set to zero.
 *      IMPORTANT: The 32 bit number is stored in big endian.
 *      长度大于等于 16384（2^14） 字节的字符串。
 *      只有第一个字节之后的4个字节表示长度即 2^32-1。首字节的 6 个低bit位未使用且设置为0.
 *      32 bit 位以大端序存储（高位低存，逆序存放）
 *
 * 整数
 * |11000000| - 3 bytes
 *      Integer encoded as int16_t (2 bytes).
 *      整数编码为 int16_t（2字节）
 * |11010000| - 5 bytes
 *      Integer encoded as int32_t (4 bytes).
 *      整数编码为 int32_t（4字节）
 * |11100000| - 9 bytes
 *      Integer encoded as int64_t (8 bytes).
 *      整数编码为 int64_t（8字节）
 * |11110000| - 4 bytes
 *      Integer encoded as 24 bit signed (3 bytes).
 *      整数编码为24位有符号 （3字节）
 * |11111110| - 2 bytes
 *      Integer encoded as 8 bit signed (1 byte).
 *      整数编码为 8bit有符号 （1字节）
 * |1111xxxx| - (with xxxx between 0001 and 1101) immediate 4 bit integer.
 *      Unsigned integer from 0 to 12. The encoded value is actually from
 *      1 to 13 because 0000 and 1111 can not be used, so 1 should be
 *      subtracted from the encoded 4 bit value to obtain the right value.
 *      XXXX 在 0001到1101之间，即4bit 整数。
 *      无符号整数从0到12。编码值实际从1到13，因为0000和1111不能被使用，所以应该从4bit中减去 1 来获取正确的值
 *
 * |11111111| - End of ziplist special entry.
 *      ziplist特殊节点结尾
 *
 * Like for the ziplist header, all the integers are represented in little
 * endian byte order, even when this code is compiled in big endian systems.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;zlentry 数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* We use this function to receive information about a ziplist entry.
 * Note that this is not how the data is actually encoded, is just what we
 * get filled by a function in order to operate more easily.
 * 我们使用这个方法来接收 ziplist 节点的信息。
 * 注意这不是数据的实际编码方式，这只是为了更容易操作而由函数填充的内容
 */
typedef struct zlentry {
    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/
                                 //用于编码前一项 len 的字节，存储上一个元素的长度数值所需要的字节数
    unsigned int prevrawlen;     /* Previous entry len. */
                                 //前一个节点的长度
    unsigned int lensize;        /* Bytes used to encode this entry type/len.
                                    For example strings have a 1, 2 or 5 bytes
                                    header. Integers always use a single byte.*/
                                 //用于编码节点的类型或长度的字节。 例如字符串由 1、2、5字节的头部。 整数通常使用 1 字节
    unsigned int len;            /* Bytes used to represent the actual entry.
                                    For strings this is just the string length
                                    while for integers it is 1, 2, 3, 4, 8 or
                                    0 (for 4 bit immediate) depending on the
                                    number range. */
                                 //用于表示真正节点的字节。 对于字符串来说就是字符串的长度，对于整型来说依赖数字的范围，可能是 1,2,3，4,8 或 0的4bit位
    unsigned int headersize;     /* prevrawlensize + lensize. */
                                 //头部长度 前一个节点 加 当前节点的长度
    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
                                    the entry encoding. However for 4 bits
                                    immediate integers this can assume a range
                                    of values and must be range-checked. */
                                 //依赖节点的类型设置为 ZIP_STR_* or ZIP_INT_*。 然后对于 4bit位整数，可以假设为一个范围的值，必须进行范围检查
    unsigned char *p;            /* Pointer to the very start of the entry, that
                                    is, this points to prev-entry-len field. */
                                 //指向节点最开始的指针，即指向prev-entry-len(前一个节点长度) 字段
} zlentry;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面说到列表元素的结构只有三个属性，分别是:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;previous_entry_length: 前一个元素的字节长度&lt;/li&gt;
  &lt;li&gt;encoding: 当前元素的编码&lt;/li&gt;
  &lt;li&gt;content: 当前元素的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;previous_entry_length 属性记录了前一个元素的字节长度，却有 1 字节还是 5 字节之分，前一个元素的长度也根据字节数的不同，获取方式也不同。
因此我们可以把这个可变属性拆成 2 个属性:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;prevrawlensize: 存储前一个元素的长度所需要的字节数&lt;/li&gt;
  &lt;li&gt;prevrawlen: 前一个元素的长度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;encoding 属性表示当前元素的编码，记录着当前节点存储数据的类型及长度。 encoding 字段存储数据的长度也是采用变长的方式，可以是1、2、5字节，整数恒为 1 字节。&lt;br /&gt;
encoding 值的前两位则能表示当前元素存储数据的类型。当 encoding 为 1111xxxx 时，xxxx还表示值的大小，此时 content 字段内容为空，所以连同 content 字段一起，我们可以把 encoding 属性拆分成三个属性:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;lensize: 存储元素的长度数值所需要的字节数，可以为1、2、5字节，整数恒为 1 字节&lt;/li&gt;
  &lt;li&gt;len: 表示元素的长度&lt;/li&gt;
  &lt;li&gt;encoding: 标识是字节数组还是整数数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么如何获取当前元素的内容呢，Redis是这个做的:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;*p: 定义一个 char 类型指针，该指针指向当前元素的起始位置&lt;/li&gt;
  &lt;li&gt;headersize: headersize 表示当前元素的首部长度，即 prevrawlensize + lensize&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过指针 p 偏移 headersize 即可得到元素内容。&lt;/p&gt;

&lt;p&gt;那么 Redis 是如何对压缩列表进行解码的呢？&lt;br /&gt;
通过 zipEntry 函数进行解码压缩列表元素，并存于 zlentry 结构体。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* Fills a struct with all information about an entry.
 * This function is the &quot;unsafe&quot; alternative to the one blow.
 * Generally, all function that return a pointer to an element in the ziplist
 * will assert that this element is valid, so it can be freely used.
 * Generally functions such ziplistGet assume the input pointer is already
 * validated (since it&apos;s the return value of another function).
 * 用节点的所有信息填充结构体。这个函数是不安全的替代方法。
 * 一般来说，所有返回指向 ziplist 中元素指针的函数都回断言该元素是有效的，因此可以自由使用。
 * 一般来说 像ziplistGet的方法，假设输入的指针已经是有效的（因为它是其他方法返回的指针）
 */
static inline void zipEntry(unsigned char *p, zlentry *e) {
    //根据 prevrawlensize字节数解码 prevrawlen长度
    ZIP_DECODE_PREVLEN(p, e-&amp;gt;prevrawlensize, e-&amp;gt;prevrawlen);
    //根据 prevrawlensize字节数解码 encoding
    ZIP_ENTRY_ENCODING(p + e-&amp;gt;prevrawlensize, e-&amp;gt;encoding);
    //根据 prevrawlensize 和 encoding 解析节点长度及存储长度所需要的字节
    ZIP_DECODE_LENGTH(p + e-&amp;gt;prevrawlensize, e-&amp;gt;encoding, e-&amp;gt;lensize, e-&amp;gt;len);
    assert(e-&amp;gt;lensize != 0); /* check that encoding was valid. */
    //设置节点头部大小 = 上一个节点长度 + 该节点长度
    e-&amp;gt;headersize = e-&amp;gt;prevrawlensize + e-&amp;gt;lensize;
    e-&amp;gt;p = p;
}


/* Return the length of the previous element, and the number of bytes that
 * are used in order to encode the previous element length.
 * &apos;ptr&apos; must point to the prevlen prefix of an entry (that encodes the
 * length of the previous entry in order to navigate the elements backward).
 * The length of the previous entry is stored in &apos;prevlen&apos;, the number of
 * bytes needed to encode the previous entry length are stored in
 * &apos;prevlensize&apos;.
 * 返回上一个元素的长度 和 用于编码上一个元素长度所需的字节数量。
 * &apos;ptr&apos;必须指向节点的 prevlen 前缀（它对前一个节点长度进行编码以便向后导航元素）
 * 上一个节点的长度保存在 prevlen 中，编码前一个节点长度所需的字节数保存在 prevlensize 中
 */
#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
    /*解码 prevlensize 所占的字节数 要么为1字节要么为5字节，获取上一个节点真正的长度*/                                                                           \
    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
    /*若prevlensize为1，则ptr的第一个字节即为上一个节点的长度*/                                                                           \
    if ((prevlensize) == 1) {                                                  \
        (prevlen) = (ptr)[0];                                                  \
    } else { /* prevlensize == 5 若字节长度等于5，则取后面4个字节即32位作为上一个节点的长度 */            \
        /* 读取连续的4个字节（即32位），并将这4个字节的数据组合成一个整数len。
         * 这里的组合方式是按照小端字节序（little-endian）进行的，即最高有效字节（MSB）存放在最高的内存地址，最低有效字节（LSB）存放在最低的内存地址。
         * (ptr)[1]是第一个字节，它不会被移动，成为prevlen的最低8位
         * (pre)[2]是第二个字节，它会被左移8位，成为整数prevlen的次低8位
         * (pre)[3]是第三个字节，它会被左移16位，成为整数的prevlen的次高8位
         * (pre)[4]是第四个字节，它会被左移24位，成为整数的prevlen的最高8为
         * */                                                                       \
        (prevlen) = ((ptr)[4] &amp;lt;&amp;lt; 24) |                                         \
                    ((ptr)[3] &amp;lt;&amp;lt; 16) |                                         \
                    ((ptr)[2] &amp;lt;&amp;lt;  8) |                                         \
                    ((ptr)[1]);                                                \
    }                                                                          \
} while(0)

/* Return the number of bytes used to encode the length of the previous
 * entry. The length is returned by setting the var &apos;prevlensize&apos;.
 * 返回用于编码上一个节点长度的字节数。 通过设置变量 prevlensize 来返回长度
 */
#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    /*若指针的第一个元素小于ZIP_BIG_PREVLEN 代表 prevlensize 为 1字节，否则为 5 字节*/  \
    if ((ptr)[0] &amp;lt; ZIP_BIG_PREVLEN) {                                          \
        (prevlensize) = 1;                                                     \
    } else {                                                                   \
        (prevlensize) = 5;                                                     \
    }                                                                          \
} while(0)


/* Extract the encoding from the byte pointed by &apos;ptr&apos; and set it into
 * &apos;encoding&apos; field of the zlentry structure.
 * 从 ptr 所指向的字节中提取编码，并且将它设置到 zlentry 结构中的 encoding 字段
 * */
#define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
    (encoding) = ((ptr)[0]);                    \
    /* 若 encoding 小于ZIP_STR_MASK（字符串标志位），与ZIP_STR_MASK进行与运算获取 int类型编码 */                                            \
    if ((encoding) &amp;lt; ZIP_STR_MASK) (encoding) &amp;amp;= ZIP_STR_MASK; \
} while(0)


/* Decode the entry encoding type and data length (string length for strings,
 * number of bytes used for the integer for integer entries) encoded in &apos;ptr&apos;.
 * The &apos;encoding&apos; variable is input, extracted by the caller, the &apos;lensize&apos;
 * variable will hold the number of bytes required to encode the entry
 * length, and the &apos;len&apos; variable will hold the entry length.
 * On invalid encoding error, lensize is set to 0.
 * 解码节点中的编码类型和数据长度（对于字符串的字符串长度，对于整数项的整数所使用的字节数）。
 * encoding变量是输入，由调用者提取。变量 lensize 保留编码节点长度所需的字节。 变量 len 将保留节点的长度。
 * 在编码异常场景下，lensize将设置为0
 * */
#define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
    /*判断编码属于字节数组还是整数类型*/                                                                           \
    if ((encoding) &amp;lt; ZIP_STR_MASK) {                                           \
        /*如果存储长度等于 ZIP_STR_06B（00000000）*/                                                                       \
        if ((encoding) == ZIP_STR_06B) {                                       \
            /*需要 1 字节存储字符串长度*/                                                                   \
            (lensize) = 1;                                                     \
            /* 元素长度为 (ptr)[0] 和 111111 做与运算获取实际长度 */                                                                   \
            (len) = (ptr)[0] &amp;amp; 0x3f;                                           \
        } else if ((encoding) == ZIP_STR_14B) {/*如果存储长度等于 ZIP_STR_14B(0100 0000) */                                \
            (lensize) = 2;                                                     \
            (len) = (((ptr)[0] &amp;amp; 0x3f) &amp;lt;&amp;lt; 8) | (ptr)[1];                       \
        } else if ((encoding) == ZIP_STR_32B) {                                \
            (lensize) = 5;                                                     \
             /* 读取连续的4个字节（即32位），并将这4个字节的数据组合成一个整数len。
              * 这里的组合方式是按照大端字节序（big-endian）进行的，即最高有效字节（MSB）存放在最低的内存地址，最低有效字节（LSB）存放在最高的内存地址。
              * (ptr)[1]是第一个字节，它会被左移24位，成为整数的prevlen的最高8为
              * (pre)[2]是第二个字节，它会被左移16位，成为整数的prevlen的次高8位
              * (pre)[3]是第三个字节，它会被左移8位，成为整数prevlen的次低8位
              * (pre)[4]是第四个字节，它不会被移动，成为prevlen的最低8位
              * */                                                                       \
            (len) = ((uint32_t)(ptr)[1] &amp;lt;&amp;lt; 24) |                               \
                    ((uint32_t)(ptr)[2] &amp;lt;&amp;lt; 16) |                               \
                    ((uint32_t)(ptr)[3] &amp;lt;&amp;lt;  8) |                               \
                    ((uint32_t)(ptr)[4]);                                      \
        } else {                                                               \
            (lensize) = 0; /* bad encoding, should be covered by a previous */ \
            (len) = 0;     /* ZIP_ASSERT_ENCODING / zipEncodingLenSize, or  */ \
                           /* match the lensize after this macro with 0.
                            * 异常场景，赋值0*/ \
        }                                                                      \
    } else {                                                                   \
        /*判断编码属于整数类型*/                                                                           \
        (lensize) = 1;                                                         \
        if ((encoding) == ZIP_INT_8B)  (len) = 1;  /* 若encoding = ZIP_INT_8B 长度为1字节，即可以用 8bit 位数据表示 */                            \
        else if ((encoding) == ZIP_INT_16B) (len) = 2;  /* 若encoding = ZIP_INT_16B 长度为2字节，即可以用 16bit 位数据表示 */                         \
        else if ((encoding) == ZIP_INT_24B) (len) = 3;  /* 若encoding = ZIP_INT_24B 长度为3字节，即可以用 24bit 位数据表示 */                         \
        else if ((encoding) == ZIP_INT_32B) (len) = 4;  /* 若encoding = ZIP_INT_32B 长度为4字节，即可以用 32bit 位数据表示 */                         \
        else if ((encoding) == ZIP_INT_64B) (len) = 8;  /* 若encoding = ZIP_INT_64B 长度为8字节，即可以用 64bit 位数据表示 */                         \
        else if (encoding &amp;gt;= ZIP_INT_IMM_MIN &amp;amp;&amp;amp; encoding &amp;lt;= ZIP_INT_IMM_MAX)  /* 异常情况 长度设置为0 */ \
            (len) = 0; /* 4 bit immediate */                                   \
        else                                                                   \
            (lensize) = (len) = 0; /* bad encoding */                          \
    }                                                                          \
} while(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到解码主要分为三个步骤:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;解码 previous_entry_length 字段，此时入参 ptr 指向元素首地址&lt;/li&gt;
  &lt;li&gt;解码 encoding 字段，此时入参 ptr 指向元素首地址偏移 previous_entry_length 字段长度的位置&lt;/li&gt;
  &lt;li&gt;解码 len 字段，根据 encoding 分别解析计算节点长度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;创建压缩列表&lt;/strong&gt;&lt;br /&gt;
源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* Create a new empty ziplist. */
//创建压缩列表
unsigned char *ziplistNew(void) {
    //初始化默认字节大小=11字节  即 zlbytes(4字节) + zltail(4字节) + zlen(2字节) + zlend(1字节)
    unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
    //分配内存11字节大小
    unsigned char *zl = zmalloc(bytes);
    //初始化 zlbytes 字段
    //intrev32ifbe 意思为 int32 reversal if big endian，即如果当前主机字节序为大端序，那么将它的内存存储进行翻转操作。  见https://blog.csdn.net/WhereIsHeroFrom/article/details/84643017
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
    //初始化 zltail 字段
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
    //长度设置为0
    ZIPLIST_LENGTH(zl) = 0;
    //初始化结束标志位
    zl[bytes-1] = ZIP_END;
    return zl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建压缩列表的代码很简单，函数无输入参数，只需要分配初始化存储空间 11（4+4+2+1）个，并对 zlytes、zltail、zllen 和 zlend 字段初始化值，最后返回压缩列表的首地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;插入元素&lt;/strong&gt;&lt;br /&gt;
源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;
/* Insert item at &quot;p&quot;.
 * 向指针 p 中插入元素
 * zl:压缩列表字节大小
 * p:压缩列表指针
 * s: 待插入的节点
 * slen: 待插入的节点长度
 * */
unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    //curlen 表示插入元素前压缩列表的长度
    //reqlen表示新插入元素的长度
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, newlen;
    //prevlensize 表示前一个字节的长度
    //prevlen 表示存储前一个字节需要的字节数
    unsigned int prevlensize, prevlen = 0;
    size_t offset;
    //nextdiff 表示插入元素后一个元素长度的变化，取值可能是0（长度不变），4（长度增加4）或-4（长度减少4）
    int nextdiff = 0;
    //encoding 用于存储当前元素编码
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized.
                                    初始化以避免警告。使用该值可以很简单的看出未初始化
                                    */
    zlentry tail;

    /* Find out prevlen for the entry that is inserted.
     * 计算已插入节点的 prevlen
     * */
    //找出待插入节点的前置节点长度，有三种场景
    if (p[0] != ZIP_END) {
        //若非结尾标识，直接计算上一个节点的长度
        //1.如果p[0] 不指向列表末尾，说明列表非空，并且 p 指向其中一个节点，所以新插入节点的前置节点长度可以通过节点 p 指向的节点信息中获取
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); //通过 ZIP_DECODE_PREVLEN 方法获取 prevlen 长度
    } else {
        //获取尾节点位置，用来判断当前压缩列表是否为空列表
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        //若末尾节点非结束标识
        //2. 如果尾节点指针不指向压缩列表末尾，说明当前压缩列表不为空，那么新插入节点的前置节点长度就是尾节点的长度
        if (ptail[0] != ZIP_END) {
            //获取尾节点的总长度 头部大小+总长度
            prevlen = zipRawEntryLengthSafe(zl, curlen, ptail);
        }
        //3. 第三种情况就是 p 指向压缩列表末尾，但是压缩列表中节点为空，所以 p 的前置节点长度为 0 ，故不做处理
    }

    /* See if the entry can be encoded
     * 尝试将节点从String转为int，计算当前节点的长度
     * */
    //s指针指向新增节点数据  slen为数据长度
    //确定数据编码，为整数时返回对应固定长度，为字符串时使用slen
    if (zipTryEncoding(s,slen,&amp;amp;value,&amp;amp;encoding)) {
        /* &apos;encoding&apos; is set to the appropriate integer encoding
         * encoding 已经设置为最合适的整数编码，并获取编码长度
         * */
        reqlen = zipIntSize(encoding);
    } else {
        /* &apos;encoding&apos; is untouched, however zipStoreEntryEncoding will use the
         * string length to figure out how to encode it.
         * encoding 未受影响，但是 zipStoreEntryEncoding 将使用字符串长度来决定如何编码
         * */
        reqlen = slen;
    }

    /* We need space for both the length of the previous entry and
     * the length of the payload.
     * 我们需要为前一个节点的长度和有效负载的长度分配空间 即更新当前节点场景
     * */
    //编码前置节点长度所需字节数
    reqlen += zipStorePrevEntryLength(NULL,prevlen);
    //编码当前字符串长度所需字节数
    //此时 reqlen 为新加入节点的整体长度
    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

    /* When the insert position is not equal to the tail, we need to
     * make sure that the next entry can hold this entry&apos;s length in
     * its prevlen field.
     * 当插入的位置不在尾部时，我们需要保证下一个节点可以在 prevlen 字段中保存当前节点的长度
     * */
    int forcelarge = 0; //在nextdiff==-4 &amp;amp;&amp;amp; reqlen&amp;lt;4 时使用，该条件说明，插入元素导致压缩列表变小了，即函数 ziplistResize内部调用 realloc 重新分配空间小于 zl 指向的空间，此时 realloc 会将多余空间回收，导致数据丢失（丢失了尾部），所以为了避免这种情况，我们使用forcelarge来标记这种情况，并将 nextdiff 置为0，详情见https://segmentfault.com/a/1190000018878466?utm_source=tag-newest
    //计算原来 p 位置上的节点将要保存的 prevlen（当前待插入节点的大小） 是否变化
    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
    //连锁更新的时候会出现问题
    if (nextdiff == -4 &amp;amp;&amp;amp; reqlen &amp;lt; 4) {
        nextdiff = 0; //将nextdiff 设置为0，此时内存重分配不会出现回收空间的情况，造成数据丢失
        forcelarge = 1;
    }

    /* Store offset because a realloc may change the address of zl.
     * 重新分配内存肯呢个会改变 zl 的地址，所以存储偏移
     * */
    offset = p-zl; //偏移量，用来表示 p 相对于压缩列表首地址的偏移量，由于重新分配了空间，新元素插入的位置指针 p 会时效，可以预先计算好指针 p 对于压缩列表首地址的偏移量，待空间分配之后再便宜
    //最新空间大小   当前压缩列表大小 + 插入元素大小 + 差值长度
    newlen = curlen+reqlen+nextdiff;
    //重新分配压缩列表大小
    zl = ziplistResize(zl,newlen);
    //根据偏移找到新插入元素 P 的位置
    p = zl+offset;

    /* Apply memory move when necessary and update tail offset.
     * 必要时应用内存移动并更新尾偏移量
     * */
    //非空列表插入
    if (p[0] != ZIP_END) {
        /* Subtract one because of the ZIP_END bytes
         * 因为是 ZIP_END 字节，所以减去1
         * */
        //将 p 节点后移（没有移动 p 节点前一节点长度信息），留出当前节点位置
        //p+reqlen: 偏移量是这个，就是将原来的数据移动到新插入节点之后
        //curlen-offset-1+nextdiff: 移动的长度，就是位置 P 之后的所有元素的长度 -1（结束符大小恒为 0XFF，不需要移动），再加上 nextdiff（下一个元素长度的变化）
        //p-nextdiff: 表示从哪个位置需要复制移动，因为下一个元素长度会发生变化，所以需要提前预留出这部分空间，就多复制一块空间，到时候覆盖即可
        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);

        /* Encode this entry&apos;s raw length in the next entry.
         * 在下一个节点中编码节点原始长度 并且判断是否需要加大上一个节点长度
         * */
        //写入 p 节点以前一个节点长度信息（要插入节点的长度）
        if (forcelarge)
            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
        else
            zipStorePrevEntryLength(p+reqlen,reqlen);

        /* Update offset for tail
         * 更新末尾节点的偏移
         * */
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);

        /* When the tail contains more than one entry, we need to take
         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the
         * size of prevlen doesn&apos;t have an effect on the *tail* offset.
         * 当尾部包含多个节点时，还需要考虑 nextdiff，否则，prevlen大小的变化不会对尾部偏移量产生影响
         * */
        assert(zipEntrySafe(zl, newlen, p+reqlen, &amp;amp;tail, 1));
        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
        }
    } else {
        /* This element will be the new tail.
         * 如果在末尾 则该节点将变成新的末尾节点
         * */
        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);
    }

    /* When nextdiff != 0, the raw length of the next entry has changed, so
     * we need to cascade the update throughout the ziplist
     * 当 nextdiff 不为0，下一个节点的原始长度已经改变，所以需要级联更新
     * */
    if (nextdiff != 0) {
        //计算偏移
        offset = p-zl;
        //级联更新压缩链表
        zl = __ziplistCascadeUpdate(zl,p+reqlen);
        //更新后添加偏移
        p = zl+offset;
    }

    /* Write the entry
     * 写节点信息
     * */
    //写入前一节点长度信息
    p += zipStorePrevEntryLength(p,prevlen);
    //写入节点编码与长度信息
    p += zipStoreEntryEncoding(p,encoding,slen);
    //如果是字符串则分配内存
    if (ZIP_IS_STR(encoding)) {
        memcpy(p,s,slen);
    } else {
        //是整数则添加整数值
        zipSaveInteger(p,value,encoding);
    }
    //压缩列表长度加1
    ZIPLIST_INCR_LENGTH(zl,1);
    return zl;
}


/* Return the length of the previous element, and the number of bytes that
 * are used in order to encode the previous element length.
 * &apos;ptr&apos; must point to the prevlen prefix of an entry (that encodes the
 * length of the previous entry in order to navigate the elements backward).
 * The length of the previous entry is stored in &apos;prevlen&apos;, the number of
 * bytes needed to encode the previous entry length are stored in
 * &apos;prevlensize&apos;.
 * 返回上一个元素的长度 和 用于编码上一个元素长度所需的字节数量。
 * &apos;ptr&apos;必须指向节点的 prevlen 前缀（它对前一个节点长度进行编码以便向后导航元素）
 * 上一个节点的长度保存在 prevlen 中，编码前一个节点长度所需的字节数保存在 prevlensize 中
 */
#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
    /*解码 prevlensize 所占的字节数 要么为1字节要么为5字节，获取上一个节点真正的长度*/                                                                           \
    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
    /*若prevlensize为1，则ptr的第一个字节即为上一个节点的长度*/                                                                           \
    if ((prevlensize) == 1) {                                                  \
        (prevlen) = (ptr)[0];                                                  \
    } else { /* prevlensize == 5 若字节长度等于5，则取后面4个字节即32位作为上一个节点的长度 */            \
        /* 读取连续的4个字节（即32位），并将这4个字节的数据组合成一个整数len。
         * 这里的组合方式是按照小端字节序（little-endian）进行的，即最高有效字节（MSB）存放在最高的内存地址，最低有效字节（LSB）存放在最低的内存地址。
         * (ptr)[1]是第一个字节，它不会被移动，成为prevlen的最低8位
         * (pre)[2]是第二个字节，它会被左移8位，成为整数prevlen的次低8位
         * (pre)[3]是第三个字节，它会被左移16位，成为整数的prevlen的次高8位
         * (pre)[4]是第四个字节，它会被左移24位，成为整数的prevlen的最高8为
         * */                                                                       \
        (prevlen) = ((ptr)[4] &amp;lt;&amp;lt; 24) |                                         \
                    ((ptr)[3] &amp;lt;&amp;lt; 16) |                                         \
                    ((ptr)[2] &amp;lt;&amp;lt;  8) |                                         \
                    ((ptr)[1]);                                                \
    }                                                                          \
} while(0)


/* Return the total number of bytes used by the entry pointed to by &apos;p&apos;.
 * 返回 p 所指向的节点所使用的总字节数
 * */
static inline unsigned int zipRawEntryLengthSafe(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &amp;amp;e, 0));
    return e.headersize + e.len;
}


/* Check if string pointed to by &apos;entry&apos; can be encoded as an integer.
 * Stores the integer value in &apos;v&apos; and its encoding in &apos;encoding&apos;.
 * 检查 entry 所指向的字符串是否可以被编码为整数。
 * 将整数值存储在 v 中，它的编码存储在 encoding 字段中
 * */
int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {
    long long value;

    if (entrylen &amp;gt;= 32 || entrylen == 0) return 0;
    if (string2ll((char*)entry,entrylen,&amp;amp;value)) {
        /* Great, the string can be encoded. Check what&apos;s the smallest
         * of our encoding types that can hold this value. */
        if (value &amp;gt;= 0 &amp;amp;&amp;amp; value &amp;lt;= 12) {
            *encoding = ZIP_INT_IMM_MIN+value;
        } else if (value &amp;gt;= INT8_MIN &amp;amp;&amp;amp; value &amp;lt;= INT8_MAX) {
            *encoding = ZIP_INT_8B;
        } else if (value &amp;gt;= INT16_MIN &amp;amp;&amp;amp; value &amp;lt;= INT16_MAX) {
            *encoding = ZIP_INT_16B;
        } else if (value &amp;gt;= INT24_MIN &amp;amp;&amp;amp; value &amp;lt;= INT24_MAX) {
            *encoding = ZIP_INT_24B;
        } else if (value &amp;gt;= INT32_MIN &amp;amp;&amp;amp; value &amp;lt;= INT32_MAX) {
            *encoding = ZIP_INT_32B;
        } else {
            *encoding = ZIP_INT_64B;
        }
        *v = value;
        return 1;
    }
    return 0;
}


/* Return bytes needed to store integer encoded by &apos;encoding&apos;
 * 返回存储由 encoding 编码的整数所需的字节数
 * */
static inline unsigned int zipIntSize(unsigned char encoding) {
    switch(encoding) {
    case ZIP_INT_8B:  return 1;
    case ZIP_INT_16B: return 2;
    case ZIP_INT_24B: return 3;
    case ZIP_INT_32B: return 4;
    case ZIP_INT_64B: return 8;
    }
    if (encoding &amp;gt;= ZIP_INT_IMM_MIN &amp;amp;&amp;amp; encoding &amp;lt;= ZIP_INT_IMM_MAX)
        return 0; /* 4 bit immediate */
    /* bad encoding, covered by a previous call to ZIP_ASSERT_ENCODING */
    redis_unreachable();
    return 0;
}


/* Encode the length of the previous entry and write it to &quot;p&quot;. Return the
 * number of bytes needed to encode this length if &quot;p&quot; is NULL.
 * 编码上一个节点的长度且将它写入到 p 节点中。
 * 如果节点 p 为null，返回编码该长度需要的字节数
 * */
unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
    //如果节点 p 为空，返回当前 len 对应的编码即可
    if (p == NULL) {
        //如果 len 小于254返回1字节，否则返回 4字节 + 1字节
        return (len &amp;lt; ZIP_BIG_PREVLEN) ? 1 : sizeof(uint32_t) + 1;
    } else {
        //若节点 p 不为空
        //当前长度小于 254 更新节点 p 长度并返回 1字节
        if (len &amp;lt; ZIP_BIG_PREVLEN) {
            p[0] = len;
            return 1;
        } else {
            //返回上一个节点的更大字节 用于更新场景
            return zipStorePrevEntryLengthLarge(p,len);
        }
    }
}


/* Encode the length of the previous entry and write it to &quot;p&quot;. This only
 * uses the larger encoding (required in __ziplistCascadeUpdate).
 * 对前一项的长度进行编码，并将其写入 p 。这只用于更大的编码 用于 __ziplistCascadeUpdate 方法
 * */
int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
    uint32_t u32;
    //若p 不为null，更新长度编码即长度
    if (p != NULL) {
        p[0] = ZIP_BIG_PREVLEN;
        u32 = len;
        memcpy(p+1,&amp;amp;u32,sizeof(u32));
        memrev32ifbe(p+1);
    }
    //返回 1 + 4 字节
    return 1 + sizeof(uint32_t);
}


/* Write the encoding header of the entry in &apos;p&apos;. If p is NULL it just returns
 * the amount of bytes required to encode such a length. Arguments:
 * 将节点的编码头部写入到 p 中，如果 p 为null则返回编码头部需要的长度
 *
 * &apos;encoding&apos; is the encoding we are using for the entry. It could be
 * ZIP_INT_* or ZIP_STR_* or between ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX
 * for single-byte small immediate integers.
 * encoding 是我们为节点使用的编码。它可以是 ZIP_INT_* or ZIP_STR_* 或 大小在 ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX 表示单字节小的直接整数。
 *
 * &apos;rawlen&apos; is only used for ZIP_STR_* encodings and is the length of the
 * string that this entry represents.
 * rawlen 只用于 ZIP_STR_* 编码且该节点所代表的字符串长度
 *
 * The function returns the number of bytes used by the encoding/length
 * header stored in &apos;p&apos;.
 * 该方法返回  存储在 p 中用于 encoding/length 头部的字节大小
 * */
unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
    unsigned char len = 1, buf[5];

    //判断是否字符串 并更新 编码字段
    if (ZIP_IS_STR(encoding)) {
        /* Although encoding is given it may not be set for strings,
         * so we determine it here using the raw length. */
        if (rawlen &amp;lt;= 0x3f) {
            if (!p) return len;
            buf[0] = ZIP_STR_06B | rawlen;
        } else if (rawlen &amp;lt;= 0x3fff) {
            len += 1;
            if (!p) return len;
            buf[0] = ZIP_STR_14B | ((rawlen &amp;gt;&amp;gt; 8) &amp;amp; 0x3f);
            buf[1] = rawlen &amp;amp; 0xff;
        } else {
            len += 4;
            if (!p) return len;
            buf[0] = ZIP_STR_32B;
            buf[1] = (rawlen &amp;gt;&amp;gt; 24) &amp;amp; 0xff;
            buf[2] = (rawlen &amp;gt;&amp;gt; 16) &amp;amp; 0xff;
            buf[3] = (rawlen &amp;gt;&amp;gt; 8) &amp;amp; 0xff;
            buf[4] = rawlen &amp;amp; 0xff;
        }
    } else {
        /* Implies integer encoding, so length is always 1.
         * 暗示整数编码，长度总为1
         * */
        if (!p) return len;
        buf[0] = encoding;
    }

    /* Store this length at p.
     * 将长度保存在 p 中
     * */
    memcpy(p,buf,len);
    return len;
}


/* Given a pointer &apos;p&apos; to the prevlen info that prefixes an entry, this
 * function returns the difference in number of bytes needed to encode
 * the prevlen if the previous entry changes of size.
 * 给定一个指针 p ，指向一个节点的 prevlen 信息，如果前一个节点的大小改变了，该方法则返回 编码 prevlen长度的差值
 *
 * So if A is the number of bytes used right now to encode the &apos;prevlen&apos;
 * field.
 * 如果 A 是当前 prevlen字段编码的字节大小
 *
 * And B is the number of bytes that are needed in order to encode the
 * &apos;prevlen&apos; if the previous element will be updated to one of size &apos;len&apos;.
 * 如果前一个节点将被更新为大小为 len 的元素， 则B 是编码 prevlen 所需的字节数
 *
 * Then the function returns B - A
 * 该方法返回 b-a
 *
 * So the function returns a positive number if more space is needed,
 * a negative number if less space is needed, or zero if the same space
 * is needed.
 * 如果该方法返回正数代表需要更多的空间，返回负数代表需要更少的空间，或 0 代表无需改动
 * */
int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
    unsigned int prevlensize;
    //当前节点的 prevlen 字节大小 A
    ZIP_DECODE_PREVLENSIZE(p, prevlensize);
    //最新节点长度的 prevlen 字节大小 B
    return zipStorePrevEntryLength(NULL, len) - prevlensize;
}


/* Return the number of bytes used to encode the length of the previous
 * entry. The length is returned by setting the var &apos;prevlensize&apos;.
 * 返回用于编码上一个节点长度的字节数。 通过设置变量 prevlensize 来返回长度
 */
#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    /*若指针的第一个元素小于ZIP_BIG_PREVLEN 代表 prevlensize 为 1字节，否则为 5 字节*/  \
    if ((ptr)[0] &amp;lt; ZIP_BIG_PREVLEN) {                                          \
        (prevlensize) = 1;                                                     \
    } else {                                                                   \
        (prevlensize) = 5;                                                     \
    }                                                                          \
} while(0)


/* Resize the ziplist.
 * 重新调整压缩列表的大小
 * */
unsigned char *ziplistResize(unsigned char *zl, size_t len) {
    assert(len &amp;lt; UINT32_MAX);
    zl = zrealloc(zl,len);
    ZIPLIST_BYTES(zl) = intrev32ifbe(len);
    zl[len-1] = ZIP_END;
    return zl;
}


/* Encode the length of the previous entry and write it to &quot;p&quot;. Return the
 * number of bytes needed to encode this length if &quot;p&quot; is NULL.
 * 编码上一个节点的长度且将它写入到 p 节点中。
 * 如果节点 p 为null，返回编码该长度需要的字节数
 * */
unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
    //如果节点 p 为空，返回当前 len 对应的编码即可
    if (p == NULL) {
        //如果 len 小于254返回1字节，否则返回 4字节 + 1字节
        return (len &amp;lt; ZIP_BIG_PREVLEN) ? 1 : sizeof(uint32_t) + 1;
    } else {
        //若节点 p 不为空
        //当前长度小于 254 更新节点 p 长度并返回 1字节
        if (len &amp;lt; ZIP_BIG_PREVLEN) {
            p[0] = len;
            return 1;
        } else {
            //返回上一个节点的更大字节 用于更新场景
            return zipStorePrevEntryLengthLarge(p,len);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入元素可以简要分为 3 个步骤:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;将元素内容编码&lt;/li&gt;
  &lt;li&gt;重新分配内存空间&lt;/li&gt;
  &lt;li&gt;复制数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面详细介绍每个步骤的实现:&lt;br /&gt;
&lt;strong&gt;编码&lt;/strong&gt;&lt;br /&gt;
编码即计算 previous_entry_length 字段， encoding 字段和 content 字段的内容。那么如何获取前一个元素的长度呢？此时就需要根据元素的插入位置分情况讨论了。插入元素的位置如下图所示:&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/ziplist/插入元素位置示意.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;插入元素位置示意&lt;/div&gt;
&lt;/center&gt;

&lt;ol&gt;
  &lt;li&gt;当插入列表为空、插入位置为 P0 时，不存在前一个元素，即前一个元素的长度为0；&lt;/li&gt;
  &lt;li&gt;当插入位置为 P1 时，需要获取 entryX 元素的长度，而 entryX+1 元素的 previous_len 字段存储的就是 entryX 元素的长度，比较容易获取&lt;/li&gt;
  &lt;li&gt;当插入位置为 P2 时，需要获取 entryN 元素的长度，entryN 是压缩列表的尾元素，计算元素长度时需要将其 3 个字段长度相加&lt;br /&gt;
找出元素插入位置代码如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* Find out prevlen for the entry that is inserted.
 * 计算已插入节点的 prevlen
 * */
//找出待插入节点的前置节点长度，有三种场景
if (p[0] != ZIP_END) {
    //若非结尾标识，直接计算上一个节点的长度
    //1.如果p[0] 不指向列表末尾，说明列表非空，并且 p 指向其中一个节点，所以新插入节点的前置节点长度可以通过节点 p 指向的节点信息中获取
    ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); //通过 ZIP_DECODE_PREVLEN 方法获取 prevlen 长度
} else {
    //获取尾节点位置，用来判断当前压缩列表是否为空列表
    unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
    //若末尾节点非结束标识
    //2. 如果尾节点指针不指向压缩列表末尾，说明当前压缩列表不为空，那么新插入节点的前置节点长度就是尾节点的长度
    if (ptail[0] != ZIP_END) {
        //获取尾节点的总长度 头部大小+总长度
        prevlen = zipRawEntryLengthSafe(zl, curlen, ptail);
    }
    //3. 第三种情况就是 p 指向压缩列表末尾，但是压缩列表中节点为空，所以 p 的前置节点长度为 0 ，故不做处理
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当插入位置为压缩列表末尾且压缩列表不为空时，计算前一个元素长度代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* Return the total number of bytes used by the entry pointed to by &apos;p&apos;.
 * 返回 p 所指向的节点所使用的总字节数
 * */
static inline unsigned int zipRawEntryLengthSafe(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &amp;amp;e, 0));
    return e.headersize + e.len;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;encoding 字段标识的是当前元素存储的数据类型和数据长度。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;编码时首先尝试将数据内容解析为整数，如果解析成功，则按照压缩列表整数类型编码存储&lt;/li&gt;
  &lt;li&gt;如果解析失败，则按照压缩列表字节数类型编码存储&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* See if the entry can be encoded
 * 尝试将节点从String转为int，计算当前节点的长度
 * */
//s指针指向新增节点数据  slen为数据长度
//确定数据编码，为整数时返回对应固定长度，为字符串时使用slen
if (zipTryEncoding(s,slen,&amp;amp;value,&amp;amp;encoding)) {
    /* &apos;encoding&apos; is set to the appropriate integer encoding
     * encoding 已经设置为最合适的整数编码，并获取编码长度
     * */
    reqlen = zipIntSize(encoding);
} else {
    /* &apos;encoding&apos; is untouched, however zipStoreEntryEncoding will use the
     * string length to figure out how to encode it.
     * encoding 未受影响，但是 zipStoreEntryEncoding 将使用字符串长度来决定如何编码
     * */
    reqlen = slen;
}

/* We need space for both the length of the previous entry and
 * the length of the payload.
 * 我们需要为前一个节点的长度和有效负载的长度分配空间 即更新当前节点场景
 * */
//编码前置节点长度所需字节数
reqlen += zipStorePrevEntryLength(NULL,prevlen);
//编码当前字符串长度所需字节数
//此时 reqlen 为新加入节点的整体长度
reqlen += zipStoreEntryEncoding(NULL,encoding,slen);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码尝试按照整数解析新添加元素的数据内容，数值存储在变量的 value 中，编码存储在变量 encoding 中。如果解析成功，还需要计算整数整数所占字节数。
变量 reqlen 最终存储的是当前元素所需空间大小，初始赋值为元素 content 字段所需空间的大小，再累加 previous_entry_length 和 encoding 字段所需空间大小&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重新分配空间&lt;/strong&gt;&lt;br /&gt;
由于新插入了元素，压缩列表所需空间增大，因此需要重新分配存储空间。那么空间大小是不是添加元素前的压缩列表长度与新添加元素长度之和呢？并不完全是，因为 previous_entry_length 字段长度是根据前一个字段长度变化的。&lt;/p&gt;

&lt;p&gt;我们假设插入元素前， entryX 元素的长度为 128 字节， entryX+1 元素的 previous_entry_length 字段占 1 字节；
添加元素 entryNew，元素长度为 1024 字节，此时 entryX+1 元素的 previous_entry_length 字段需要占 5 个字节，即压缩列表的长度不仅增加了 1024 字节，还要加上 entryX+1 元素扩展的 4 个字节。而 entryX+1 元素的长度可能增加 4 个字节、减少 4 个字节或者不变。&lt;br /&gt;
压缩列表长度变化如下图所示：&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/ziplist/压缩列表长度变化示意.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;压缩列表长度变化示意&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;由于重新分配了空间，新元素插入的位置指针 P 会失效，可以预先计算好指针 P 相对于压缩列表首地址的偏移量，待分配空间之后再偏移即可。&lt;br /&gt;
代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* We need space for both the length of the previous entry and
 * the length of the payload.
 * 我们需要为前一个节点的长度和有效负载的长度分配空间 即更新当前节点场景
 * */
//编码前置节点长度所需字节数
reqlen += zipStorePrevEntryLength(NULL,prevlen);
//编码当前字符串长度所需字节数
//此时 reqlen 为新加入节点的整体长度
reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

/* When the insert position is not equal to the tail, we need to
 * make sure that the next entry can hold this entry&apos;s length in
 * its prevlen field.
 * 当插入的位置不在尾部时，我们需要保证下一个节点可以在 prevlen 字段中保存当前节点的长度
 * */
int forcelarge = 0; //在nextdiff==-4 &amp;amp;&amp;amp; reqlen&amp;lt;4 时使用，该条件说明，插入元素导致压缩列表变小了，即函数 ziplistResize内部调用 realloc 重新分配空间小于 zl 指向的空间，此时 realloc 会将多余空间回收，导致数据丢失（丢失了尾部），所以为了避免这种情况，我们使用forcelarge来标记这种情况，并将 nextdiff 置为0，详情见https://segmentfault.com/a/1190000018878466?utm_source=tag-newest
//计算原来 p 位置上的节点将要保存的 prevlen（当前待插入节点的大小） 是否变化
nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
//连锁更新的时候会出现问题
if (nextdiff == -4 &amp;amp;&amp;amp; reqlen &amp;lt; 4) {
    nextdiff = 0; //将nextdiff 设置为0，此时内存重分配不会出现回收空间的情况，造成数据丢失
    forcelarge = 1;
}

/* Store offset because a realloc may change the address of zl.
 * 重新分配内存肯呢个会改变 zl 的地址，所以存储偏移
 * */
offset = p-zl; //偏移量，用来表示 p 相对于压缩列表首地址的偏移量，由于重新分配了空间，新元素插入的位置指针 p 会时效，可以预先计算好指针 p 对于压缩列表首地址的偏移量，待空间分配之后再便宜
//最新空间大小   当前压缩列表大小 + 插入元素大小 + 差值长度
newlen = curlen+reqlen+nextdiff;
//重新分配压缩列表大小
zl = ziplistResize(zl,newlen);
//根据偏移找到新插入元素 P 的位置
p = zl+offset;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nextdiff 用来表示 entryX+1 元素长度变化，取值可能为 0 （长度不变）、4（长度增加4）、-4（长度减少4）&lt;br /&gt;
forcelarge 用来表示一种特殊的情况，即 nextdiff==-4&amp;amp;&amp;amp;reqlen&amp;lt;4 ，该情况有可能会导致内存重分配时回收内存空间，进而数据丢失。所以表示这种特殊情况并做处理。&lt;br /&gt;
offset 表示指针 P 相对于压缩列表首地址的偏移位置，内存重分配后计算指针 P 的新的位置时使用&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下面详细说下 nextdiff == -4 &amp;amp;&amp;amp; reqlen &amp;lt; 4 这个情况&lt;br /&gt;
nextdiff == -4 &amp;amp;&amp;amp; reqlen &amp;lt; 4 时会发生什么呢？插入元素导致压缩列表所需空间变小了。即函数 ziplistResize 内部调研 realloc 重新分配的空间小于指针 zl指向的空间。我们知道 realloc 重新分配空间时，返回的地址可能不变（当前位置有足够的内存空间可供分配），当重新分配的空间减少时，realloc 可能会将多余的空间回收，导致数据丢失（压缩列表后面一部分数据丢失）。因此需要避免这种情况的发生，Redis 采用的方法是重新赋值 nextdiff=0，同时使用 forcelarge 标记这种情况。&lt;br /&gt;
那么，nextdiff=-4 时，reqlen 会小于 4 吗？nextdiff=-4 说明插入元素之前 entryX+1 的元素的总长度大于等于 254 字节，所以 entryNew 元素的 previous_entry_length 字段同样需要 5 个字节，即 entryNew 元素的总长度肯定是大于 5 个字节的，reqlen 又怎么会小于 4 呢？正常情况下是不会出现这种情况的，但是由于连锁更新，可能会出现 nextdiff=-4 但 entryX 元素的总长度小于 254 字节的情况，此时 reqlen 可能会小于 4 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;数据复制&lt;/strong&gt;&lt;br /&gt;
重新分配空间之后，需要将位置 P 后的元素移动到指定位置，将新元素插入到位置 P。我们假设 entryX+1 元素的长度增加 4（即nextdiff=4）。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  /* Apply memory move when necessary and update tail offset.
     * 必要时应用内存移动并更新尾偏移量
     * */
    //非空列表插入
    if (p[0] != ZIP_END) {
        /* Subtract one because of the ZIP_END bytes
         * 因为是 ZIP_END 字节，所以减去1
         * */
        //将 p 节点后移（没有移动 p 节点前一节点长度信息），留出当前节点位置
        //p+reqlen: 偏移量是这个，就是将原来的数据移动到新插入节点之后
        //curlen-offset-1+nextdiff: 移动的长度，就是位置 P 之后的所有元素的长度 -1（结束符大小恒为 0XFF，不需要移动），再加上 nextdiff（下一个元素长度的变化）
        //p-nextdiff: 表示从哪个位置需要复制移动，因为下一个元素长度会发生变化，所以需要提前预留出这部分空间，就多复制一块空间，到时候覆盖即可
        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);

        /* Encode this entry&apos;s raw length in the next entry.
         * 在下一个节点中编码节点原始长度 并且判断是否需要加大上一个节点长度
         * */
        //写入 p 节点以前一个节点长度信息（要插入节点的长度）
        if (forcelarge)
            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
        else
            zipStorePrevEntryLength(p+reqlen,reqlen);

        /* Update offset for tail
         * 更新末尾节点的偏移
         * */
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);

        /* When the tail contains more than one entry, we need to take
         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the
         * size of prevlen doesn&apos;t have an effect on the *tail* offset.
         * 当尾部包含多个节点时，还需要考虑 nextdiff，否则，prevlen大小的变化不会对尾部偏移量产生影响
         * */
        assert(zipEntrySafe(zl, newlen, p+reqlen, &amp;amp;tail, 1));
        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
        }
    } else {
        /* This element will be the new tail.
         * 如果在末尾 则该节点将变成新的末尾节点
         * */
        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据复制分为两种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一种是当前插入的位置不是最后，因此需要进行数据赋值&lt;/li&gt;
  &lt;li&gt;另一种是当前插入的位置为尾节点后面，就不需要进行数据复制了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;主要看第一种情况，其中下面这段代码需要仔细理解下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);&lt;br /&gt;
C库函数 void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;p+reqlen 很好理解，就是将 P 后面的数据复制到新节点之后&lt;/li&gt;
  &lt;li&gt;curlen-offset-1+nextdiff 表示复制的字符数量。即 P 后面元素的长度 + entryX+1 元素长度的变化 nextdiff，再减去 1 ，因为结束符恒为 0XFF,不需要移动&lt;/li&gt;
  &lt;li&gt;p-nextdiff 将 P 后面的内容复制过去，然后多复制一块，因为下一个元素的长度空间会发生变化，供下一个元素的 previous_entry_length 使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么第一个更新尾元素偏移量之后，指向的元素可能不是尾元素呢？因为当 entryX+1 元素就是尾元素时，只需要更新一次尾元素的偏移量；但是当 entryX+1 元素不是尾元素时且 entryX+1 元素的长度发生了改变时，尾元素偏移量还需要加上 nextdiff 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;连锁更新&lt;/strong&gt;&lt;br /&gt;
每个节点的 previous_entry_length 属性都记录了前一个节点的长度：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果前一个节点的长度小于 254 字节，那么 previous_entry_length 属性需要用 1 字节长度的空间来保存这个长度值&lt;/li&gt;
  &lt;li&gt;如果前一个节点的长度大于等于 254 字节，那么 previous_entry_length 属性需要用 5 个字节的空间来保存这个长度值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，考虑这样一种情况：在一个压缩列表中，有多个连续的、长度介于 250 字节到 253 字节之间的节点 e1 到 eN ，如下图所示：&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/ziplist/包含节点 e1 至 eN 的压缩列表.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;包含节点 e1 至 eN 的压缩列表&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;因为 e1 到 eN 的所有节点的长度都小于 254 字节，所以记录这些节点的长度只需要 1 字节长的 previous_entry_length 属性。
这时，如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点，那么 new 将成为 e1 的前置节点，如下图所示：&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/ziplist/插入新节点到压缩列表.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;插入新节点到压缩列表&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;因为 e1 的 previous_entry_length 属性仅长 1 字节，它没办法保存新节点 new 的长度，所以程序将对压缩列表执行空间重分配操作，并将 e1 节点的 previous_entry_length 属性从原来的 1 字节扩展为 5 字节长。&lt;br /&gt;
现在，麻烦的事情来了，e1 原本的长度介于 250 字节至 253 字节之间，在为 previous_entry_length 属性新增 4 个字节空间之后， e1 的长度就变成了介于 254 字节至 257 字节之间，而这种长度使用 1 字节长的 previous_entry_length 属性是没办法保存的。&lt;/p&gt;

&lt;p&gt;因此，为了让 e2 的 previous_entry_length 属性可以记录下 e1 的长度，程序需要再次对压缩列表执行空间重分配操作，并将 e2 节点的 previous_entry_length 属性从原来的 1 字节扩展为 5 字节。&lt;/p&gt;

&lt;p&gt;正如扩展 e1 引发了对 e2 的扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展。为了让每个节点的 previous_entry_length 属性都符合压缩列表对节点的要求，程序需要不断地对压缩列表执行空间分配操作，指导 eN 位置。&lt;/p&gt;

&lt;p&gt;Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为 连续更新，下图展示了这一过程：&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/ziplist/连锁更新过程.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;连锁更新过程&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。&lt;/p&gt;

&lt;p&gt;考虑到上图所示的压缩列表，如果 e1 至 eN 都是大小介于 250 字节至 253 字节的节点，big 节点的长度大于等于 254 字节（需要 5 字节的 previous_entry_length 来保存），而 small 节点的长度小于 254 字节（只需要 1 字节的 previous_entry_length 来保存），那么当我们将 small 节点从压缩列表中删除之后，为了让 e1 的 pervious_entry_length 属性可以记录 big 节点的长度，程序将扩展 e1 的空间，并由此引发之后的连锁更新。&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/ziplist/删除节点引发连锁更新.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;删除节点引发连锁更新&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作，而每次空间重分配的最坏复杂度为 O(N) ，所以连锁更新的最坏复杂度为 O(N^2)。&lt;/p&gt;

&lt;p&gt;需要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先，压缩列表里要恰好有多个连续、长度介于 250 字节至 253 字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；&lt;/li&gt;
  &lt;li&gt;其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响；比如说，对三五个节点进行连锁更新是绝对不会影响性能的；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为以上原因，ziplistPush 等命令的平均复杂度仅为 O(N) ，在实际中，可以放心使用这些函数，而不必担心连锁更新会影响压缩列表的性能。&lt;/p&gt;

&lt;p&gt;源码代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* When an entry is inserted, we need to set the prevlen field of the next
 * entry to equal the length of the inserted entry. It can occur that this
 * length cannot be encoded in 1 byte and the next entry needs to be grow
 * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,
 * because this only happens when an entry is already being inserted (which
 * causes a realloc and memmove). However, encoding the prevlen may require
 * that this entry is grown as well. This effect may cascade throughout
 * the ziplist when there are consecutive entries with a size close to
 * ZIP_BIG_PREVLEN, so we need to check that the prevlen can be encoded in
 * every consecutive entry.
 * 当插入一个节点时，我们需要将下一个节点的 prevlen 字段设置为等于插入节点的长度。
 * 可能会出现这种情况，这个长度不能被 1 字节编码，下一个节点需要变大以存储 5字节的 prevlen 编码。
 * 这可以免费完成，因为这只会发生在节点已经被插入（这会导致realloc和memmove）。
 * 但是，编码 prevlen 同样需要节点增长。
 * 当存在大小接近 ZIP_BIG_PREVLEN 的连续节点时，这种效果可能会在整个 ziplist 中级联，因为我们需要检查 prevlen 是否可以在每个连续条目中编码
 *
 *
 * Note that this effect can also happen in reverse, where the bytes required
 * to encode the prevlen field can shrink. This effect is deliberately ignored,
 * because it can cause a &quot;flapping&quot; effect where a chain prevlen fields is
 * first grown and then shrunk again after consecutive inserts. Rather, the
 * field is allowed to stay larger than necessary, because a large prevlen
 * field implies the ziplist is holding large entries anyway.
 * 请注意，这种效果也可以反过来发生，在这种情况下，编码 prevlen 字段所需的字节会缩小。
 * 这种效果被故意忽略了，因为它会导致扑动效果，即在连续插入之后，链上的字段首先增长，然后再次收缩。
 * 相反，允许字段保持比需要的更发，因为较大的 prevlen 字段意味着 ziplist 无论如何多包涵较大的节点。
 *
 *
 * The pointer &quot;p&quot; points to the first entry that does NOT need to be
 * updated, i.e. consecutive fields MAY need an update.
 * 指针 p 指向第一个不需要被更新节点，即连续的字段可能需要更新
 * */
unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    zlentry cur;
    size_t prevlen, prevlensize, prevoffset; /* Informat of the last changed entry. 最后更改的节点信息 */
    size_t firstentrylen; /* Used to handle insert at head. 用于处理头部插入 */
    size_t rawlen, curlen = intrev32ifbe(ZIPLIST_BYTES(zl));
    size_t extra = 0, cnt = 0, offset;
    size_t delta = 4; /* Extra bytes needed to update a entry&apos;s prevlen (5-1).  更新节点的 prevlen 所需的额外字节（5-1） */
    unsigned char *tail = zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl));

    /* Empty ziplist */
    if (p[0] == ZIP_END) return zl;

    //将 p 所指向的节点的信息保存到 cur 结构中
    zipEntry(p, &amp;amp;cur); /* no need for &quot;safe&quot; variant since the input pointer was validated by the function that returned it. */
    //当前节点的长度
    firstentrylen = prevlen = cur.headersize + cur.len;
    //计算编码当前节点的长度所需的字节数
    prevlensize = zipStorePrevEntryLength(NULL, prevlen);
    //记录 p 的偏移量
    prevoffset = p - zl;
    //记录下一节点的偏移量
    p += prevlen;

    /* Iterate ziplist to find out how many extra bytes do we need to update it.
     * 迭代压缩列表找出需要更新的额外字节数
     * */
    while (p[0] != ZIP_END) {
        assert(zipEntrySafe(zl, curlen, p, &amp;amp;cur, 0));

        /* Abort when &quot;prevlen&quot; has not changed. 当 prevlen 没有改变时终止 */
        if (cur.prevrawlen == prevlen) break;

        /* Abort when entry&apos;s &quot;prevlensize&quot; is big enough. 当节点的 prevlensize 足够大时宗旨 */
        if (cur.prevrawlensize &amp;gt;= prevlensize) {
            if (cur.prevrawlensize == prevlensize) {
                zipStorePrevEntryLength(p, prevlen);
            } else {
                /* This would result in shrinking, which we want to avoid.
                 * So, set &quot;prevlen&quot; in the available bytes. */
                zipStorePrevEntryLengthLarge(p, prevlen);
            }
            break;
        }

        /* cur.prevrawlen means cur is the former head entry. */
        assert(cur.prevrawlen == 0 || cur.prevrawlen + delta == prevlen);

        /* Update prev entry&apos;s info and advance the cursor. 更新前一个节点的信息并移动光标 */
        rawlen = cur.headersize + cur.len;
        prevlen = rawlen + delta; 
        prevlensize = zipStorePrevEntryLength(NULL, prevlen);
        prevoffset = p - zl;
        p += rawlen;
        extra += delta;
        cnt++;
    }

    /* Extra bytes is zero all update has been done(or no need to update).
     * 额外字节为零，表示更新已完成（或不需要更新）
     * */
    if (extra == 0) return zl;

    /* Update tail offset after loop.
     * 循环后更新尾部偏移量
     * */
    if (tail == zl + prevoffset) {
        /* When the the last entry we need to update is also the tail, update tail offset
         * unless this is the only entry that was updated (so the tail offset didn&apos;t change). */
        if (extra - delta != 0) {
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra-delta);
        }
    } else {
        /* Update the tail offset in cases where the last entry we updated is not the tail. */
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);
    }

    /* Now &quot;p&quot; points at the first unchanged byte in original ziplist,
     * move data after that to new ziplist.
     * 现在 p 指向原始 ziplist 中第一个未更改的字节，将其之后的数据移动到ziplist中
     * */
    offset = p - zl;
    zl = ziplistResize(zl, curlen + extra);
    p = zl + offset;
    memmove(p + extra, p, curlen - offset - 1);
    p += extra;

    /* Iterate all entries that need to be updated tail to head.
     * 迭代所有需要从头到尾更新的节点
     * */
    while (cnt) {
        zipEntry(zl + prevoffset, &amp;amp;cur); /* no need for &quot;safe&quot; variant since we already iterated on all these entries above. */
        rawlen = cur.headersize + cur.len;
        /* Move entry to tail and reset prevlen. 将入口移动至尾部并重置预设值 */
        memmove(p - (rawlen - cur.prevrawlensize), 
                zl + prevoffset + cur.prevrawlensize, 
                rawlen - cur.prevrawlensize);
        p -= (rawlen + delta);
        if (cur.prevrawlen == 0) {
            /* &quot;cur&quot; is the previous head entry, update its prevlen with firstentrylen. */
            zipStorePrevEntryLength(p, firstentrylen);
        } else {
            /* An entry&apos;s prevlen can only increment 4 bytes. */
            zipStorePrevEntryLength(p, cur.prevrawlen+delta);
        }
        /* Foward to previous entry. 跳转到上一个节点 */
        prevoffset -= cur.prevrawlen;
        cnt--;
    }
    return zl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除元素&lt;/strong&gt;&lt;br /&gt;
ziplistDelete 函数可以同时删除多个元素，输入参数 p 指向的是首个待删除元素的地址，num 表示待删除元素数据。&lt;br /&gt;
删除元素同样可以简要分为三个步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;计算待删除元素的总长度&lt;/li&gt;
  &lt;li&gt;数据复制&lt;/li&gt;
  &lt;li&gt;重新分配空间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;计算待删除元素的总长度&lt;br /&gt;
相关代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//解码第一个待删除元素
zipEntry(p, &amp;amp;first); /* no need for &quot;safe&quot; variant since the input pointer was validated by the function that returned it. */
//遍历所有待删除元素，通知指针后移
for (i = 0; p[0] != ZIP_END &amp;amp;&amp;amp; i &amp;lt; num; i++) {
    p += zipRawEntryLengthSafe(zl, zlbytes, p);
    deleted++;
}

assert(p &amp;gt;= first.p);
//待删除元素的总长度
totlen = p-first.p; /* Bytes taken by the element(s) to delete. 要删除的元素所占的字节数*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即遍历压缩列表，计算待删除元素的长度之和。&lt;/p&gt;

&lt;p&gt;数据复制&lt;br /&gt;
第一步完成之后，指针 first 与指针 p 之间的元素都是待删除的。当指针 p 恰好指向 zlend 字段时，不需要复制数据，只需要更新尾节点的偏移量即可。&lt;/p&gt;

&lt;p&gt;接下来，我们看另外一种情况，即指针 p 指向的是某一个元素，而不是 zlend 字段。 删除元素时，压缩列表所需空间减少，那么减少的量是否仅为待删除元素的总长度呢？那肯定不是了，因为需要更新下一个节点的 previous_entry_length 的值。见下图：&lt;/p&gt;
&lt;center&gt;   
&lt;img src=&quot;../../img/redis/ziplist/压缩列表删除元素示意.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;压缩列表删除元素示意&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;删除元素 entryX+1 到元素 entryN-1 之间的 N-X-1 个元素，元素 entryN-1 的长度为 12 字节，因此元素 entryN 的 previous_entry_length 字段占 1 字节；&lt;br /&gt;
删除这些元素之后，entryX 成为了 entryN 的前一个元素，元素 entryX 的长度为 512 字节，因此元素 entryN 的 previous_entry_length 字段还需要占 5 个字节，即删除元素之后的压缩列表的总长度还与元素 entryN 长度的变化量有关。&lt;br /&gt;
源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* Storing `prevrawlen` in this entry may increase or decrease the
 * number of bytes required compare to the current `prevrawlen`.
 * There always is room to store this, because it was previously
 * stored by an entry that is now being deleted.
 * 在此表项中存储 prevrawlen 可能会比当前 prevrawlen 增加或减少所需的字节数。
 * 总是有空间来存储它，因为它以前是一个现在被删除的节点存储的。
 * 计算删除的 最后一个元素 entryN-1 之后的元素 entryN 的长度变化量
 * */
nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);

/* Note that there is always space when p jumps backward: if
 * the new previous entry is large, one of the deleted elements
 * had a 5 bytes prevlen header, so there is for sure at least
 * 5 bytes free and we need just 4.
 * 请注意，当 p 向后跳转时总是有空间：如果新的前一个节点很大，则删除的元素之一具有 5 字节的 prevlen 头部，因此肯定至少有 5 字节的空闲空间，而我们只需要 4 字节。
 * */
//更新 entryN 的 previous_entry_length 字段
p -= nextdiff;
assert(p &amp;gt;= first.p &amp;amp;&amp;amp; p&amp;lt;zl+zlbytes-1);
zipStorePrevEntryLength(p,first.prevrawlen);

/* Update offset for tail
 * 尾部更新偏移
 * */
set_tail = intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen;

/* When the tail contains more than one entry, we need to take
 * &quot;nextdiff&quot; in account as well. Otherwise, a change in the
 * size of prevlen doesn&apos;t have an effect on the *tail* offset.
 * 当尾部包含多个节点时，我们还需要考虑 nextdiff 。
 * 否则， prevlen  大小的变化不会对 尾 偏移量产生影响。
 * */
assert(zipEntrySafe(zl, zlbytes, p, &amp;amp;tail, 1));
if (p[tail.headersize+tail.len] != ZIP_END) {
    set_tail = set_tail + nextdiff;
}

/* Move tail to the front of the ziplist
 * 将尾部移到压缩列表的签名
 * */
/* since we asserted that p &amp;gt;= first.p. we know totlen &amp;gt;= 0,
 * so we know that p &amp;gt; first.p and this is guaranteed not to reach
 * beyond the allocation, even if the entries lens are corrupted.
 * 因为我们断言 p &amp;gt;= first.p。 我们知道 totlen&amp;gt;=0，所以我们知道 p&amp;gt;first.p ，这保证不会超出分哦，即使节点长度被损坏
 * */
size_t bytes_to_move = zlbytes-(p-zl)-1;
memmove(first.p,p,bytes_to_move);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新分配空间&lt;br /&gt;
重新分配空间与插入元素的类似，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;/* Resize the ziplist
 * 重新调整压缩列表大小
 * */
offset = first.p-zl;
zlbytes -= totlen - nextdiff;
zl = ziplistResize(zl, zlbytes);
p = zl+offset;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，在插入元素时，调用 ziplistResize 函数重新分配空间时，如果重新分配的空间小于指针 zl 指向的空间时，可能会出现问题。而删除元素时，压缩列表的长度肯定时减小的。&lt;br /&gt;
因为删除元素时，先复制数据，再重新分配空间，即调用 ziplistResize 函数时，多余的那部分空间存储的数据已经被复制，此时回收这部分空间并不会造成数据的损失。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html#ziplist%E7%BB%93%E6%9E%84&lt;br /&gt;
http://zhangtielei.com/posts/blog-redis-ziplist.html&lt;br /&gt;
https://juejin.cn/post/6914456200650162189#heading-17
https://juejin.cn/post/7097856013776191518
https://segmentfault.com/a/1190000018878466?utm_source=tag-newest
https://wenfh2020.com/2020/01/30/redis-ziplist/&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="redis" />
      

      

      
        <summary type="html">压缩列表 - ziplist ziplist 是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在 O(1) 的时间复杂度下完成 list 两端的 push 和 pop 操作。但是因为每次操作都需要重新分配 ziplist 的内存，所以实际复杂度和 ziplist 的内存使用量相关。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Redis Sds</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Redis Sds" />
      <published>2024-07-09T00:00:00+08:00</published>
      <updated>2024-07-09T00:00:00+08:00</updated>
      <id>http://localhost:4000/redis-sds</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;简单动态字符串---sds&quot;&gt;简单动态字符串 - sds&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;一种用于存储二进制数据的一种结构，具有动态扩容的特点，其实现位于src/sds.h和src/sds.c中。从版本3.2开始，sds底层数据结构也发生改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;字符串编码类型&lt;/strong&gt;&lt;br /&gt;
字符串有三种 encoding 类型 int 、 raw 、 embstr 。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;int：用于整数类型&lt;/li&gt;
  &lt;li&gt;embstr：用于短字符串&lt;/li&gt;
  &lt;li&gt;raw：用于长字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;定义在 server.h 中，下面列出 string 类型的编码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;br /&gt;
如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型来表示，那么这个整数值将会保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ），并将字符串对象的编码设置为 int 。&lt;br /&gt;
相对于用 raw 编码， int 编码既节省了指针占用的内存，也节省了 sds 结构的内存。&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/string-int.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;int示例&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;embstr&lt;/strong&gt;&lt;br /&gt;
embstr 编码是专门用于保存短字符串的一种优化编码方式。当字符串的长度小于等于 44(redis 3.2版本之前为39) 字节的时候，将采用 embstr 编码。&lt;br /&gt;
创建字符串对象的代码如下（object.c）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Create a string object with EMBSTR encoding if it is smaller than
 * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is
 * used.
 * 如果字符串小于等于OBJ_ENCODING_EMBSTR_SIZE_LIMIT 创建embstr编码，否则使用raw编码
 *
 * The current limit of 44 is chosen so that the biggest string object
 * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc.
 * 选择当前44的限制是为了作为embstr分配的最大字符串对象仍然适合64字节的jemalloc
 *
 */
#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
robj *createStringObject(const char *ptr, size_t len) {
    if (len &amp;lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return createRawStringObject(ptr,len);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;embstr 有个显著的特点，就是 redisObject 跟 sds 的内存是连在一起的。好处有：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;分配内存的时候只需要分配一次。而 raw 编码的 sds 跟 RedisObject 分离，就是分配两次内存&lt;/li&gt;
  &lt;li&gt;同样，释放内存也只需要释放一次&lt;/li&gt;
  &lt;li&gt;连续内存能更好利用内存带来的优势&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/embstr结构示意图.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;embstr结构示意图&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;raw&lt;/strong&gt;&lt;br /&gt;
raw 编码主要用来保存长度超过 44（redis 3.2版本之后） 字节的字符串。其真实数据由sdshdr结构来表示存储，外层还是由 RedisObject 包装。&lt;br /&gt;
sds 的结构大致如下：&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/raw-sds结构.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;raw-sds结构&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;redisObject 中的 ptr 指针，就是指向 sds 。&lt;/p&gt;
&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/raw-robj.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;raw-robj&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;编码转换&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;int 转 raw&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当字符串传的不是整数的时候，int 就会转成 raw 编码&lt;/li&gt;
  &lt;li&gt;如果执行了一些修改命令，如 append 等（set 不算），都会转成 raw 编码&lt;/li&gt;
  &lt;li&gt;一旦编码变为 raw 之后，将不会再转成 embstr&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;embstr 转 raw&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果执行了一些修改的命令，如 append 等，都会转成 raw 编码，不管修改后字符串的长度。因为没有给 embstr 编码实现修改接口，实际上 embstr 是只读的。&lt;/li&gt;
  &lt;li&gt;一旦编码为 raw 之后，将不会再转成 embstr&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;embstr编码为什么从 39 位修改为 44 位&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;embstr 编码中，RedisObject 和 sds 是一块连续的内存空间，这块内存空间 Redis 限制了 64 个字节，而 RedisObject 固定占了 16 字节，
redis3.2 版本之前的 sds 占了 8 个字节，再加上字符串末尾 \0 占用了 1 个字节，所以：64-16-8-1=39 字节。&lt;br /&gt;
redis3.2 版本之后 sds 做了优化，对于 embstr 编码会采用 sdshdr8 来存储，而 sdshdr8 占用的空间只有 24 位，即 3 字节（len+alloc+flag） + \0 字符(1字节)，
所以最后为： 64-16-3-1=44 字节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;sds结构优化&lt;/strong&gt;&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/sds结构图-3.0.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;sds结构图-3.0&lt;/div&gt;
&lt;/center&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#redis3.2 sdshdr结构  

struct sdshdr {
    //记录buf数组中已使用字节的数量  4字节
    //等于SDS所保存字符串的长度
    unsigned int len;

    //记录buf数组中未使用字节的数量  4字节
    unsigned int free;

    //char数组，用于保存字符串
    char buf[];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;len为6，表示这个SDS保存了一个长度为5的字符串  4字节&lt;/li&gt;
  &lt;li&gt;free为0，表示这个SDS没有剩余空间  4字节&lt;/li&gt;
  &lt;li&gt;buf是个char类型的数组，注意末尾保存了一个空字符 ‘\0’(1字节)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#redis6.2 sdshdr结构  

struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */ 已使用 1字节存储
    uint8_t alloc; /* excluding the header and null terminator */ 1字节存储
    unsigned char flags; /* 3 lsb of type, 5 unused bits */ 1字节存储
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;strong&gt;sdshdr&lt;/strong&gt; 是头部，它的大小可以通过 sizeOf() 方法计算， &lt;strong&gt;buf&lt;/strong&gt; 是真实存储用户数据的地方，另外注意，从命名上能看出来，这个数据结构除了能存储二进制数据，显然是用于设计作为字符串使用的，所以在 &lt;strong&gt;buf&lt;/strong&gt; 中，用户数据后总跟着一个 &lt;strong&gt;\0&lt;/strong&gt;，即图中的 “数据”+”\0” 就是所谓的buf。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;len:保存了SDS保存字符串的长度   (len-alloc 即为之前的 free)&lt;/li&gt;
  &lt;li&gt;alloc:分别以uint8, uint16, uint32, uint64表示整个SDS，除头部与末位的 \0，剩余的字节数&lt;/li&gt;
  &lt;li&gt;flags:始终为 1 字节，以低三位标示着头部的类型，高五位未使用&lt;/li&gt;
  &lt;li&gt;buf[]:数组用来保存字符串的每个元素，注意末尾保存了一个空字符 ‘\0’&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个字段大小可以根据不同 sdshdr 来计算，比如 sdshdr8 代表 8bit 即 1字节，以此类推。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;printf(&quot;%ld\n&quot;, sizeof(struct sdshdr8));  // 3
printf(&quot;%ld\n&quot;, sizeof(struct sdshdr16)); // 5
printf(&quot;%ld\n&quot;, sizeof(struct sdshdr32)); // 9
printf(&quot;%ld\n&quot;, sizeof(struct sdshdr64)); // 17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，我们还需要注意以下源码中的 &lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;packed&lt;/strong&gt;)) 。它的作用就是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用的字节数进行对齐。&lt;br /&gt;
从上面我们已经知道，结构体会按照所有变量中最宽的基本数据类型做字节对齐。但是用 packed 修饰后，结构体则变为按 1 字节对齐。&lt;br /&gt;
以 sdshdr32 为例，修饰前按 4 字节对齐大小为 12（4*3 - [len=4;alloc=4;flags=4(实际是1)]） 字节；修饰后按 1 字节对齐，共 9 （4*2+1 - [len=4;alloc=4;flags=1(实际是1)]）  字节。注意 buf 是个 char 类型的柔性数组，地址连续，始终在 flags 之后，packed 修饰前后如下图所示。&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/packed修饰前后示意.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;packed修饰前后示意&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;这样做有两个好处：&lt;br /&gt;
1 - 节省内存：例如 sdshdr32 可节省 3 个字节（12-9）&lt;br /&gt;
2 - SDS 返回给上层的，不是结构体首地址，而是指向内容的 buf 指针。因为此时按 1 字节对齐，故 SDS创建成功后， 无论是 sdshdr8、sdsdhr16、还是 sdshdr32，都能通过 (char*)sh+hdrlen 得到 buf 指针地址（其中 hdrlen 是结构体长度，通过 sizeof 计算得到）。修饰后，无论是 sdshdr8、sdshdr16 还是 sdshdr32，都能通过 buf[-1] 找到 flags，因为此时按 1 字节对齐。若没有 packed 的修饰，还需要对不同结构进行处理，实现更复杂。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;存在问题:&lt;br /&gt;
  不同长度的字符串是否有必要占用大小相同的头部？一个int占 4 字节，在实际应用中，存放与redis的字符串往往没有这么长，每个字符串都用 4 字节存储未免太浪费空间。&lt;br /&gt;
  短字符串，len 和 free 的长度为 1 字节就够了；长字符串，用 2 字节或 4 字节；更长的字符串，用 8 字节。&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
这样确实更省内存，但依然存在以下问题：&lt;br /&gt;
1-如何区分三种情况？&lt;br /&gt;
2-对于短字符串来说，头部还是太长了。以长度为 1 字节的字符串为例，len 和 free 本身就占了 2 字节，能不能进一步压缩呢？&lt;br /&gt;
对于问题 1，考虑增加一个字符 flags 来标识类型，用最小的 1 字节来存储，且把 flags 加在柔性数组 buf 之前，这样虽然多了 1 字节，但是通过偏移柔性数组的指针即能快速定位 flags ，区分类型也可以接受。&lt;br /&gt;
对于问题 2，由于 len 已经是最小的 1 字节了，再压缩只能考虑用位长来存储长度了。&lt;/p&gt;

&lt;p&gt;  结合以上两个问题，5 种类型（长度 1 字节、2 字节、4 字节、8 字节、小于 1 字节）的SDS至少需要 3 位来存储类型（2^3=8），1 个字节 8 位，剩余的 5 位存储长度，可以满足长度小于 32 的短字符串。&lt;/p&gt;

&lt;p&gt;在 Redis 5.0 中，我们用如下结构来存储长度小于 32 的短字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 低 3 位存储类型，高 5 位存储长度 */
    char buf[];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sdshdr5 结构如下，flags 占 1 个字节，其低三位（bit）表示 type，高 5 位（bit）表示长度。能表示的长度区间为 0~31(2^5)。flags 后面就是字符串的内容。&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/sdshdr5结构.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;sdshdr5结构&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;而长度大于 31 的字符串，1 字节依然放不下。按之前的思路，将 len 和 free 单独存放。sdshdr8、sdshdr16、sdshdr32和sdshdr64的结构相同，以 sdshdr8 为例，结构如下：&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/sdshdr8结构.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;sdshdr8结构&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;其中表头共占用了 S[1(len) + 1(alloc) + 1(flags)] 个字节。flags的内容与 sdshdr5 类型，依然采用 3 位存储类型，但剩余 5 位不存储长度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sds源码分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串创建&lt;/strong&gt;&lt;br /&gt;
核心代码在 sds.c#sdsnewlen() :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Create a new sds string with the content specified by the &apos;init&apos; pointer
 * and &apos;initlen&apos;.
 * 通过init指针和initlen指定的内容创建一个新的sds字符串
 * If NULL is used for &apos;init&apos; the string is initialized with zero bytes.
 * 如果init为null 字符串将被初始化为0字节
 * If SDS_NOINIT is used, the buffer is left uninitialized;
 * 如果使用SDS_NOINIT，缓冲区将不会初始化
 *
 * The string is always null-termined (all the sds strings are, always) so
 * even if you create an sds string with:
 * 字符串总是空结尾（适用于所有的sds字符串），即使你创建mystring = sdsnewlen(&quot;abc&quot;,3) 字符串
 *
 * mystring = sdsnewlen(&quot;abc&quot;,3);
 *
 * You can print the string with printf() as there is an implicit \0 at the
 * end of the string. However the string is binary safe and can contain
 * \0 characters in the middle, as the length is stored in the sds header.
 * 你可以通过printl()打印字符串，在字符串末尾会有一个隐含的 \0. 然而 字符串是二进制安全的，可以包含中间的 \0 字符，因为长度存储在sds头部
 *
 */
sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) {
    void *sh;
    sds s;
    //根据字符串长度初始化sds类型
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    //空字符串通常是为了添加而创建。使用 8 代替 5
    if (type == SDS_TYPE_5 &amp;amp;&amp;amp; initlen == 0) type = SDS_TYPE_8;
    //根据上一步获取的type计算header的长度
    int hdrlen = sdsHdrSize(type);
    //标志位的指针
    unsigned char *fp; /* flags pointer. */
    //已分配的空间
    size_t usable;

    assert(initlen + hdrlen + 1 &amp;gt; initlen); /* Catch size_t overflow */
    //申请内存 大小为 头部+字符串大小+null字符串结尾
    sh = trymalloc?
        s_trymalloc_usable(hdrlen+initlen+1, &amp;amp;usable) ://尝试分配内存，失败返回null
        s_malloc_usable(hdrlen+initlen+1, &amp;amp;usable);//分配内存或抛出异常
    if (sh == NULL) return NULL;
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        //初始化内存 将 sh 内存块中前 hdrlen+initlen+1 个字节设置为 0
        memset(sh, 0, hdrlen+initlen+1);
    //将 s 指向字符串的首地址 即指向buf，从首地址向右偏移 hdrlen 长度
    s = (char*)sh+hdrlen;
    //fp 指向头部的最后一个字节 即flag
    fp = ((unsigned char*)s)-1;

    //已使用大小 即申请内容大小减去 头部大小 + 末尾 1 字节占位符
    usable = usable-hdrlen-1;
    if (usable &amp;gt; sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    //根据类型初始化字符串
    switch(type) {
        case SDS_TYPE_5: {
            //sdshdr5 的 flags 的 高5bit 存放着 len， 低3bit位存放着 type
            *fp = type | (initlen &amp;lt;&amp;lt; SDS_TYPE_BITS);
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            sh-&amp;gt;len = initlen;//初始化总长度
            sh-&amp;gt;alloc = usable;//初始化已使用长度
            *fp = type;//初始化类型
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            sh-&amp;gt;len = initlen;
            sh-&amp;gt;alloc = usable;
            *fp = type;
            break;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            sh-&amp;gt;len = initlen;
            sh-&amp;gt;alloc = usable;
            *fp = type;
            break;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            sh-&amp;gt;len = initlen;
            sh-&amp;gt;alloc = usable;
            *fp = type;
            break;
        }
    }
    if (initlen &amp;amp;&amp;amp; init)
        //将 init 字符串的内容复制到 s 中
        memcpy(s, init, initlen);
    //初始化字符串结尾 占位符
    s[initlen] = &apos;\0&apos;;
    return s;
}


/**
 * 根据字符串长度判断 sds类型
 * 1&amp;lt;&amp;lt;5 = 32 :      SDS_TYPE_5
 * 1&amp;lt;&amp;lt;5 = 256:      SDS_TYPE_8
 * 1&amp;lt;&amp;lt;16 = 65536:   SDS_TYPE_16
 * 1&amp;lt;&amp;lt;32 = 4294967296:   SDS_TYPE_32
 * else:   SDS_TYPE_64
 * @param string_size
 * @return
 */
static inline char sdsReqType(size_t string_size) {
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;5)
        return SDS_TYPE_5;
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;8)
        return SDS_TYPE_8;
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;16)
        return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size &amp;lt; 1ll&amp;lt;&amp;lt;32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}


/**
 * 获取不同类型头部长度
 * @param type 
 * @return 
 */
static inline int sdsHdrSize(char type) {
    switch(type&amp;amp;SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return sizeof(struct sdshdr5);
        case SDS_TYPE_8:
            return sizeof(struct sdshdr8);
        case SDS_TYPE_16:
            return sizeof(struct sdshdr16);
        case SDS_TYPE_32:
            return sizeof(struct sdshdr32);
        case SDS_TYPE_64:
            return sizeof(struct sdshdr64);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br /&gt;
根据字符串长度选择合适的 sds 类型并分配内存，根据字符串类型初始化 sds 。返回值是 sds 结构中 buf 的指针。&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串扩容&lt;/strong&gt;&lt;br /&gt;
核心代码在 sds.c#sdscat()#sdsMakeRoomFor()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Append the specified null terminated C string to the sds string &apos;s&apos;.
 * 将指定的以空结尾的C字符串追加到sds字符串 &apos;s&apos;后面
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串不再有效，所有的引用必须被该调用返回的指针替代
 */
sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}

/* Append the specified binary-safe string pointed by &apos;t&apos; of &apos;len&apos; bytes to the
 * end of the specified sds string &apos;s&apos;.
 * 将指定的以空结尾的C字符串追加到sds字符串 &apos;s&apos;后面
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串不再有效，所有的引用必须被该调用返回的指针替代
 */
sds sdscatlen(sds s, const void *t, size_t len) {
    //获取字符串 s 的长度，即取 len 属性 sds5取flags的高五位
    size_t curlen = sdslen(s);
    //字符串扩容
    s = sdsMakeRoomFor(s,len);
    if (s == NULL) return NULL;
    //将 len 长度 t 复制到 s字符串中， 从 s+curlen 位置开始
    memcpy(s+curlen, t, len);
    //更新字符串长度 即len属性， sds5更新flags的高五位
    sdssetlen(s, curlen+len);
    //末尾添加占位符
    s[curlen+len] = &apos;\0&apos;;
    return s;
}


/* Enlarge the free space at the end of the sds string so that the caller
 * is sure that after calling this function can overwrite up to addlen
 * bytes after the end of the string, plus one more byte for nul term.
 * 扩大sds字符串末尾的可用空间，调用后可以保证在字符串结束后覆盖最多 addlen 个字节，再加上一个字节为 null 占位符
 *
 * Note: this does not change the *length* of the sds string as returned
 * by sdslen(), but only the free buffer space we have.
 * 注意：他不会改变 sds 字符串的长度，例如调用 sdslen()， 但是只有可用的缓冲空间
 */
sds sdsMakeRoomFor(sds s, size_t addlen) {
    void *sh, *newsh;
    //获取可用空间 即 len-alloc=free
    size_t avail = sdsavail(s);
    size_t len, newlen, reqlen;
    //获取 s 字符串类型 s指向buf的指针，s[-1]即为flags地址
    char type, oldtype = s[-1] &amp;amp; SDS_TYPE_MASK;
    int hdrlen;
    size_t usable;

    /* Return ASAP if there is enough space left. */
    //如果 可用大于 addlen 直接返回
    if (avail &amp;gt;= addlen) return s;

    //获取字符串长度
    len = sdslen(s);
    //将指针向左偏移 hdr 长度，即当前指针指向 sds头部，而不是从 buf 开始
    sh = (char*)s-sdsHdrSize(oldtype);
    //初始化新增的长度
    reqlen = newlen = (len+addlen);
    assert(newlen &amp;gt; len);   /* Catch size_t overflow */
    //如果拼接字符串后的长度小于 1M， 则扩容为拼接字符串后长度的两倍
    if (newlen &amp;lt; SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        //否则在拼接长度的基础上新增 1M
        newlen += SDS_MAX_PREALLOC;

    //根据最终字符串长度 获取字符串类型
    type = sdsReqType(newlen);

    /* Don&apos;t use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    //获取新字符串类型长度
    hdrlen = sdsHdrSize(type);
    assert(hdrlen + newlen + 1 &amp;gt; reqlen);  /* Catch size_t overflow */
    //如果扩容后结构体不变
    if (oldtype==type) {
        //根据原始字符串及扩容后的长度重新分配内存，并将内容复制到新内存中，并清空原内存空间
        //usable会被设置为当前分配的大小
        newsh = s_realloc_usable(sh, hdrlen+newlen+1, &amp;amp;usable);
        if (newsh == NULL) return NULL;
        //将 s 字符串指针指向 buf 数组
        s = (char*)newsh+hdrlen;
    } else {
        /* Since the header size changes, need to move the string forward,
         * and can&apos;t use realloc */
        //由于头部长度改变，需要向前移动字符串，不能使用内存重新分配
        //分配最新长度的内存空间，从堆上重新申请数据空间
        newsh = s_malloc_usable(hdrlen+newlen+1, &amp;amp;usable);
        if (newsh == NULL) return NULL;
        //将 len+1 长度的 s 内容复制新内存空间中
        memcpy((char*)newsh+hdrlen, s, len+1);
        //释放原内容空间
        s_free(sh);
        //将 s 字符串指针指向 buf 数组
        s = (char*)newsh+hdrlen;
        //设置字符串类型 flags
        s[-1] = type;
        //更新新字符串长度
        sdssetlen(s, len);
    }
    //获取实际可用数据空间
    usable = usable-hdrlen-1;
    if (usable &amp;gt; sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    //设置新字符串已使用总长度 alloc
    sdssetalloc(s, usable);
    return s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br /&gt;
扩容阶段：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若 SDS 中剩余空闲空间 avail 大于新增内容的长度 addlen，则无需扩容；&lt;/li&gt;
  &lt;li&gt;若 SDS 中剩余空闲空间 avail 小于或等于新增内容的长度 addlen：
    &lt;ul&gt;
      &lt;li&gt;若新增后的总长度 len+addlen &amp;lt; 1MB ，则按新长度的两倍扩容；&lt;/li&gt;
      &lt;li&gt;若新增后的总长度 len+addlen &amp;gt;= 1MB ，则按新长度加上 1MB 扩容。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内容分配阶段：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据扩容后的长度选择对应的SDS类型：
    &lt;ul&gt;
      &lt;li&gt;若类型不变，则只需通过 s_realloc_usable 扩大 buf 数组即可；&lt;/li&gt;
      &lt;li&gt;若类型变化，则需要为整个 SDS 重新分配内存，并将原来的 SDS 内容拷贝至新位置。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/sdsMakeRoomFor流程图.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;sdsMakeRoomFor流程图&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串释放（惰性空间释放）&lt;/strong&gt;&lt;br /&gt;
重置len属性清空SDS在 sds.c#sdsclear()&lt;br /&gt;
真正清空SDS在 sds.c#sdsfree()&lt;br /&gt;
清空空闲缓存在 sds.c#sdsRemoveFreeSpace()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Modify an sds string in-place to make it empty (zero length).
 * However all the existing buffer is not discarded but set as free space
 * so that next append operations will not require allocations up to the
 * number of bytes previously available.
 * 原地修改 SDS 字符串使用为空（长度为0）
 * 但是所有的缓冲区不会被丢弃而是被设置为空闲区域，这样下一个追加操作不需要分配之前可用的字节数
 */
void sdsclear(sds s) {
    //将长度设置为0
    sdssetlen(s, 0);
    s[0] = &apos;\0&apos;;
}

/* Free an sds string. No operation is performed if &apos;s&apos; is NULL.
 * 释放 sds字符串。当 s 为 NULL 时不会执行任何操作
 */
void sdsfree(sds s) {
    if (s == NULL) return;
    //s-sdsHdrSize(s[-1]):指针指向sds起始地址  s_free释放内存
    s_free((char*)s-sdsHdrSize(s[-1]));
}

/* Reallocate the sds string so that it has no free space at the end. The
 * contained string remains not altered, but next concatenation operations
 * will require a reallocation.
 * 重新分配sds字符串，使得结尾没有任何空余空间。
 * 原来包含的字符串不会改动，但是下一个串联操作将需要重新分配内存
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call.
 * 在此调用之后，传入的sds字符串将不再有效。且所有的引用将被调用返回的新指针代替
 */
sds sdsRemoveFreeSpace(sds s, int would_regrow) {
    return sdsResize(s, sdslen(s), would_regrow);
}

/* Resize the allocation, this can make the allocation bigger or smaller,
 * if the size is smaller than currently used len, the data will be truncated.
 * 调整分配大小，这可以使分配更大或更小，如果大小小于当前已使用的长度，数据将被截断
 *
 * The when the would_regrow argument is set to 1, it prevents the use of
 * SDS_TYPE_5, which is desired when the sds is likely to be changed again.
 * 当would_regrow参数为1时，它将阻止使用sds5，这是在sds可能再次更改时所需要的
 *
 * The sdsAlloc size will be set to the requested size regardless of the actual
 * allocation size, this is done in order to avoid repeated calls to this
 * function when the caller detects that it has excess space.
 * 无论实际大小多少，sdsAlloc大小都将被设置为请求的大小，这么做是为了当调用者检测到它有多余的空间时防止重复调用此方法
 */
sds sdsResize(sds s, size_t size, int would_regrow) {
    void *sh, *newsh;
    //取原sds类型
    char type, oldtype = s[-1] &amp;amp; SDS_TYPE_MASK;
    //取原sds头部长度
    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);
    //取sds 长度
    size_t len = sdslen(s);
    //指针指向sds起始位置
    sh = (char*)s-oldhdrlen;

    /* Return ASAP if the size is already good. */
    //如果大小已经满足则直接满足  即 len=alloc
    if (sdsalloc(s) == size) return s;

    /* Truncate len if needed. */
    //如果size小于len 直接直接截断
    if (size &amp;lt; len) len = size;

    /* Check what would be the minimum SDS header that is just good enough to
     * fit this string. */
    //根据size  重新计算sds类型
    type = sdsReqType(size);
    if (would_regrow) {
        /* Don&apos;t use type 5, it is not good for strings that are expected to grow back. */
        //不要使用type5， 它不适合那些期望增长回来的字符串
        if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    }
    //根据sds类型计算头部大小
    hdrlen = sdsHdrSize(type);

    /* If the type is the same, or can hold the size in it with low overhead
     * (larger than SDS_TYPE_8), we just realloc(), letting the allocator
     * to do the copy only if really needed. Otherwise if the change is
     * huge, we manually reallocate the string to use the different header
     * type.
     * 如果类型相同，或可以用低位表示大小（type大于8），我们只需要 realloc()，让分配器只在真正需要的时候进行复制。
     * 如果改变很大，根据不同的头部大小手动重新分配内存
     */
    //判断是需要重新分配
    int use_realloc = (oldtype==type || (type &amp;lt; oldtype &amp;amp;&amp;amp; type &amp;gt; SDS_TYPE_8));
    //若重新分配使用原类型
    size_t newlen = use_realloc ? oldhdrlen+size+1 : hdrlen+size+1;
    int alloc_already_optimal = 0;
    #if defined(USE_JEMALLOC)
        /* je_nallocx returns the expected allocation size for the newlen.
         * We aim to avoid calling realloc() when using Jemalloc if there is no
         * change in the allocation size, as it incurs a cost even if the
         * allocation size stays the same. */
        alloc_already_optimal = (je_nallocx(newlen, 0) == zmalloc_size(sh));
    #endif

    //使用重新分配内存
    if (use_realloc &amp;amp;&amp;amp; !alloc_already_optimal) {
        //根据newlen重新分配内存
        newsh = s_realloc(sh, newlen);
        if (newsh == NULL) return NULL;
        //指针指向 buf 缓冲区
        s = (char*)newsh+oldhdrlen;
    } else if (!alloc_already_optimal) {
        //使用新建内存空间 新分配newlen的空间
        newsh = s_malloc(newlen);
        if (newsh == NULL) return NULL;
        //将s的len长度内存复制到newsh+hdrlen中
        memcpy((char*)newsh+hdrlen, s, len);
        //释放sh
        s_free(sh);
        //指针指向 buf缓冲区
        s = (char*)newsh+hdrlen;
        //设置flgas类型
        s[-1] = type;
    }
    //设置字符串末尾占位符
    s[len] = 0;
    //更新长度
    sdssetlen(s, len);
    //更新已使用大小
    sdssetalloc(s, size);
    return s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br /&gt;
redis提供了三种方法清空 SDS。&lt;br /&gt;
sdsclear：重置len属性，不直接释放内存，新的数据可以复写，而不用重新申请内存。&lt;br /&gt;
sdsfree：通过 s_free 释放内存。&lt;br /&gt;
sdsRemoveFreeSpace：清空未使用缓存空间，执行字符串相关指令时通过 tryObjectEncoding 触发或通过 clientsCron 定时触发。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;为什么使用sds&quot;&gt;为什么使用sds&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;常数复杂度获取字符串长度&lt;br /&gt;
由于len属性的存在，我们获取sds字符串的长度只需要获取len属性，时间复杂度为O(1)。而对于C语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为O(n)。通过&lt;strong&gt;strlen key&lt;/strong&gt;命令可以获取key的字符串长度。&lt;/li&gt;
  &lt;li&gt;杜绝缓冲区溢出&lt;br /&gt;
在C语言中使用strcat函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间就会造成缓冲区溢出。而对于SDS数据类型，在进行字符修改的时候，会首先根据记录的len属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。&lt;/li&gt;
  &lt;li&gt;减少修改字符串的内存重分配次数&lt;br /&gt;
C语言由于不记录字符串长度，所以如果要修改字符串，必须要重新分配内存，如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄漏。&lt;br /&gt;
而对于SDS，由于len和alloc属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略:
    &lt;ol&gt;
      &lt;li&gt;空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。&lt;/li&gt;
      &lt;li&gt;惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重分配来回收缩短后多余的字节，而是使用&lt;strong&gt;alloc&lt;/strong&gt;属性将这些字节的数量记录下来，等待后续使用。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;二进制安全&lt;br /&gt;
因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件，内容可能包括空字符串，因此C字符串无法正确存取；而所有SDS的API都是以处理二进制的方式来处理buf里面的元素，并且SDS不是以空字符串来判断是否结束，而是以len属性表示的长度来判断字符串是否结束。&lt;/li&gt;
  &lt;li&gt;兼容部分C字符串函数&lt;br /&gt;
虽然SDS是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用C语言库 string.h 中的一部分函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;空间预分配进一步理解&quot;&gt;空间预分配进一步理解&lt;/h5&gt;
&lt;p&gt;当执行追加操作时，比如现在给key=’Hello World’的字符后追加’ again!’，则这时的len=18，free由0变成了18，此时的 buf=’Hello World again!\0………………’(.表示空格)，也就是buf的内存空间是18+18+1=37字节，其中’\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，
就无须在进行空间分配了。在当前版本中，当新字符串长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。&lt;br /&gt;
思考：&lt;strong&gt;这种分配策略会浪费内存资源吗？&lt;/strong&gt; &lt;br /&gt;
答：执行过APPEND命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭redis之后，再次启动时重新载入的字符串对象将不会有预分配空间。
因为执行APPEND命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND操作的键很多，而字符串的体积又很大的话，那可能就需要修改redis服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;小结&quot;&gt;小结&lt;/h5&gt;
&lt;p&gt;redis的字符串表示为sds，而不是C字符串（以\0结尾的char*），它是redis底层所使用的字符串表示，对比如下：&lt;/p&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/sds/sds和c字符串对比.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;redis字符串对比图&lt;/div&gt;
&lt;/center&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://pdai.tech/md/db/nosql-redis/db-redis-overview.html&lt;br /&gt;
https://blog.wangjunfeng.com/post/redis-sds/&lt;br /&gt;
https://juejin.cn/post/7064359936842530830&lt;br /&gt;
https://www.cnblogs.com/chenchuxin/p/14189925.html&lt;br /&gt;
https://cloud.tencent.com/developer/article/1911682&lt;br /&gt;
https://www.cnblogs.com/chenchuxin/p/14204452.html&lt;br /&gt;
https://juejin.cn/post/6894539895084154887&lt;br /&gt;
https://blog.csdn.net/yangbodong22011/article/details/78419966&lt;br /&gt;
https://www.aphysia.cn/archives/redis-2—sdsyuan-ma-fen-xi&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="redis" />
      

      

      
        <summary type="html">简单动态字符串 - sds 一种用于存储二进制数据的一种结构，具有动态扩容的特点，其实现位于src/sds.h和src/sds.c中。从版本3.2开始，sds底层数据结构也发生改变。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Redisobject</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Redisobject" />
      <published>2024-06-24T00:00:00+08:00</published>
      <updated>2024-06-24T00:00:00+08:00</updated>
      <id>http://localhost:4000/redisObject</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;center&gt;   
&lt;img src=&quot;../../img/redis/redisObject/redisObject.jpg&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;redisObject概览&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;    上图展示了redisObject，Redis所有数据类型、Redis所有编码方式以及底层数据结构之间的关系。&lt;br /&gt;
    它反映了redis的每种对象其实都由 &lt;strong&gt;对象结构（redisObject）&lt;/strong&gt; 与 &lt;strong&gt;对应编码的数据结构&lt;/strong&gt; 组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。&lt;br /&gt;
所以，我们需要从几个角度来研究：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对象设计机制：对象结构（redisObject）&lt;/li&gt;
  &lt;li&gt;编码类型和底层数据结构：对应编码的数据结构&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;为什么设计redisobject对象&quot;&gt;为什么设计redisObject对象&lt;/h3&gt;

&lt;p&gt;    在redis的命令中，用于对键进行处理的命令占了很大一部分，而对于键所保存的值的类型（键的类型），键能执行的命令又各不相同。
如：LPUSH和LLEN只能用于列表键，而SADD和SRANDMEMBER只能用于集合键等；另外一些命令，比如DEL、TTL和TYPE，可以用于任何类型的键；但是要正确实现这些命令，
必须为不同类型的键设置不同的处理方式，比如说，删除一个列表键和删除一个字符串键的操作过程就不太一样。&lt;br /&gt;
    故：&lt;strong&gt;Redis必须让每个键都带有类型信息，使得程序可以检查键的类型，并为它选择合适的处理方式。&lt;/strong&gt;&lt;br /&gt;
    比如说，集合类型就可以由字典和整数集合两种不同的数据结构实现，但是当用户执行ZADD命令时，它不关心集合使用的是什么编码，只要Redis能按照ZADD命令的指示，将新元素添加到集合就可以了。&lt;br /&gt;
    这说明，&lt;strong&gt;操作数据类型的命令除了要对键的类型进行检查之外，还需要根据数据类型的不同编码进行多态处理。&lt;/strong&gt;&lt;br /&gt;
    为了解决以上问题，Redis构建了自己的类型系统，这个系统的主要功能包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;redisObject对象&lt;/li&gt;
  &lt;li&gt;基于redisObject对象的类型检查&lt;/li&gt;
  &lt;li&gt;基于redisObject对象的显示多态函数&lt;/li&gt;
  &lt;li&gt;对redisObject进行分配、共享和销毁的机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;redisobject数据结构&quot;&gt;redisObject数据结构&lt;/h3&gt;
&lt;p&gt;    redisObject是Redis类型系统的核心，数据库中的每个键、值以及Redis本身处理的参数，都表示为这种数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;typedef struct redisObject {
    unsigned type:4;            //redisObject的类型    4bit
    unsigned encoding:4;        //同一种类型的不同编码方式  4bit
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or  
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
                            //记录RedisObject的访问时间信息      24bit
                            //LRU时间（相对于全局 lru_clock）
                            //LFU数据(最低有效的8位频率和最高有效的16位访问时间)
    int refcount;           //引用计数      32bit
    void *ptr;              //指向底层实现数据结构的指针     64bit
} robj;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redisObject占用 16 个字节( 4 + 4 + 24 + 32 + 64 = 128 位)。&lt;br /&gt;
其中type、encoding和ptr是最重要的三个属性。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;type记录了对象所保存的值的类型，它的值可能是以下常量中的一个：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* A redis object, that is a type able to hold a string / list / set */

/* The actual Redis Object */
//真正的redis对象
#define OBJ_STRING 0    /* String object. */
#define OBJ_LIST 1      /* List object. */
#define OBJ_SET 2       /* Set object. */
#define OBJ_ZSET 3      /* Sorted set object. */
#define OBJ_HASH 4      /* Hash object. */
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;encoding记录了对象所保存的值的编码，它的值可能是以下常量中的一个：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* Objects encoding. Some kind of objects like Strings and Hashes can be
 * internally represented in multiple ways. The &apos;encoding&apos; field of the object
 * is set to one of this fields for this object.
    对象编码。像字符串和哈希这种对象内部可以有多种方式标识。 encoding字段被设置为该对象的其中一个字段
 */
#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ptr是一个指针，指向实际保存值的数据结构，这个数据结构由type和encoding属性决定。&lt;br /&gt;
举个例子，如果一个redisObject的type属性为 OJB_LIST ，encoding属性为 OBJ_ENCODING_QUICKLIST，那么这个对象就是一个Redis列表（List），它的值保存在一个QuickList的数据结构内，而ptr指针就指向quickList的对象；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lru属性：记录了对象最后一次被命令程序访问的时间&lt;br /&gt;
    空转时长：当前时间减去键的值对象lru时间，就是该键的空转时长。Redis idletime命令可以打印出给定键的空转时长。&lt;br /&gt;
    如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;命令的类型检查和多态&quot;&gt;命令的类型检查和多态&lt;/h3&gt;

&lt;p&gt;当执行一个处理数据类型命令的时候，redis执行以下步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；&lt;/li&gt;
  &lt;li&gt;检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；&lt;/li&gt;
  &lt;li&gt;根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；&lt;/li&gt;
  &lt;li&gt;返回数据结构的操作结果作为命令的返回值；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;对象共享&quot;&gt;对象共享&lt;/h3&gt;

&lt;p&gt;    redis一般会把一些常见的值放在一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。&lt;br /&gt;
redis预分配的值对象如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE等等&lt;/li&gt;
  &lt;li&gt;包括0在内，小于REDIS_SHARED_INTEGERS的所有整数&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等的内存数据结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;    为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象？&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高&lt;/li&gt;
  &lt;li&gt;如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)&lt;/li&gt;
  &lt;li&gt;如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度是O(N)&lt;/li&gt;
  &lt;li&gt;如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其他对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N^2)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;引用计数以及对象的销毁&quot;&gt;引用计数以及对象的销毁&lt;/h3&gt;

&lt;p&gt;    redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；&lt;/li&gt;
  &lt;li&gt;当新创建一个对象时，它的refcount属性被设置为1；&lt;/li&gt;
  &lt;li&gt;当对一个对象进行共享时，redis将这个对象的rfcount加一；&lt;/li&gt;
  &lt;li&gt;当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的rfcount减一；&lt;/li&gt;
  &lt;li&gt;当对象的rfcount降至0时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;redis底层数据结构&quot;&gt;Redis底层数据结构&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;简单动态字符串 - sds&lt;/li&gt;
  &lt;li&gt;压缩列表 - ZipList&lt;/li&gt;
  &lt;li&gt;快表 - QuickList&lt;/li&gt;
  &lt;li&gt;字典/哈希表 - Dict&lt;/li&gt;
  &lt;li&gt;整数集 - IntSet&lt;/li&gt;
  &lt;li&gt;跳表 - ZSkipList&lt;br /&gt;
下面就逐一介绍下以上数据结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html
https://axlgrep.github.io/tech/redis-object.html&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="redis" />
      

      

      
        <summary type="html">redisObject概览</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Redis Guide</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Redis Guide" />
      <published>2024-06-11T00:00:00+08:00</published>
      <updated>2024-06-11T00:00:00+08:00</updated>
      <id>http://localhost:4000/redis-guide</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;redis-为什么这么快&quot;&gt;Redis 为什么这么快&lt;/h3&gt;

&lt;center&gt;   
&lt;img src=&quot;../../img/redis/guide/whyRedisFast.png&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;image-alt&quot; /&gt;
&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;Why is Redis so fast&lt;/div&gt;
&lt;/center&gt;

&lt;h3 id=&quot;完全基于内存&quot;&gt;完全基于内存&lt;/h3&gt;

&lt;p&gt;    redis作为一种内存导向型数据库系统，其关键特性在于将所有的数据实体，包括键值对及其相关的复杂数据结构，完全寄宿于内存之中。相较于依赖磁盘存储的传统数据库系统，redis巧妙地运用内存的高速读写特性，显著提升了系统的响应速度与整体性能表现。&lt;br /&gt;
    内存相对于磁盘具备无可比拟的读写速度优势，使得redis能够即时、高效地处理数据存取。在读取操作层面，redis无需经过耗时的磁盘I/O过程。只需要在内存空间内迅速定位所需数据，从而显著降低了访问延迟；而在写入操作时，redis同样直接作用于内存区域，新数据能立刻生效，仅在执行持久化策略时，例如RDB快照或AOF日志记录，数据才会被异步地或按需地同步到磁盘，以确保在系统重启后数据还能恢复，但此过程并不会妨碍redis在常规操作中维持其卓越的性能表现。&lt;br /&gt;
    服务器的内存是有限的，redis究竟是如何在有限内存空间中进行精细且高效的内存管理呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过期键删除&lt;/strong&gt;&lt;br /&gt;
    Redis支持为键设置过期时间（TTL），并且在键过期后会通过两种方式自动删除它们:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;惰性删除（Lazy Expire）：
  在访问某个键时，Redis会检查该键是否已经过期，如果已经过期，则在访问时将其删除。这意味胡总只有当客户端尝试访问过期键时，Redis才会执行删除操作。这种方式的优势在于避免了不必要的操作，只有在需要时才进行删除，但缺点是可能会导致过期键在一段时间内仍然占用内存。&lt;/li&gt;
  &lt;li&gt;定期删除（Active Expire）： 
  Redis周期性地（默认每秒10次）随机抽取一部分键，并检查它们的过期时间。如果发现某个键已经过期，则立即删除。这种方式可以保证过期键在一定时间内被及时删除，避免了过期键长时间占用内存。但定期删除会带来额外的CPU消耗，因为需要再每次抽取时检查键的过期时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    这两种方式结合起来，可以有效地管理和清理过期键，保证Redis的内存使用在合理范围内。同时，我们在日常开发中可以根据具体业务场景和需求调整过期策略的配置，以达到最佳的性能和内存利用率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存淘汰策略&lt;/strong&gt;&lt;br /&gt;
    内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的maxmemory），Redis会根据预先设置的淘汰策略来选择要删除的键，从而释放内存空间。通过合理选择和配置内存淘汰策略，可以有效地管理内存使用，防止内存溢出，并保证系统的稳定性和性能。&lt;br /&gt;
    常见的内存淘汰策略：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;LRU（最近最少使用）&lt;br /&gt;
   LRU策略会删除最近最少被访问的键。Redis会记录每个键最后一次被访问的时间戳，并定期检查这些时间戳，选择最久未被访问的键进行删除。LRU策略适用于缓存场景，通常最久未被访问的键可能是最不常用的，因此删除这些键可以释放更多的内存空间。&lt;/li&gt;
  &lt;li&gt;LFU（最不经常使用）&lt;br /&gt;
   LFU策略会删除最不经常被访问的键。Redis会记录每个键被访问的频率，并定期检查这些频率，选择访问频率最低的键进行删除。LFU策略适用于对访问频率较低的键进行淘汰，从而释放内存空间。&lt;/li&gt;
  &lt;li&gt;TTL（键的过期时间）&lt;br /&gt;
   TTL策略会删除已经过期的键。Redis会定期检查键的过期时间，并删除已经过期的键。通过设置键的过期时间，可以自动清理不再需要的数据，释放内存空间。&lt;/li&gt;
  &lt;li&gt;随机删除&lt;br /&gt;
   随机删除策略会随机选择一些键进行删除。虽然这种策略不考虑键的使用频率或过期时间，但在某些情况下可能会是一种简单且有效地淘汰方式，尤其在内存空间不足时。&lt;/li&gt;
  &lt;li&gt;淘汰固定数量的键&lt;br /&gt;
   淘汰固定数量的键策略会选择要删除的键数量，然后安装一定的规则（如LRU或LFU）来选择要删除的键。这种策略可以保证每次淘汰都释放固定数量的内存空间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当Redis的内存使用达到配置的 &lt;strong&gt;maxmemory&lt;/strong&gt; 限制时，就会触发内存淘汰策略，以释放内存空间。合理选择内存淘汰策略，并根据系统的需求设置 &lt;strong&gt;maxmemory&lt;/strong&gt; 参数，可以有效地管理内存使用，保证系统的稳定性和性能。通过合理配置内存限制和内存淘汰策略，可以有效地管理Redis的内存使用，保证系统在内存空间不足时能够及时释放内存，避免因内存溢出而导致系统功能下降或者崩溃。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;修改内存 &lt;strong&gt;maxmemory&lt;/strong&gt; 只需要在 &lt;strong&gt;redis.config&lt;/strong&gt; 配置文件中配置 &lt;strong&gt;maxmemory-policy&lt;/strong&gt; 参数即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;内存碎片管理&lt;/strong&gt;&lt;br /&gt;
    内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。&lt;br /&gt;
    在Redis中，由于数据的增删改查操作不断进行，会导致内存空间中出现大量的内存碎片。这些内存碎片虽然单个很小，但如果积累起来会导致内存碎片化，降低内存利用率，影响系统的性能和稳定性。&lt;br /&gt;
    为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;遍历内存空间：Redis会遍历整个内存空间，检查每个内存块的状态，包含已分配和未分配的内存块。&lt;/li&gt;
  &lt;li&gt;合并相邻的空闲内存块：Redis会尝试合并相邻的空间内存块，将它们合并成一个更大的内存块。这样可以减少内存碎片的数量，提高内存利用率。&lt;/li&gt;
  &lt;li&gt;移动数据：如果有必要，Redis可能会将数据从一个内存块移动到另一个内存块，以便更好地组织内存空间。这个过程可能会比较耗时，因为需要将数据从一个位置复制到另一个位置。&lt;/li&gt;
  &lt;li&gt;释放不再使用的内存块：最后，Redis会释放那些不再使用的内存块，以便它们可以被重新分配给新的数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    通过定期进行内存碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化的程度，提高内存利用率，从而提高系统的性能和稳定性。但是，内存碎片整理过程可能会消耗一定的系统资源，尤其在内存碎片较多的情况下。所以，通常情况下，Redis会选择在系统负载较低的时候进行碎片整理操作。&lt;/p&gt;

&lt;h3 id=&quot;高效的数据结构&quot;&gt;高效的数据结构&lt;/h3&gt;

&lt;p&gt;    Redis的每种对象其实都由 &lt;strong&gt;对象结构（redisObject）&lt;/strong&gt; 与 &lt;strong&gt;对应编码的数据结构&lt;/strong&gt; 组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://markdown.com.cn/basic-syntax/blockquotes.html
https://www.cnblogs.com/coderacademy/p/18099027
https://redis.io/docs/latest/develop/data-types/
https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="redis" />
      

      

      
        <summary type="html">Redis 为什么这么快</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Introduce</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Introduce" />
      <published>2024-01-10T00:00:00+08:00</published>
      <updated>2024-01-10T00:00:00+08:00</updated>
      <id>http://localhost:4000/introduce</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h1 id=&quot;图例&quot;&gt;图例&lt;/h1&gt;
&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD基本概念.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;DDD基本概念&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD基本概念.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;DDD基本概念&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;center&gt;
    &lt;a href=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD脑图.png&quot;&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; class=&quot;img-responsive img-centered&quot; alt=&quot;DDD脑图&quot; src=&quot;https://cdn.jsdelivr.net/gh/BiggerYellow/BiggerYellow.github.io/img/ddd/DDD脑图.png&quot; /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;DDD脑图&lt;/div&gt;
    &lt;/a&gt;
&lt;/center&gt;

&lt;h1 id=&quot;基本概念&quot;&gt;基本概念&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;通用类概念
    &lt;ol&gt;
      &lt;li&gt;领域驱动设计（DDD）&lt;br /&gt;
&lt;strong&gt;DDD是Domain-Driven Design的缩写，是Eric Evans于2004年提出的一种软件设计方法和理念。&lt;/strong&gt;&lt;br /&gt;
其主要思想是利用确定的业务模型来指导业务与应用的设计和实现。主张开发人员与业务人员持续地沟通和模型的持续迭代式演化，以保证业务模型与代码实现的一致性，从而实现有效管理业务复杂度，优化软件设计的目的。&lt;/li&gt;
      &lt;li&gt;模型（Model）&lt;br /&gt;
&lt;strong&gt;通常，模型是对对象、人或系统的信息表示。它通过较为简单的信息结构来代表我们需要理解的复杂事物或系统。&lt;/strong&gt;&lt;br /&gt;
地图、乐高都是模型，模型可以简化复杂事物的认知。通俗来说模型就是经验的抽象集合，平时听到的谚语、公式、定理，本质上都是一种模型。&lt;/li&gt;
      &lt;li&gt;建模（Modeling）&lt;br /&gt;
&lt;strong&gt;建模是构建模型的过程。&lt;/strong&gt;&lt;br /&gt;
在软件设计过程中，通过分析业务，将业务需求使用合适的模型表示出来，是建模的任务。模型可以作为业务分析的输出，并作为软件设计的重要理论基础。比如在分析一个电商应用的业务时，抽象出订单、商品等概念，进一步定义出模型，并用合适的图例表达，往往是UML来表达。&lt;/li&gt;
      &lt;li&gt;模型驱动设计（Model-Driven Design）&lt;br /&gt;
&lt;strong&gt;面向模型的设计方法，优先通过识别模型来简化业务设计。&lt;/strong&gt;&lt;br /&gt;
设计过程中，以模型的为中心，始终维护模型，并基于此指导设计。&lt;/li&gt;
      &lt;li&gt;软件设计（The Software Design）&lt;br /&gt;
&lt;strong&gt;软件设计从需求出发，对软件系统的整体结构、模块做出划分和规划，以便于具体代码的编写。&lt;/strong&gt;&lt;br /&gt;
由于软件具有非结构化、准确的定义，软件设计往往通过经验完成，无法通过某种特定的推理路线严格推导实现。&lt;/li&gt;
      &lt;li&gt;战略设计（Strategic Design）&lt;br /&gt;
&lt;strong&gt;战略设计也称为战略建模，是指对业务进行高层次的抽象和归类，主要手段包括理清上下文和进行子域的划分。&lt;/strong&gt;&lt;br /&gt;
战略设计关注模型的分离，其解决的问题的大的模型如何划分为小模型以及相互之间如何关联。战略设计的产出可以用于指导团队协作，使得规模巨大的软件可以被合理拆分。&lt;br /&gt;
战略设计的产出通常为上下文图，以及模块及微服务划分。&lt;/li&gt;
      &lt;li&gt;战术设计（Tactical Design）&lt;br /&gt;
&lt;strong&gt;战术设计也称为战术建模，是指对特定上下文下的模型进行详细设计。&lt;/strong&gt;&lt;br /&gt;
战术设计的对象包括聚合、实体和值对象，其目标时明确它们是什么以及相互之间有何关系。战术设计的产出可以使用UML表达的类图，需要细化到具体的属性，同时确保在代码级别可实现。&lt;/li&gt;
      &lt;li&gt;软件（Software）&lt;br /&gt;
&lt;strong&gt;DDD讨论下的软件是指，用于解决具体业务问题的计算机程序，既可以是单体也可以是分布式系统。&lt;/strong&gt;&lt;br /&gt;
软件设计是DDD的最终目的，使用DDD的各种工具可以指导软件设计，最终构建出健壮、容易维护的系统。&lt;/li&gt;
      &lt;li&gt;原则（Principle）&lt;br /&gt;
&lt;strong&gt;为了更好的践行DDD，需要遵守几个原则：通用语言、聚焦核心域、协作共创和持续建模。&lt;/strong&gt;&lt;br /&gt;
这些原则是为了更好的服务业务，从业务驱动模型设计。&lt;/li&gt;
      &lt;li&gt;通用语言（Ubiquitous Language）&lt;br /&gt;
&lt;strong&gt;通用语言是指在软件设计中，业务人员和开发人员需要使用无歧义的统一语言来对话。&lt;/strong&gt;&lt;br /&gt;
这些语言包括对概念的统一理解和定义，以及业务人员参与到软件建模中，否则业务的变化会造成软件巨大的变化。&lt;/li&gt;
      &lt;li&gt;聚焦核心域（Focus）&lt;br /&gt;
&lt;strong&gt;核心域是最关键的业务逻辑，聚焦核心域决定了软件的定位和投资重心。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;协作共创（Collaboration）&lt;br /&gt;
&lt;strong&gt;协作共创是指领域专家和业务专家共同建模。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;持续建模（Continuous）&lt;br /&gt;
&lt;strong&gt;持续建模是指模型需要随业务变化而被及时更新。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;上下文（Context）&lt;br /&gt;
&lt;strong&gt;上下文是指不同语境下的概念虽然有相同的用词，可能具有不同的含义。&lt;/strong&gt;&lt;br /&gt;
在软件设计中，因为自然语言的原因，相同的用词导致实际是不同概念，会对建模和软件设计带来误导。同时，不同的上下文也是识别模型边界的手段。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;领域分析类概念
    &lt;ol&gt;
      &lt;li&gt;问题空间（Problem Space）&lt;br /&gt;
&lt;strong&gt;待解决的业务问题的集合。&lt;/strong&gt;&lt;br /&gt;
在DDD实践中，应该明确区分问题空间和解空间，避免混为一谈。&lt;/li&gt;
      &lt;li&gt;领域（Domain）&lt;br /&gt;
&lt;strong&gt;领域是业务相关知识的集合。&lt;/strong&gt;&lt;br /&gt;
通常来说，领域就是业务知识。业务有一些内在规则，存在专业性。计算机只是业务规则的自动化。&lt;/li&gt;
      &lt;li&gt;子域（Sub Domain）&lt;br /&gt;
&lt;strong&gt;一个子域是领域的一部分。&lt;/strong&gt;&lt;br /&gt;
为了降低业务理解复杂度，DDD实践中通常将领域划分为子域，通过分而治之的方法分析问题。&lt;/li&gt;
      &lt;li&gt;核心域（Core Domain）&lt;br /&gt;
&lt;strong&gt;核心域是指领域中最核心的部分，通常对应企业的核心业务。&lt;/strong&gt;&lt;br /&gt;
核心域需要我们投入最大精力，进行充分的分析。因为它是企业能运转的基础。&lt;/li&gt;
      &lt;li&gt;支撑域（Support Domain）&lt;br /&gt;
&lt;strong&gt;支撑域是一种特殊的子域，是指为了实现核心业务而不得不开发的业务所对应的相关知识的集合。&lt;/strong&gt;&lt;br /&gt;
例如，活动平台业务属于电商的支撑域，因为该业务对电商企业并不是必需的，其存在的意义仅在于放大利润。&lt;/li&gt;
      &lt;li&gt;通用域（General Domain）&lt;br /&gt;
&lt;strong&gt;通用域是另一种特殊的子域，对应的是业界已经有成熟方案的业务。&lt;/strong&gt;&lt;br /&gt;
通用域可以看做一种特殊的支撑域，可以使用标准部件来实现，短信通知、邮件等领域问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;建模类概念
    &lt;ol&gt;
      &lt;li&gt;解空间（Solution Space）&lt;br /&gt;
&lt;strong&gt;解空间是一个数学概念。是指满足问题的所有约束前提下，所有可行解的集合。在DDD的上下文中，指的是所有可能的解决方案的集合。&lt;/strong&gt;&lt;br /&gt;
解空间是相对于问题空间存在的，认识到解空间存在的好处是解空间可以通过一些方法从问题空间导出，而不是通过猜测得出的。&lt;/li&gt;
      &lt;li&gt;领域模型（Model）&lt;br /&gt;
&lt;strong&gt;领域模型是业务概念在程序中的一种表达方式。&lt;/strong&gt;&lt;br /&gt;
领域模型可以用来设计和理解整个软件结构。面向对象设计中的类概念是领域模型的一种表达方式。与此类似，UML的建模方法也可以应用于在对领域模型的表达上。在DDD实践中，领域模型应当尽量简洁，能反应业务概念即可。&lt;/li&gt;
      &lt;li&gt;限界上下文（Bounded context）&lt;br /&gt;
&lt;strong&gt;限界上下文是有明确边界的上下文。在DDD中领域模型会被限定在限界上下文中。&lt;/strong&gt;&lt;br /&gt;
限界上下文强调概念的一致性。虽然传统的方法学已经在追求概念的一致性，但是忽略的系统的庞大性，不论系统多庞大，在系统任何位置同一概念通用。DDD不追求全局的一致性，而是将系统拆成多块，在相同的上下文中实现概念一致性。&lt;br /&gt;
识别上下文可以从概念的二义性着手，比如商品的概念在物流、交易、支付含义完全不一样，但具有不同内涵和外延，实际上他们处在不同上下文。&lt;br /&gt;
限界上下文可以用于微服务划分、避免模型的不正确复用带来的问题。&lt;/li&gt;
      &lt;li&gt;实体（Entity）&lt;br /&gt;
&lt;strong&gt;实体是在相同限界上下文中具有唯一标识的领域模型，可变，通过标识判断同一性。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;值对象（Value Object）&lt;br /&gt;
&lt;strong&gt;值对象是一种特殊的领域模型，不可变，通过值判断同一性。&lt;/strong&gt;&lt;br /&gt;
实体中可以使用ID标识，但是值对象用属性标识，任何属性的变化都视为新的值对象。比如一个银行账户，可以由ID唯一标识，币种和余额可以被修改但是还是同一个账户；交易单中的金额由币种和数值组成，无论修改哪一个属性，金额都不再是原来的金额。&lt;/li&gt;
      &lt;li&gt;聚合（Aggregate）&lt;br /&gt;
&lt;strong&gt;聚合是一组生命周期强一致，修改规则强关联的实体和值对象的集合，表达统一的业务含义。&lt;/strong&gt;&lt;br /&gt;
聚合的意义在于让业务统一一致，在面向对象中有非常重要的价值。比如，订单中有多个订单项，订单的总价是根据订单项计算而来的。如果没有经验的开发者直接对订单项做出修改，而不是由订单统一处理业务逻辑，会造成业务的一致性问题。&lt;br /&gt;
聚合需要在相同的上下文中，不能跨上下文。&lt;/li&gt;
      &lt;li&gt;聚合根（Aggregate Root）&lt;br /&gt;
&lt;strong&gt;聚合根是聚合中最核心的实体，其他的实体和值对象都从属于这个实体&lt;/strong&gt;&lt;br /&gt;
要管理聚合必须使用一个聚合根，然后使用聚合根来实现发现、持久化聚合的作用，完成统一的业务意义。一个聚合中有且只有一个聚合根，聚合也可以只会有一个单独的实体。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;软件设计类概念
    &lt;ol&gt;
      &lt;li&gt;模块（Module）&lt;br /&gt;
&lt;strong&gt;模块是一组类或对象组成的集合。&lt;/strong&gt;&lt;br /&gt;
在DDD实践中推荐使用限界上下文和聚合来指导模块划分。同时，如果不是特别复杂的业务逻辑也可以不遵守该模式。&lt;/li&gt;
      &lt;li&gt;仓储（Repository）&lt;br /&gt;
&lt;strong&gt;仓储是以持久化领域模型为职责的类。&lt;/strong&gt;&lt;br /&gt;
仓储的目的是屏蔽业务逻辑和持久化基础设施的差异。例如，对于同样的持久化业务需求，在采用关系型数据库和非关系型数据库作为存储基础设施时的实现细节是有所不同的。&lt;br /&gt;
软件的设计往往是围绕着对数据的修改完成的。经验不多的开发者往往会认为，软件的开发过程就是对数据库的增删改查。但实际上基于该认知的软件设计让软件难以维护。&lt;br /&gt;
对于采用关系数据库作为存储基础设置的项目，仓储层可以被ORM实现。若不使用ORM，则需要自己实现仓储。&lt;/li&gt;
      &lt;li&gt;服务（Service）&lt;br /&gt;
&lt;strong&gt;服务是领域模型的操作者，负责领域内的业务规则的实现。&lt;/strong&gt;&lt;br /&gt;
在实践中如果使用主、客体的思维来进行设计，则服务为主体，领域模型为客体。使用拟人化的方式来对服务进行命名，可以让开发者更容易理解。比如一个维护客户数据的CRM应用中，客户数据被抽象为模型：Client，对应的服务可以设计为：ClientManager。&lt;/li&gt;
      &lt;li&gt;工厂（Factory）&lt;br /&gt;
&lt;strong&gt;工厂是以构建领域模型（实体或值对象）为职责的类或方法。&lt;/strong&gt;&lt;br /&gt;
工厂可以利用不同的业务参数构建不同的领域模型。对于简单的业务逻辑实现可以不使用工厂。工厂的实现不一定是类的形式，也可以是具备工厂功能的方法。&lt;br /&gt;
在面向对象程序设计中，工厂是一种设计模型。在广义的工厂模式中，工厂可以根据不同的规则的业务需求构造不同的对象。例如在Redis连接客户端的实现中，可以使用Redis单机、哨兵、集群等不同的方式来构建Redis连接客户端。&lt;/li&gt;
      &lt;li&gt;策略（Strategy）&lt;br /&gt;
&lt;strong&gt;策略是业务规则的实现方式。&lt;/strong&gt;&lt;br /&gt;
例如通知业务，可以使用不同的渠道来实现，不同渠道的实现逻辑可以认为是不同的策略。在面向对象程序设计中，策略模式也是一种设计模式，是多态的一种实现模式。&lt;br /&gt;
策略通常会搭配着接口来设计。如果说接口是一种契约，那策略就是契约的履约方式。&lt;/li&gt;
      &lt;li&gt;规格（Specification）&lt;br /&gt;
&lt;strong&gt;规格是一些特殊的业务规则。通常表现为用于校验、查询和搜索条件。&lt;/strong&gt;&lt;br /&gt;
在实践中，规则可以被设计为灵活的查询或校验条件，也可以被抽象出来以便复用。&lt;br /&gt;
例如，在JPA、MongoDB、ElasticSearch和一些具有查询能力的ORM都大量使用这种设计方式，同样的在应用程序中我们也可以参考这种设计模式，把业务规则提取处理。&lt;/li&gt;
      &lt;li&gt;分层架构&lt;br /&gt;
&lt;strong&gt;分层架构是指在软件设计过程中按照既定的原则将不同的功能实现拆分到不同的层级进行实现的一种设计方式。每个层级有独立的职责，多个层次协同以提供完整功能。按照DDD的分层模型，通常可以划分为：接入层、应用层、领域层、基础设施层。&lt;/strong&gt;&lt;br /&gt;
分层架构在具体的软件中可以表现为不同的形式。例如，在分布式系统中，不同层级的软件实现，可以表现为独立部署的服务。而在单体系统中，分层可以用不同的模块或包来实现。&lt;br /&gt;
分层架构的设计理念与计算机网络的层级结构类似，上层依赖下层的实现，而下层实现无需关心上层实现。例如,HTTP协议构建TCP协议之上，TCP协议只负责提供传输层的能力，而不需要知道具体的应用层协议。&lt;br /&gt;
分层架构中层级的数量需要依照系统复杂度来定，并不需要死板地按照DDD推荐的四层来进行设计。在简单的系统中，可以通过减少分层来避免样板代码，减少冗余。例如在web系统中有时候只有一种接入方式，接入层和应用层能力高度重叠，可以考虑直接使用应用层替代接入层。&lt;br /&gt;
软件框架的使用，通常会引入新的层级，从而影响系统整体的分层架构。例如，ORM框架本身就提供了对Repository的一层抽象。&lt;/li&gt;
      &lt;li&gt;接入层（Interface）&lt;br /&gt;
&lt;strong&gt;接入层负责的是系统的输入和输出。&lt;/strong&gt;&lt;br /&gt;
接入层只关心沟通协议，不关心业务相关的数据校验。接入层的实现是与业务应用强相关的，不同的业务应用有不同的实现方式。例如，对于普通的Web应用，基于HTTP协议的API是一种接入层实现方式。&lt;br /&gt;
接入层特点：&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;接入层对应用数据透明，只关心数据格式而不关心数据的内容&lt;/li&gt;
      &lt;li&gt;在大部分单体系统中接入层通常被框架实现。例如，在SpringBoot框架中，HTTP协议的API设计不需要关注HTTP协议本身。&lt;/li&gt;
      &lt;li&gt;在分布式系统中接入层通常被网关实现。  &lt;br /&gt;
    9. 应用层（Application）&lt;br /&gt;
&lt;strong&gt;应用层，组织业务场景，编排业务，隔离场景对领域层的差异。&lt;/strong&gt;&lt;br /&gt;
应用层遵循面向对象核心思想中的关注点分离概念。应用层的关注点在于业务场景的处理。例如：对于一个服务多种类型用户的应用，toC的网页界面和后台管理页面对应的是不同的业务场景。对于新用户注册这个业务来说，
通过ToC的网页注册和通过后台管理页面进行注册是不同的业了务场景。然而，用户注册在系统层面的基本逻辑是一样的。所以，用户注册的基本业务逻辑可以交由领域层来实现。而两种不同渠道进行用户注册所需要进行的身份验证等逻辑，
可以设计在应用层进行实现。这样便能达到关注点分离，复用核心业务逻辑的目的。&lt;br /&gt;
应用层的特点：&lt;/li&gt;
      &lt;li&gt;关心处理完一个完整的业务&lt;/li&gt;
      &lt;li&gt;该层只负责业务编排，对象转换，而具体的业务逻辑由领域层实现&lt;/li&gt;
      &lt;li&gt;虽然不关心请求从何处来，但关心谁来、做什么、有没有权限做&lt;/li&gt;
      &lt;li&gt;利用不同的领域服务来解决问题&lt;/li&gt;
      &lt;li&gt;对最终一致性有要求的业务和事务处理需要放到应用层来处理&lt;/li&gt;
      &lt;li&gt;功能权限放到这层&lt;br /&gt;
    10. 领域层（Domain）&lt;br /&gt;
&lt;strong&gt;领域层，实现具体的业务逻辑、规则，为应用层提供无差别的服务能力。&lt;/strong&gt;&lt;br /&gt;
实际处理业务的地方，领域层需要对应用层提供无差别的服务和能力。例如，对于用户注册的场景，用户既可以通过邮箱自己注册，也可以由管理员在后台进行添加。用户注册的核心逻辑可以由领域层完成，但是对于不同渠道进行用户注册的参数校验和权限验证等逻辑则由应用层实现。&lt;br /&gt;
领域层的特点：&lt;/li&gt;
      &lt;li&gt;不关心场景，关心模型完整性和业务规则&lt;/li&gt;
      &lt;li&gt;不关心谁来，不关心场景完整的业务，关心当前上下文的业务完整&lt;/li&gt;
      &lt;li&gt;强一致性事务放到此层，聚合的事务是理所当然的&lt;/li&gt;
      &lt;li&gt;对应到分布式系统中的domain service、后台等概念&lt;/li&gt;
      &lt;li&gt;领域层做业务规则验证&lt;/li&gt;
      &lt;li&gt;数据权限放到这层（比如只允许删除自己创建的商品），因为数据权限涉及业务规则&lt;/li&gt;
      &lt;li&gt;根据业务情况，参考反范式理论，跨上下文使用只对象做必要的数据冗余&lt;br /&gt;
    11. 基础设施层（Infrastructure）&lt;br /&gt;
&lt;strong&gt;基础设施层，提供具体的技术实现，比如存储，基础设施对业务保持透明。&lt;/strong&gt;&lt;br /&gt;
对于基础设施层来说，基础设施层并不是指Mysql、Redis等外部组件，而是外部组件的适配器，Hibernate、Mybatis、Redis Template等，因此再DDD中适配器模式被多次提到，基础设施层往往不能单独存在，还是要依附于领域层。基础设施层的适配器还包括了外部系统的适配，互联网产品系统的外部系统非常多，常见的有活体检测、风控系统、税务发票等。&lt;br /&gt;
基础设施层的特点：&lt;/li&gt;
      &lt;li&gt;关心存储、通知、第三方系统等外部设施&lt;/li&gt;
      &lt;li&gt;基础设施的权限由配置到应用的凭证控制，例如数据库、对象存储的凭证，基础设施层不涉及用户的权限&lt;br /&gt;
    12. 部署架构&lt;br /&gt;
&lt;strong&gt;部署架构是指具体的架构实现。&lt;/strong&gt;&lt;br /&gt;
主要是在分布式系统、单体系统，甚至在客户端软件中体现。&lt;br /&gt;
把逻辑架构和部署构架区分开可以很好的理解软件设计上和部署上的不同，对于应用架构来说，逻辑上的设计不一定对应部署架构。&lt;br /&gt;
这样就很好理解DDD在不同场合中的使用方式，避免生搬硬套。当DDD的分层结构在单体应用中使用时，每层可能使用包、模块来表达，在微服务中使用时，每层可能由不同角色的微服务来完成。&lt;br /&gt;
    13. 微服务（Micro Service）&lt;br /&gt;
&lt;strong&gt;微服务是一种低耦合的分布式应用系统。&lt;/strong&gt;&lt;br /&gt;
维基百科的定义是：一种软件开发技术-面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。这个定义没有问题，但是忽略了一个重要的信息，微服务是一种分布式架构，微服务必须面对分布式系统的各种问题。&lt;br /&gt;
分布式系统是通过计算机网络连接、协同工作的IT系统，因此使用DDD时候，需要为这种系统做适配，而不是简单的做出切分。&lt;br /&gt;
    14. 单体（Monomer）&lt;br /&gt;
&lt;strong&gt;单体是主要业务实现和部署在单一服务器上的应用。&lt;/strong&gt;&lt;br /&gt;
单体系统是相对于微服务来说的，其特点是主要的实现在单一的服务器中。&lt;br /&gt;
    15. 分布式应用系统（Distributed）&lt;br /&gt;
&lt;strong&gt;分布式应用系统是建立在计算机网络之上的应用软件系统，不同单元通过计算机网络集成。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;事件风暴类概念
    &lt;ol&gt;
      &lt;li&gt;事件风暴（Event Storming）&lt;br /&gt;
&lt;strong&gt;事件风暴是一种以工作坊的形式，使用DDD建模的方式。&lt;/strong&gt;&lt;br /&gt;
事件风暴是一种捕获行为需求的方法，类似传统软件的开发用例分析。所有人员（领域专家和技术专家）对业务行为进行一次发散，并最终收敛达到业务的统一。&lt;/li&gt;
      &lt;li&gt;领域事件（Domain Event）&lt;br /&gt;
&lt;strong&gt;事件是系统状态发生的某种客观现象，领域事件是和领域有关的事件。&lt;/strong&gt;&lt;br /&gt;
领域事件是在业务上真实发生的客观事实，这些事实对系统会产生关键影响，是观察业务系统变化的关键点。领域事件一般是领域专家关心的。&lt;br /&gt;
事件的评价方式是系统状态是否发生变化。系统状态变化意味着领域模型被业务规则操作，这是观察系统业务的好办法。&lt;br /&gt;
识别领域事件的线索有：&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;是否产生了某种数据&lt;/li&gt;
      &lt;li&gt;系统状态是否发生改变，无论这种状态存放到数据库还是内存&lt;/li&gt;
      &lt;li&gt;是否对外发送了某些消息&lt;br /&gt;
    3. 业务规则（Policy）&lt;br /&gt;
&lt;strong&gt;业务规则是指对业务逻辑的定义和约束。&lt;/strong&gt;&lt;br /&gt;
不同的业务规则往往意味着不同的领域事件被触发，未来在技术实现时可能是一些分支条件，对应DDD实现中可能通过领域服务、规格、策略等方式实现。&lt;br /&gt;
业务规则的识别是为了将数据和算法分开。&lt;br /&gt;
    4. 命令（Command）&lt;br /&gt;
&lt;strong&gt;命令时执行者发起的操作，构成要件是执行者和行为。&lt;/strong&gt;&lt;br /&gt;
命令可以类比于UML分析中的业务用例，是某个场景中领域事件的触发动作。&lt;br /&gt;
    5. 执行者（Actor）&lt;br /&gt;
&lt;strong&gt;执行者是指使用系统的主体，是导致系统状态变化的触发源。&lt;/strong&gt;&lt;br /&gt;
执行者有点像UML的涉众，不过区别是执行者不仅是用户，还包括外部系统和本系统。在事件风暴中，执行者可以是：用户、外部系统、本系统、定时器。&lt;br /&gt;
    6. 用户（User）&lt;br /&gt;
&lt;strong&gt;用户是执行者的一种，是指使用软件或服务的人。&lt;/strong&gt;&lt;br /&gt;
用户可以有不同的角色，通常我们会把不同角色的相似行为作为不同的命令来处理，有可能得到同样的事件。&lt;br /&gt;
    7. 外部系统（Out System）&lt;br /&gt;
&lt;strong&gt;外部系统是执行者的一种，系统开放API的调用发起者。&lt;/strong&gt;&lt;br /&gt;
有一些系统会提供对外的API给外部系统，这时候外部系统也会发出命令让系统产生事件，这里的外部系统特指作为执行者的外部系统。&lt;br /&gt;
    8. 本系统（System）&lt;br /&gt;
&lt;strong&gt;本系统是执行者的一种，指系统本身。&lt;/strong&gt;&lt;br /&gt;
事件的触发可以由用户、外部系统、定时器触发，也可以由上一个事件触发，因此这里的触发者是系统本身。&lt;br /&gt;
    9. 定时器（Timer）&lt;br /&gt;
&lt;strong&gt;定时器是执行者的一种，通常是定时任务。&lt;/strong&gt;&lt;br /&gt;
定时器可以作为执行者，不过需要区别于本系统这个触发源。定时器可以看待为外部一个时间信号源，类似于计算机中主机中的振荡器。&lt;br /&gt;
    10. 参与人（Participants）&lt;br /&gt;
&lt;strong&gt;作为工作坊的参与人员（应区别于执行者）&lt;/strong&gt;&lt;br /&gt;
参与人只是一种角色，而非具体的一个人，可以多个自然人做群体参与，也可以一人一人分饰不同的角色。&lt;br /&gt;
在开始工作坊之前，参与人需要满足一些条件：&lt;/li&gt;
      &lt;li&gt;参与人需要对解决的问题和产出目标达成共识&lt;/li&gt;
      &lt;li&gt;参与人需要DDD的基本知识或接受过基本培训&lt;/li&gt;
      &lt;li&gt;领域专家、技术专家需要能全程参加&lt;br /&gt;
    11. 领域专家（Domain Expert）&lt;br /&gt;
&lt;strong&gt;领域专家是指熟悉业务规则的人，在工作坊中一般是能敲定业务规则的人。&lt;/strong&gt;&lt;br /&gt;
在实际的事件风暴工作坊中，领域专家是一个比技术专家更难获得的人，一个合格的、能让工作坊进展下去的领域专家需要有几个要求：
    1. 了解现有业务情况
    2. 能对具体的业务方向做出结论性的输出
在做工作坊时，需要分清现状（As-IS）和目标（To-Be）业务，现状业务很多人能说出来，不过真正的领域专家能对目标业务做出描述的人。&lt;br /&gt;
    12. 技术专家（Tech Expert）
&lt;strong&gt;技术专家是指熟悉技术方案和实现方式的人，能给出可行的技术方案和了解基础设计的限制条件。&lt;/strong&gt;&lt;br /&gt;
技术专家需要能对现有的技术做出描述，而未来的技术选型可能是动态的，能有一定预见性最好。技术专家往往是当前团队中最熟悉架构和代码的人。&lt;br /&gt;
    13. 主持人（Facilitator）&lt;br /&gt;
&lt;strong&gt;主持人是工作坊流程的推动者，以及DDD方法论的守护者。&lt;/strong&gt;&lt;br /&gt;
在一些工作坊中，主持人往往是外部的咨询师，他们有大量的实践经验，需要能对DDD的概念、方法有成体系的研究，并能推动工作坊进行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="DDD" />
      

      

      
        <summary type="html">图例 DDD基本概念</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Bitoperation</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Bitoperation" />
      <published>2023-11-18T00:00:00+08:00</published>
      <updated>2023-11-18T00:00:00+08:00</updated>
      <id>http://localhost:4000/BitOperation</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h4 id=&quot;常见运算符&quot;&gt;常见运算符&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;按位与 &amp;amp;&lt;br /&gt;
  两个操作数相应的二进制位都为1，结果为1，反之为0。&lt;/li&gt;
  &lt;li&gt;按位或 |&lt;br /&gt;
  两个操作数相应的二进制位只要有一个为1，结果为1，反之为0。&lt;/li&gt;
  &lt;li&gt;按位异或 ^&lt;br /&gt;
  两个操作数相应的二进制位值只要相同，运算结果为0，反之为1。&lt;/li&gt;
  &lt;li&gt;按位取反 ~&lt;br /&gt;
  单目运算符，只有一个操作数，是将操作数相应的二进制位数取反。&lt;/li&gt;
  &lt;li&gt;左移 «  
  将一个数的各二进制位左移若干位，移动的位数由右操作数指定。&lt;/li&gt;
  &lt;li&gt;右移 »&lt;br /&gt;
  与左移相反&lt;/li&gt;
  &lt;li&gt;二进制数最低位1和后面所有0组成的 \(2^k\) lowbit&lt;br /&gt;
  将x的二进制所有位全部取反，再加1，就可以得到 -x 的二进制编码。例如6的二进制编码是 110 ，全部取反后得到 001，加1得到010。&lt;br /&gt;
  设原先x的二进制编码是 (…)10…00，全部取反后得到[…]01…11，加1后得到[…]10…00，也就是-x的二进制编码。这里x表示二进制中第一个1是x最低位的1。&lt;br /&gt;
  (…)和[…]中省略号的每一位分别相反，所以 x&amp;amp;-x = (…)10…00 &amp;amp; […]10…00 = 10…00，得到的结果就是 lowbit。&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">常见运算符 按位与 &amp;amp;   两个操作数相应的二进制位都为1，结果为1，反之为0。 按位或 |   两个操作数相应的二进制位只要有一个为1，结果为1，反之为0。 按位异或 ^   两个操作数相应的二进制位值只要相同，运算结果为0，反之为1。 按位取反 ~   单目运算符，只有一个操作数，是将操作数相应的二进制位数取反。 左移 «    将一个数的各二进制位左移若干位，移动的位数由右操作数指定。 右移 »   与左移相反 二进制数最低位1和后面所有0组成的 \(2^k\) lowbit   将x的二进制所有位全部取反，再加1，就可以得到 -x 的二进制编码。例如6的二进制编码是 110 ，全部取反后得到 001，加1得到010。   设原先x的二进制编码是 (…)10…00，全部取反后得到[…]01…11，加1后得到[…]10…00，也就是-x的二进制编码。这里x表示二进制中第一个1是x最低位的1。   (…)和[…]中省略号的每一位分别相反，所以 x&amp;amp;-x = (…)10…00 &amp;amp; […]10…00 = 10…00，得到的结果就是 lowbit。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Mathematicalformula</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Mathematicalformula" />
      <published>2023-10-18T00:00:00+08:00</published>
      <updated>2023-10-18T00:00:00+08:00</updated>
      <id>http://localhost:4000/MathematicalFormula</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;数学公式&quot;&gt;数学公式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;等差数列&quot;&gt;等差数列&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;定义式
https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/1129192?fr=ge_ala&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;等比数列&quot;&gt;等比数列&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;排列组合&quot;&gt;排列组合&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">数学公式</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Algorithmtips</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Algorithmtips" />
      <published>2023-10-18T00:00:00+08:00</published>
      <updated>2023-10-18T00:00:00+08:00</updated>
      <id>http://localhost:4000/AlgorithmTips</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h3 id=&quot;常用算法小技巧&quot;&gt;常用算法小技巧&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;向下取整&quot;&gt;向下取整&lt;/h4&gt;
    &lt;p&gt;  向下取整函数floor(val)的结果是小于或等于val的最大整数。&lt;br /&gt;
  例如:求x除以3的向下取整数字，直接除以3即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;向上取整&quot;&gt;向上取整&lt;/h4&gt;
    &lt;p&gt;  向上取整函数ceil(val)的结果是大于或等于val的最小整数。将其转化为向下取整思路，先将x加上要除以的n-1，再除以n即可。&lt;br /&gt;
  例如:求x除以3的向上取整数字，为避免浮点数运算，需要先将x加2再直接除以3，即ceil((x/3)=(x+2)/3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="algorithm" />
      

      

      
        <summary type="html">常用算法小技巧</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Datatype</title>
      <link href="http://localhost:4000/" rel="alternate" type="text/html" title="Datatype" />
      <published>2022-09-26T00:00:00+08:00</published>
      <updated>2022-09-26T00:00:00+08:00</updated>
      <id>http://localhost:4000/dataType</id>
      <content type="html" xml:base="http://localhost:4000/">&lt;h1 id=&quot;mysql基本数据类型&quot;&gt;Mysql基本数据类型&lt;/h1&gt;

&lt;h2 id=&quot;数值类型&quot;&gt;数值类型&lt;/h2&gt;
&lt;h3 id=&quot;整数类型&quot;&gt;整数类型&lt;/h3&gt;
&lt;p&gt;  数值型数据类型主要用来存储数字,Mysql提供了多种数值数据类型,不同的数据类型提供不同的取值范围,可以存储的值范围越大,其所需要的存储空间也会越大.&lt;br /&gt;
  mysql主要提供的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT.整数类型的属性字段可以添加AUTO_INCREMENT自增约束条件.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据范围&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Storage(Bytes)&lt;/th&gt;
      &lt;th&gt;Minimum Value Signed&lt;/th&gt;
      &lt;th&gt;Minimum Value Unsigned&lt;/th&gt;
      &lt;th&gt;Maximum Value Signed&lt;/th&gt;
      &lt;th&gt;Maximum Value Unsigned&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;TINYINT&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;-128&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;127&lt;/td&gt;
      &lt;td&gt;255&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SMALLINT&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;-32768&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;32767&lt;/td&gt;
      &lt;td&gt;65535&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MEDIUMINT&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;-8388608&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;8388607&lt;/td&gt;
      &lt;td&gt;16777215&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INT&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;-2147483648&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2147483647&lt;/td&gt;
      &lt;td&gt;4294967295&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIGINT&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;\(-2^63\)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2^63 - 1&lt;/td&gt;
      &lt;td&gt;2^64 - 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FLOAT&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;-3.402823466E+38&lt;/td&gt;
      &lt;td&gt;1.175494351E-38&lt;/td&gt;
      &lt;td&gt;-1.175494351E-38&lt;/td&gt;
      &lt;td&gt;3.402823466E+38&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DOUBLE&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;-1.7976931348623157E+308&lt;/td&gt;
      &lt;td&gt;2.2250738585072014E-308&lt;/td&gt;
      &lt;td&gt;-2.2250738585072014E-308&lt;/td&gt;
      &lt;td&gt;1.7976931348623157E+308&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;示例:&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int(4)&lt;/code&gt;&lt;br /&gt;
该声明指明,该字段中的数据一般只显示4位数字.&lt;/p&gt;

&lt;p&gt;注意点:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;显示宽度和数据类型取值范围是无关的。显示宽度只是指明mysql最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充；如果掺入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且可以显示出来。 &lt;br /&gt;
例如:向year字段插入一个数值12345，当使用select查询该列值的时候，mysql显示的将是完整的带有5位数字的12345，而不是4位数字的值。&lt;br /&gt;
其他整数型数据类型也可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度。  &lt;br /&gt;
显示宽度只用于显示，并不能限制取值范围和占用空间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应该根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。&lt;/p&gt;

&lt;h3 id=&quot;浮点数类型和定点数类型&quot;&gt;浮点数类型和定点数类型&lt;/h3&gt;
&lt;p&gt;mysql中使用浮点数和定点数表示小数。&lt;br /&gt;
浮点数类型有两种:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;单精度浮点类型(FLOAT)&lt;/li&gt;
  &lt;li&gt;双精度浮点类型(DOUBLE)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;定点数类型只有一种:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DECIMAL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浮点数类型和定点数类型都可以用(M, N)来表示。其中，用M称为精度，表示总共的位数；N称为标度，表示小数的位数。&lt;br /&gt;
DECIMAL类型不同于FLOAT和DOUBLE，DECIMAL实际是以串存放的，可能的最大取值范围和DOUBLE一样，但是其有效的取值范围由M和D的值来决定。如果改变M而固定D，则取值范围将随着M的变大而变大。&lt;/p&gt;

&lt;p&gt;注意点:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;无论是定点数还是浮点数类型，如果用户指定的精度超出精度范围，则会四舍五入。&lt;br /&gt;
FLOAT和DOUBLE在不指定精度操作时，默认会按照实际的精度(由计算机硬件和操作系统决定)，DECIMAL若不指定精度则默认为(10, 0);&lt;br /&gt;
在mysql中，定点数以字符串形式存储，在对精度要求比较高的时候，使用DECIMAL的类型比较好，另外，两个浮点数进线减法和比较运算时，容易出现问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考链接:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;https://dev.mysql.com/doc/refman/5.7/en/numeric-types.html&lt;br /&gt;
https://zhuanlan.zhihu.com/p/543865001&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      
        <category term="mysql" />
      

      

      
        <summary type="html">Mysql基本数据类型</summary>
      

      
      
    </entry>
  
</feed>
